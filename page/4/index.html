<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yangxin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-读书笔记/浏览器安全" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.718Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/">浏览器安全</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><h3 id="规范形式"><a href="#规范形式" class="headerlink" title="规范形式"></a>规范形式</h3><blockquote>
<p>scheme：&#x2F;&#x2F;[user:password@]domain:port&#x2F;path?query_string#fragments</p>
</blockquote>
<ul>
<li>scheme</li>
</ul>
<p>方案名，也常被当为协议名混用。一般为http、https、ftp等，告诉浏览器应该如何进行连接。浏览器在识别时不区分大小写</p>
<ul>
<li>[user:password]。可选</li>
</ul>
<p>验证信息，提供登陆主机的身份信息，不建议使用这种方式进行身份验证，因为传递时是明文，且并非所有浏览器都支持</p>
<ul>
<li>domain</li>
</ul>
<p>主机名，使用域名，主机名或者合法ip均可。如果要使用ipv6地址，则地址必须要在中括号([])中括起来，如http:&#x2F;&#x2F;[::1]。不区分域名大小写</p>
<ul>
<li>port</li>
</ul>
<p>端口号，表明浏览器应该连接目标的哪个端口，如果没有指定，使用默认端口（http为80，https为443）</p>
<ul>
<li>path</li>
</ul>
<p>路径，表明浏览器获取什么数据。如果服务器的文件系统是大小写敏感，那么路径也可能是大小写敏感</p>
<ul>
<li>query_string</li>
</ul>
<p>查询字符串，由一个或多个“key&#x3D;value”对组成，表示需要传递给服务器的内容</p>
<ul>
<li>fragments</li>
</ul>
<p>片段字符，hash部分，表明文档资源的某个部分位置。例如可以让浏览器定位到锚点（通称超级链接锚点标签<a>，anchor）的id处。一般情况下，hash值改变不会使得浏览器发出请求</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>字形欺骗</li>
</ul>
<p>利用字形相似来进行url的替换，例如英文l和数字1，不同国家之间的符号欺骗等</p>
<ul>
<li>浏览器的自纠错</li>
</ul>
<p>分解映射：浏览器会对一些字符有自动分解，会将一些特定字符分解为浏览器可识别的内容。</p>
<p>例如将罗马数字，cjk兼容字符，带圈数字&#x2F;英文等替换为ascii字符</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="crlf攻击"><a href="#crlf攻击" class="headerlink" title="crlf攻击"></a>crlf攻击</h3><p>通过注入http头来篡改响应消息，，也可以构建超长的http头攻击运行着apache2.2.0～2.2.21服务器，使用户的http only的cookie泄漏</p>
<h3 id="401"><a href="#401" class="headerlink" title="401"></a>401</h3><p>利用浏览器的特性—当用户正在访问需要认证的资源时，服务器会响应401，浏览器收到这个状态码后，会根据服务器提供的认证提示信息弹出认证窗口。</p>
<h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>-存储型：用户输入内容没有做校验</p>
<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>将页面用iframe或者其他形式放在页面底层，用户查看的页面和实际点击的数据不一致。</p>
<p>-预防：<code>x-frame-option</code>设置页面是否支持iframe显示</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>###阻止hsts，即阻止http升级https</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" data-id="cmebduixi005qpwfm31ckc3po" data-title="浏览器安全" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/【Wasm】介绍----1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90Wasm%E3%80%91%E4%BB%8B%E7%BB%8D----1/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.713Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webAssembly/">webAssembly</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90Wasm%E3%80%91%E4%BB%8B%E7%BB%8D----1/">【Wasm】介绍(未完成)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p>webAssembly的堆栈式结构被设计为编码为一种高密度，可以被浏览器快速加载和执行的二进制格式。</p>
<p>webAssembly的设计初衷是希望浏览器以近似原生C&#x2F;C++应用的运行速度，来调用Wasm模块中包含的这各类型平台（处理器架构）上都可以使用的通用硬件功能。</p>
<p>Wasm描述来一个内存安全的沙箱执行环境，可以在现有的js虚拟机中运行实现。当浏览器中运行一个Wasm模块时，Wasm将遵循浏览器中与Web应用一致的同源策略来保证其安全性。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Wasm主要是中v8解析js的解析器和编译链路中进行处理（Pipeline链路）</p>
<ul>
<li><p>链路中各个编译器的前置Parser的语法分析，转换为AST中间数据格式</p>
</li>
<li><p>优化编译，TurboFn优化编译器会使用IC（Inline Cache）和OSR（On Stack Replacement）等对js源码进行分析和优化</p>
</li>
<li><p>进行lowering操作，优化编译器会根据现有的已经优化好的js源码来生成一些处于低层级且与硬件架构相关的中间代码。</p>
</li>
<li><p><font color=red>此时加入Wasm操作</font></p>
</li>
</ul>
<p>引擎不需要对Wasm模块中的二进制代码进行优化，也不需要生成冗余的占用大量内存的AST结构信息。只需要把这些模块中的二进制代码直接加载到内存中，然后经过位于V8链路末端编译器后端的处理，最后生成的机器码便可以直接被浏览器执行。</p>
<ul>
<li>位于V8链路最末端的编译器后端（backend）负责将这些经过处理后的代码直接转译成基于特定处理器架构的机器码，最后再被浏览器解析和执行</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90Wasm%E3%80%91%E4%BB%8B%E7%BB%8D----1/" data-id="cmebduixa0057pwfm7er35w06" data-title="【Wasm】介绍(未完成)" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webAssembly/" rel="tag">webAssembly</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/【markdown】语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90markdown%E3%80%91%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.713Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/">额外内容</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90markdown%E3%80%91%E8%AF%AD%E6%B3%95/">【markdown】语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>***、—、___可以显示横线效果</p>
<hr>
<hr>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>除了最基本的<a href=""></a>外，还包含以下</p>
<ul>
<li>引用链接</li>
</ul>
<p><a href="htttps://">link</a></p>
<ul>
<li>网址链接</li>
</ul>
<p><a href="https://">https://</a></p>
<h2 id="扩展语法GFM"><a href="#扩展语法GFM" class="headerlink" title="扩展语法GFM"></a>扩展语法GFM</h2><ul>
<li>删除线～</li>
</ul>
<p><del>删除</del></p>
<ul>
<li>下划线</li>
</ul>
<p><u>a</u></p>
<ul>
<li>上标</li>
</ul>
<p>这是^上标^</p>
<ul>
<li>下标</li>
</ul>
<p>这是<del>下标</del></p>
<ul>
<li>表情</li>
</ul>
<p>:smile:</p>
<p><a target="_blank" rel="noopener" href="https://www.webfx.com/tools/emoji-cheat-sheet/">表情地址</a></p>
<ul>
<li><p>任务列表</p>
</li>
<li><p><input disabled="" type="checkbox"> 
list 1</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
list2</p>
</li>
<li><p>锚点</p>
</li>
</ul>
<p><a href="#point">point</a></p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li>中英文之间、中英文与数字之间、英文标点符号与后面的文字之间</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="语言转换工具"><a href="#语言转换工具" class="headerlink" title="语言转换工具"></a>语言转换工具</h3><p>Pandoc</p>
<h3 id="vs-code语法增强插件"><a href="#vs-code语法增强插件" class="headerlink" title="vs code语法增强插件"></a>vs code语法增强插件</h3><p>markdown preview enhanced</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>引用文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import “文件名”</span><br></pre></td></tr></table></figure>

<p>可以将文件内容直接显示，包括图片、csv表格</p>
<ul>
<li>幻灯片</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!— slide—&gt;</span><br><span class="line">First</span><br><span class="line">&lt;!— slide—&gt;</span><br><span class="line">Second</span><br></pre></td></tr></table></figure>

<ul>
<li>使用库：reveal.js</li>
</ul>
<h2 id="交互性工具"><a href="#交互性工具" class="headerlink" title="交互性工具"></a>交互性工具</h2><p>交互性md工具可以直接执行代码</p>
<ul>
<li><p>jupyter notebook</p>
</li>
<li><p>r markdown</p>
</li>
</ul>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>其实呢，每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似，比如我们</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>[回到顶部](#readme)</code></td>
<td><a href="#readme">回到顶部</a></td>
</tr>
</tbody></table>
<p>不过要注意，标题中的英文字母都被转化为<strong>小写字母</strong>了。</p>
<blockquote>
<p>以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！</p>
</blockquote>
<h3 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 需求分析</li>
<li><input checked="" disabled="" type="checkbox"> 系统设计</li>
<li><input checked="" disabled="" type="checkbox"> 详细设计</li>
<li><input disabled="" type="checkbox"> 编码</li>
<li><input disabled="" type="checkbox"> 测试</li>
<li><input disabled="" type="checkbox"> 交付</li>
</ul>
<p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>在GitHub的<strong>issue</strong>中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p>
</blockquote>
</blockquote>
<h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><h3 id="常用于引用文本"><a href="#常用于引用文本" class="headerlink" title="常用于引用文本"></a>常用于引用文本</h3><h4 id="文本摘自《深入理解计算机系统》P27"><a href="#文本摘自《深入理解计算机系统》P27" class="headerlink" title="文本摘自《深入理解计算机系统》P27"></a>文本摘自《深入理解计算机系统》P27</h4><p>　令人吃惊的是，在哪种字节顺序是合适的这个问题上，人们表现得非常情绪化。实际上术语“little endian”（小端）和“big endian”（大端）出自Jonathan Swift的《格利佛游记》一书，其中交战的两个派别无法就应该从哪一端打开一个半熟的鸡蛋达成一致。因此，争论沦为关于社会政治的争论。只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的。</p>
<blockquote>
<p><strong>“端”（endian）的起源</strong><br>以下是Jonathan Swift在1726年关于大小端之争历史的描述：<br>“……下面我要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今的皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破较小的一端，违令者重罚。”</p>
</blockquote>
<h3 id="块引用有多级结构"><a href="#块引用有多级结构" class="headerlink" title="块引用有多级结构"></a>块引用有多级结构</h3><blockquote>
<p>数据结构</p>
<blockquote>
<p>树</p>
<blockquote>
<p>二叉树</p>
<blockquote>
<p>平衡二叉树</p>
<blockquote>
<p>满二叉树</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>表格可以指定对齐方式</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="center">居中</th>
<th align="right">右对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">col 3 is</td>
<td align="center">some wordy text</td>
<td align="right">$1600</td>
</tr>
<tr>
<td align="left">col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td align="left">zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p>
<p>比如<code>:blush:</code>，可以显示:blush:。</p>
<p>具体每一个表情的符号码，可以查询GitHub的官方网页<a target="_blank" rel="noopener" href="http://www.emoji-cheat-sheet.com/">http://www.emoji-cheat-sheet.com</a>。</p>
<p>但是这个网页每次都打开<strong>奇慢</strong>。。所以我整理到了本repo中，大家可以直接在此查看<a href="./emoji.md">emoji</a>。</p>
<h2 id="diff语法"><a href="#diff语法" class="headerlink" title="diff语法"></a>diff语法</h2><p>版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。<br>GFM中可以显示的展示diff效果。使用绿色表示新增，红色表示删除。</p>
<p>其语法与代码高亮类似，只是在三个反引号后面写diff，<br>并且其内容中，以 <code>+ </code>开头表示新增，<code>- </code>开头表示删除。</p>
<p>效果如下：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 鸟宿池边树，僧敲月下门</span></span><br><span class="line"><span class="deletion">- 鸟宿池边树，僧推月下门</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90markdown%E3%80%91%E8%AF%AD%E6%B3%95/" data-id="cmebduixc005cpwfm9ra2hg2v" data-title="【markdown】语法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/" rel="tag">额外内容</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/【vue】虚拟dom基本" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90vue%E3%80%91%E8%99%9A%E6%8B%9Fdom%E5%9F%BA%E6%9C%AC/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.713Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90vue%E3%80%91%E8%99%9A%E6%8B%9Fdom%E5%9F%BA%E6%9C%AC/">【vue】虚拟dom基本</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h2><p>在项目运行时，页面状态会不断变化，每当状态变化时，都需要重新渲染。如果每次都直接将页面全部替换更新，那么由于访问 dom 是相对昂贵的，这样会导致非常多的性能浪费。<br>因此当某个状态变化时，只更新与这个状态相关联的 dom 节点。虚拟 dom 通过状态声称一个虚拟节点树，然后使用虚拟节点树进行渲染。在更新的时候，只需要比较上一次的节点树与当前节点树有何不同，更新不同的地方即可。</p>
<h2 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>vnode</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="注释节点"><a href="#注释节点" class="headerlink" title="注释节点"></a>注释节点</h4><ul>
<li>有效属性<br><code>text</code>和<code>isComment</code></li>
<li>元素：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;！—注释—&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>vnode：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">text：”注释”，</span><br><span class="line">isComment：<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h4><ul>
<li><p>有效属性<br><code>text</code></p>
</li>
<li><p>创建过程</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTextVnode</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VNode</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="title class_">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="克隆属性"><a href="#克隆属性" class="headerlink" title="克隆属性"></a>克隆属性</h4><ul>
<li><p>特殊属性<br><code>isCloned</code></p>
</li>
<li><p>创建过程</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCloneVnode</span>(<span class="params">vnode, deep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> cloned = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    vnode.<span class="property">tag</span>,</span><br><span class="line">    vnode.<span class="property">data</span>,</span><br><span class="line">    vnode.<span class="property">children</span>,</span><br><span class="line">    vnode.<span class="property">text</span>,</span><br><span class="line">    vnode.<span class="property">elm</span>,</span><br><span class="line">    vnode.<span class="property">context</span>,</span><br><span class="line">    vnode.<span class="property">componentOptions</span>,</span><br><span class="line">    vnode.<span class="property">asyncFactory</span></span><br><span class="line">  );</span><br><span class="line">  cloned.<span class="property">ns</span> = vnode.<span class="property">ns</span>;</span><br><span class="line">  cloned.<span class="property">isStatic</span> = vnode.<span class="property">isStatic</span>;</span><br><span class="line">  cloned.<span class="property">key</span> = vnode.<span class="property">key</span>;</span><br><span class="line">  cloned.<span class="property">isComment</span> = vnode.<span class="property">isComment</span>;</span><br><span class="line">  cloned.<span class="property">isCloned</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (deep &amp;&amp; vnode.<span class="property">children</span>) &#123;</span><br><span class="line">    cloned.<span class="property">children</span> = <span class="title function_">createCloneVnode</span>(vnode.<span class="property">children</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h4><ul>
<li><p>有效属性<br><code>tag</code>: 节点名称，例如 div、li 等<br><code>data</code>: 节点上的数据，例如 attrs、class 等<br><code>children</code>: 当前节点的子节点列表<br><code>context</code>: 当前组件的 vuejs 实例</p>
</li>
<li><p>元素：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>vnode</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">children</span>: [<span class="title class_">VNode</span>, <span class="title class_">VNode</span>]，</span><br><span class="line"><span class="attr">context</span>: &#123;…&#125;,</span><br><span class="line">data：&#123;…&#125;，</span><br><span class="line"><span class="attr">tag</span>: “div”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件节点"><a href="#组件节点" class="headerlink" title="组件节点"></a>组件节点</h4><ul>
<li>特有属性：<br><code>componentOptions</code>: 组件节点的选项参数，包括 propsData、tag、children 等<br><code>componentInstance</code>: 组件实例</li>
</ul>
<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><ul>
<li>特有属性：<br><code>functionContext</code><br><code>functionOptions</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90vue%E3%80%91%E8%99%9A%E6%8B%9Fdom%E5%9F%BA%E6%9C%AC/" data-id="cmebduixh005mpwfm442e8cux" data-title="【vue】虚拟dom基本" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/【console】API" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90console%E3%80%91API/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.711Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90console%E3%80%91API/">consoleAPI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.assert(boolean, …args)</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>但第一个参数为false时进行输出</p>
<h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.count(args)</span><br><span class="line"></span><br><span class="line">console.countReset(args) // 归零累计值</span><br></pre></td></tr></table></figure>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>累计特定标签出现的次数</p>
<h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.group(“start”)</span><br><span class="line">console.log(“info”)</span><br><span class="line">console.groupCollapsed(“child”)</span><br><span class="line">console.log(“data”)</span><br><span class="line">console.groupEnd()</span><br><span class="line">console.log(“data2”)</span><br><span class="line">console.groupEnd()</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>让输出信息更加显眼聚合，易于查看</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.table(rows,[key1,key2]</span><br></pre></td></tr></table></figure>

<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>以表格打印对象内容，一次性显示更多信息</p>
<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.time(args)</span><br><span class="line">console.timeEnd(args)</span><br></pre></td></tr></table></figure>

<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>测量时间</p>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.trace()</span><br></pre></td></tr></table></figure>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>打印当前的call stack</p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn(…args)&#123;</span><br><span class="line">….</span><br><span class="line">&#125;</span><br><span class="line">monitor(fn)</span><br><span class="line">fn(“data”, “data2”)</span><br></pre></td></tr></table></figure>

<h2 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h2><p>执行该函数时，输出参数。但是无法执打印箭头函数的参数</p>
<h2 id="monitorEvents"><a href="#monitorEvents" class="headerlink" title="monitorEvents"></a>monitorEvents</h2><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorEvents(window, “click”)</span><br></pre></td></tr></table></figure>

<h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>监听并打印元素触发的事件</p>
<h2 id="getEventListeners"><a href="#getEventListeners" class="headerlink" title="getEventListeners"></a>getEventListeners</h2><h3 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getEventListeners(el)</span><br></pre></td></tr></table></figure>
<h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><p>打印所有注册在元素上的事件监听器</p>
<h2 id="queryObjects"><a href="#queryObjects" class="headerlink" title="queryObjects"></a>queryObjects</h2><h3 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryObjects(obj)</span><br></pre></td></tr></table></figure>
<h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><p>打印所有原型链中包含该原型的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%90console%E3%80%91API/" data-id="cmebduix90054pwfmezfb0zef" data-title="consoleAPI" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/chrome/" rel="tag">chrome</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/console/" rel="tag">console</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/WebRTC/【webRTC】媒体" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90webRTC%E3%80%91%E5%AA%92%E4%BD%93/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.711Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/">扩展阅读</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90webRTC%E3%80%91%E5%AA%92%E4%BD%93/">webRTC媒体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><h3 id="webRCT的媒体"><a href="#webRCT的媒体" class="headerlink" title="webRCT的媒体"></a>webRCT的媒体</h3><h4 id="轨道"><a href="#轨道" class="headerlink" title="轨道"></a>轨道</h4><p>MediaStreamTrack是webRTC中的基本媒体单元，此轨道代表一种设备或录制内容（称为源）可返回的单一类型的媒体。单个立体声源或6声道环绕声音音频信号均可视为一个轨道，即使二者都是由多个音频声道构成。依据webRTC文档的定义，轨道的内容“将一起进行编码，以便作为某种有效负载类型进行传输”。即在使用对等连接进行传输时，轨道的各个声道将被视为一个单元，即使其在本地处于启用&#x2F;禁用或静音状态</p>
<p>每个轨道都有一个源与之关联。通过webRTC不能之间访问或控制源。对源的一切控制都通过轨道实施。轨道不仅可以是来自源的原始媒体，还可能是浏览器提供的经过转换的版本</p>
<p>不同的MediaStreamTrack对象可代表同一媒体源。有两种方式可用于暂停轨道的媒体：禁用、静音</p>
<p>将轨道静音&#x2F;取消静音由用户或浏览器执行，而静音表示轨道的底层媒体源暂时无法提供媒体。一般来说，应用程序无法控制何时将轨道静音，但是其可以检查轨道的muted属性值，静音后，音频轨道将不再发声，视频轨道将显示黑屏。提供将轨道对象的enabled&#x3D;false，可单独逐一禁用每个轨道。这两个属性均独立于轨道的readyState属性。这些属性彼此独立，可以同时存在</p>
<p>ready State属性表示轨道的状态</p>
<pre><code>new：尚未连接至媒体

live：可以生成媒体

ended：表示其源当前没有且永远无法提供更多数据，例如拔掉正在使用的摄像头电源
</code></pre>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>MediaStream是MediaStreamTrack对象集合，创建媒体流方式：</p>
<p>1、通过现有的Media Stream中复制轨道来请求对本地媒体的访问</p>
<p>2、使用对等连接来接收新的流</p>
<p>请求和访问本地媒体只有一种方式，通过<code>getUserMedia</code>。通过MediaStream构造函数可以将现有的MediaStream对象轨道“复制”到新的MediaStream对象中，该构造函数将现有的一个MediaStream对象或一系列MediaStreamTrack对象用作参数。还可以完全不指定参数，并且能在现有的MediaStream添加（addTrack）和删除（removeTrack）轨道，但这一功能并未广泛得到支持。还可以通过clone来复制流及其所有轨道。对于派生的媒体流（基于其他而创建的），MediaStream构造函数的数组参数不必全都来自于现有的同一MediaStream对象，而是允许进行混搭。各轨道可以属于不同的类型，同一MediaStream对象同时包含音视频。</p>
<p>无论MediaStream对象是如何创建的，都有共同的特征：MediaStream对象中的所有轨道将在呈现时进行同步。但是流中的各个轨道并未排序，任何添加重复轨道都会被忽略且没有任何提示</p>
<h4 id="媒体选择和控制"><a href="#媒体选择和控制" class="headerlink" title="媒体选择和控制"></a>媒体选择和控制</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90webRTC%E3%80%91%E5%AA%92%E4%BD%93/" data-id="cmebduiyj009qpwfmclof6gec" data-title="webRTC媒体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webRTC/" rel="tag">webRTC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" rel="tag">扩展阅读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/WebRTC/【WebRTC】介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90WebRTC%E3%80%91%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.709Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/">扩展阅读</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90WebRTC%E3%80%91%E4%BB%8B%E7%BB%8D/">webRTC介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="webRTC-介绍"><a href="#webRTC-介绍" class="headerlink" title="webRTC 介绍"></a>webRTC 介绍</h2><p>webrtc，Web Real-time Communication，web 实时通信技术，其开创性的使浏览器能直接与其他浏览器进行交互，从而形成包括三角模式和梯形模式在内的多种体系结构</p>
<p>实时通信技术通过标准 api 和 web 应用程序交互，并使用浏览器与操作系统通信。</p>
<p>webrtc 增加新的特点 - 浏览器和浏览器之间的交互（对等连接）。在此类交互上，一个浏览器中的实时通信功能使用线上标准协议（非 http），与另一个浏览器或网络电话或视频应用程序之中的实时通信功能进行通信。虽然使用 tcp 传输 web 流量，但浏览器之间的线上可使用其他传输协议，例如 udp。</p>
<pre><code>- 提供信令服务，该服务器在浏览器和对等连接另一端提供信令通道
</code></pre>
<h3 id="webrtc-所包含的元素"><a href="#webrtc-所包含的元素" class="headerlink" title="webrtc 所包含的元素"></a>webrtc 所包含的元素</h3><ul>
<li>web 服务器</li>
<li>运行于各种设备和操作系统之上的浏览器，包括台式机、pad、手机和其他服务器</li>
<li>其他：共用交换电话网（PSTN）门户、其他互联网通信终端（会话发起协议电话、客户端，或者 Jingle 客户端</li>
</ul>
<p>webrtc 支持以上所有设备的通信</p>
<h3 id="三角模式和梯形模式"><a href="#三角模式和梯形模式" class="headerlink" title="三角模式和梯形模式"></a>三角模式和梯形模式</h3><ul>
<li><p>三角模式</p>
<p>最常见的情况可能是两个浏览器都运行从同一个 web 服务器下载的同一个 webrtc web 应用程序，因为这三个元素之间的信令路线和媒体或数据流动路线所构成的形状恰好是一个三角形，因此成为 webrtc 三角形。两个浏览器之间直接通过建立对等连接来传输语音、视频媒体，以及附加数据</p>
<p>信令在 webrtc 中并未标准化，其只被视作未应用程序的一部分。信令可以通过 http 或 websocket 传送到向浏览器提供 html 页面的同一 web 服务器，也可传送到只负责处理信令的一个完全不同的 web 服务器</p>
</li>
<li><p>梯形模式</p>
<p>其包含两台 web 服务器和两个浏览器，web 服务器之间采用标准的信令协议。例如 SIP 或 Jingle，也可以使用专有的信令协议。客户端和三角模式一样，通过对等连接传输音视频</p>
</li>
</ul>
<h3 id="webrtc-与协议"><a href="#webrtc-与协议" class="headerlink" title="webrtc 与协议"></a>webrtc 与协议</h3><ul>
<li><p>SIP</p>
<p>web 服务器有一个内置的 sip 信令网关，浏览器与 sip 客户端之间可以通过此网关来交换呼叫建立信息，直接在浏览器和 sip 客户端之间形成媒体流，因为对等连接与 sip 用户代理建立标准的实时传输协议 RTP 媒体会话</p>
<p>web 服务器 &lt;— SIP —&gt; SIP 服务器 &lt;— SIP —&gt; SIP 客户端 &lt;— 对等连接（音视频） —&gt; 浏览器 &lt;——&gt; web 服务器</p>
</li>
<li><p>Jingle</p>
<p>web 服务器有一个内置的可扩展消息现场协议，该内置服务器通过另一个 xmpp 服务器与 jingle 客户端进行通信</p>
<p>web 服务器 &lt;— Jingle —&gt; XMPP 服务器 &lt;— Jingle —&gt; Jingle 客户端 &lt;— 对等连接（音视频） —&gt; 浏览器 &lt;——&gt; web 服务器</p>
</li>
<li><p>公共交换电话网（PSTN）</p>
<p>PSTN 网关是纯音频媒体流的终结点，负责 PSTN 电话呼叫与媒体相连。在 web 服务器与 PSTN 网关之间需要有某种形式的信令，可以是 SIP，也可以是主从控制协议。</p>
<p>互联网通信服务可以为用户分配一个电话号码，用户可以使用 webrtc 访问此服务。这样拨叫该电话号码时浏览器会发出“响铃”声，应答呼叫时则会通过与 PSTN 呼叫方相连的互联网建立语音会话，其他服务可能包括能在 webrtc 应用程序中“拨打电话”，这种拨打会通过互联网与 PSTN 建立语音通道</p>
<p>PSTN 网关 &lt;——&gt; 浏览器 &lt;——&gt; Web 服务器 &lt;——&gt; PSTN 网关 &lt;——&gt; 电话</p>
</li>
</ul>
<h3 id="媒体流"><a href="#媒体流" class="headerlink" title="媒体流"></a>媒体流</h3><p>点对点 webrtc 会话中的多媒体流包括但不限于：麦克风音频流、应用程序共享视频流、前置摄像头视频流、后置摄像头视频流、网络摄像头视频流、立体声音频流</p>
<p>多方会话：</p>
<ul>
<li><p>每个浏览器都与其他参与会话的浏览器建立一个对等连接<br>优势：不需要媒体服务器基础架构、媒体延迟最低且质量高</p>
<p>缺点：不适用于大型多方会议，每次新的浏览器加入都会导致其他浏览器带宽增加</p>
</li>
<li><p>通过一个集中式媒体服务器&#x2F;混合器&#x2F;选择器，每个浏览器与媒体服务器之间建立单个对等连接。每个浏览器向服务器发送媒体数据，由服务器混合后不经将其分发给其他浏览器。这样每次有新的浏览器加入后，其他浏览器不需要对这个新的浏览器建立连接<br>优势：能扩展非常大的会话，同时可以最大幅度减少当有新参与者加入会话时每个浏览器所需的处理工作量</p>
<p>缺点：只有一个浏览器或少量浏览器参与时，会降低效率</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="建立-webRTC-会话"><a href="#建立-webRTC-会话" class="headerlink" title="建立 webRTC 会话"></a>建立 webRTC 会话</h3><ul>
<li>获取本地媒体</li>
<li>在浏览器和对等端（其他浏览器或终端）之间建立连接</li>
<li>将媒体和数据通道关联至该连接</li>
<li>交换会话描述</li>
</ul>
<h4 id="获取本地媒体"><a href="#获取本地媒体" class="headerlink" title="获取本地媒体"></a>获取本地媒体</h4><p>有多种方式可以获取，webRTC 定义了一种常见方式：<code>getUserMedia</code>，此方法可以用于获取单个本地 MediaStream，在获取一个或多个媒体后，可以使用 MediaStream API 将它们组合到所需要的流中。为保护隐私，只有当浏览器获取用户许可后，才会批准 web 应用程序访问用户麦克风或摄像头的请求</p>
<h4 id="建立对等连接"><a href="#建立对等连接" class="headerlink" title="建立对等连接"></a>建立对等连接</h4><p><code>RTCPeerConnection</code>是 webrtc 核心，其可以在两个对等端之间建立连接。这不是通过服务器请求通信，而是直接在两个实体之间进行通信。就 webrtc 本身而言，对等连接就是两个或更多浏览器之间的本地媒体连接，这种模式很适用于多向通信</p>
<p>建立此连接需要一个新的<code>RTCPeerConnection</code>对象，其构造函数方法的唯一输入项是一个配置对象，该对象包括交互式连接建立技术（ICE）“打洞”通过各种网络地址切换（NAT）设备和防火墙所使用的信息</p>
<h4 id="交换媒体或数据"><a href="#交换媒体或数据" class="headerlink" title="交换媒体或数据"></a>交换媒体或数据</h4><p>建立连接后，可将任意数量的本地媒体流关联到对等连接，以通过该连接发送至远端浏览器。同样也可以将任意数量的远端媒体流发送至对等连接的本地端，这样本地端就有了新的媒体流，而且可以像操作其他本地媒体流那样处理他们</p>
<p>每次更改媒体时，都需要在两个浏览器之间协商如何在连接通道中表示媒体。当从本地端或远程端发出添加或删除媒体的请求时，可请求浏览器生成相应的 RTCSessionDescription 对象（此容器存放会话描述，即有关如何建立媒体会话的信息），用于表示通过对等连接传输的所有媒体集合。利用 RTCPeerConnection，开发者可在会话描述被发送到远端前，根据需要查看或编辑会话描述。这样浏览器既可以处理编码器协商和编写会话描述协议 W（SDP），同时允许应用程序根据需要进行微调。</p>
<p>当两个浏览器交换完 RTCSessionDescription 对象后，即可建立媒体或数据会话。此时两个浏览器将开始打洞，打洞完毕后，即可协商密钥，以确保媒体会话的安全，最后可开始媒体或数据会话。交换对象后的所有活动通过浏览器执行 js 代码完成，应用程序的 js 代码还可以添加&#x2F;删除 STUN 和 TURN 服务器</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>在对等连接中，任一端浏览器都可以关闭连接，通过对 RTCPeerConnection 对象调用<code>close()</code>来指示连接已使用完毕，此操作会停止 ICE 处理和媒体流传输，同样，如果某一端的浏览器断开 Internet 连接或发送崩溃，媒体或数据通道中发送的持久连接请求将失效，另一端的浏览器将尝试重新开始打洞，并且在打洞失败后关闭会话。会话结束后，浏览器将删除会话授予的任何访问设备麦克风和摄像头的许可，因此在新的会话中，需要向用户请求新的许可</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>提议&#x2F;应答是一种媒体协商方式，为了确保双方在流媒体传输之前达成一致</p>
<pre><code>提议：一方向一方发送其支持并要设置的媒体类型和功能

应答：另一方回应，提示在所提议的媒体类型和功能中，哪些是此会话支持并可以接受的
</code></pre>
<p>临时应答：对提议的应答，但是临时性或实验性，可能不是实际应答中提供的最终应答，最终应答将在后面的提议&#x2F;应答交换中给出。临时应答可选，通常只在与某些模拟电话网络特征的 VoIP 系统或 PSTN 进行互操作时才会出现</p>
<p>当浏览器 A 与浏览器 B 的用户进行通信时，浏览器 A 的 js 将针对其需要的媒体提供基于约束的描述、请求媒体数据并获取用户许可。用户授予的许可必须绑定到网页所在的域，并且不能扩展到网页上的弹出窗口和其他框架。所需要的媒体会话信息由会话描述对象捕获。该对象是通过 web 服务器向浏览器 B 发送的提议。对于 A 如何将此提议发送到 B，webRTC 没有标准化方法，因此此过程可以通过多种方式完成，例如 xhr，收到会话描述对象提议后，B 将生成会话描述对象应答，并以相同的方式发送到 A，当交换完成后，开始打洞（和密钥协商），并最终交换媒体数据包</p>
<p>当关闭连接时，将导致对等连接关闭，对麦克风和摄像头的许可也全部失效</p>
<h4 id="建立-WebRTC-会话"><a href="#建立-WebRTC-会话" class="headerlink" title="建立 WebRTC 会话"></a>建立 WebRTC 会话</h4><pre><code>- 浏览器A从web服务器请求网页
- 服务器想A提供带有WebRTC JS的网页
- 浏览器B从web服务器请求网页
- 服务器向B提供带有webRTC js的网页
- A希望与B进行通信，并通过A的JS将A的会话描述对象（提议）发送到web服务器
- 服务器将A的会话描述对象发送给B的JS
- B的JS将B的会话描述对象（应答）发送到服务器
- 服务器将B的会话描述对象发送到A
- A和B开始打洞，以确认访问对方的最佳方式
- 完成打洞后，A和B以安全的媒体通信协议密钥
- AB开始交换语音、视频或数据
</code></pre>
<h4 id="三角模式建立会话"><a href="#三角模式建立会话" class="headerlink" title="三角模式建立会话"></a>三角模式建立会话</h4><pre><code>- 浏览器A、B向web服务器请求数据
- 服务器响应（h5、css、js
- 服务器返回AB HTTPS（SDP对象B A）
- AB连接成功后，ICE打洞
- 密钥协商
- 安全的媒体或数据会话
</code></pre>
<h4 id="梯形模式"><a href="#梯形模式" class="headerlink" title="梯形模式"></a>梯形模式</h4><pre><code>- 浏览器A向服务器1请求，B向服务器2请求
- web服务器分别向浏览器响应
- 浏览器A向服务器1发起https（SDP对象A）
- 服务器1向服务器2发送jingle（`&lt;jingle action=&#39;session-initiate&#39;&gt;`
- 服务器2向B发送浏览器A的信息
- 浏览器A向服务器2发送https SDP对象B
- 服务器2向服务器1发送同意jingle(`&lt;jingle action=&#39;session-accept&#39;&gt;`)
- 服务器1向浏览器A发送B的信息
- 浏览器AB开始ICE打洞、密钥协商、传输数据等
- 浏览器A向服务器1发送关闭连接
- 服务器1向服务器2发送jingle关闭（`&lt;jingle action=&#39;session-terminate&#39;&gt;`）
- 浏览器B关闭连接
</code></pre>
<h4 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h4><pre><code>- 浏览器A向服务器发送请求，服务器返回响应
- SIP用户代理向SIP服务器发送`REGISTER`，SIP服务器响应
- 浏览器向服务器发送浏览器相关信息SDP A
- 服务器向SIP服务器发送浏览器相关信息InVite SDP A
- SIP服务器向SIP用户代理发送InVite SDP A
- SIP用户代理响应接受，并将自己信息响应SDP S
- SIP服务器接收到用户代理信息后，将其响应给web服务器
- web服务器接收到后发送给浏览器
- web服务器和sip服务器连接，sip服务器与sip用户代理连接（ACK）
- 浏览器和sip用户代理开始ICE打洞、密钥协商、传输数据等
- 浏览器A向web服务器发送关闭连接
- web服务器向sip服务器发送关闭
- SIP用户代理向SIP服务器发送CLOSE
</code></pre>
<h4 id="Jingle"><a href="#Jingle" class="headerlink" title="Jingle"></a>Jingle</h4><pre><code>- 浏览器A向服务器发送请求，服务器返回响应
- 浏览器向服务器发送浏览器相关信息SDP A
- 服务器向XMPP服务器发送jingle（`&lt;jingle action=&#39;session-initiate&#39;&gt;`
- XMPP服务器向Jingle客户端发送jingle（`&lt;jingle action=&#39;session-initiate&#39;&gt;`
- Jingle客户端发送同意jingle(`&lt;jingle action=&#39;session-accept&#39;&gt;`)，XMPP服务器将其响应发送到web服务器
- web服务器接收到后发送给浏览器，附带SDP对象J
- 浏览器和Jingle客户端开始ICE打洞、密钥协商、传输数据等
- Jingle客户端向XMPP服务器发送关闭（`&lt;jingle action=&#39;session-terminate&#39;&gt;`）
- XMPP服务器向web服务器发送关闭（`&lt;jingle action=&#39;session-terminate&#39;&gt;`）
- 服务器和浏览器关闭
</code></pre>
<h4 id="PSTN"><a href="#PSTN" class="headerlink" title="PSTN"></a>PSTN</h4><p>web服务器和pstn网关之间的信令可利用任意数量的信令和控制协议，甚至sip中继。pstn网关终止webRTC媒体会话并将音频连接到pstn中继或线路。应在浏览器和pstn网关之间协商G.711（PCM）编码格式，否则将需要对音频信号进行转码</p>
<pre><code>- 浏览器A向服务器请求
- web服务器分别向浏览器响应
- 浏览器A向服务器发起https（SDP对象A）
- web服务器与PSIN网连建立连接，PSIN网联呼叫电话
- 电话挂机PSIN网联，PSIN应答web服务器
- 服务器与浏览器发送https，传输SDP对象网关
- 浏览器与PSIN网联ICE打洞、密钥协商
- 浏览器与PSIN传输媒体音频，语音会话时，还需要通过PSIN网联和电话进行连接，才做到浏览器与电话进行语音会话
- 电话挂机，PSIN网联销毁与服务器连接，浏览器关闭
</code></pre>
<h4 id="与媒体网关建立"><a href="#与媒体网关建立" class="headerlink" title="与媒体网关建立"></a>与媒体网关建立</h4><p>不再采取完全的端到端传输，而是使用媒体网关来终止ice和SRTP，并且将媒体转发给SIP UA，转发时甚至可能采取未加密的RTP形式。不过只有在VoIP网络利用某种其他安全协议时才能如此</p>
<p>媒体网关可以是一个边界元素，称为会话边界控制器(SBC)，用于穿透企业或服务提供的商网络的防火墙</p>
<pre><code>- 浏览器向web服务器/网关发送请求，服务器响应
- SIP用户管理向SIP服务器/媒体中继发送REGISTER，SIP服务器响应
- 浏览器和服务器发送SDP对象 A
- web服务器向SIP服务器/媒体中继发送Invite，携带浏览器的SDP
- SIP服务器/媒体中继向SIP用户管理发送Invite，携带浏览器的SDP
- SIP响应并携带SIP用户管理的SDP，SIP服务器响应到web服务器，web服务器相应到浏览器
- 浏览器与SIP服务器进行ICE打洞、密钥协商、安全的媒体会话，媒体会话需要SIP服务器发送给SIP用户管理
- SIP服务器关闭。。。。。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WebRTC/%E3%80%90WebRTC%E3%80%91%E4%BB%8B%E7%BB%8D/" data-id="cmebduiy0007cpwfm6hwv014b" data-title="webRTC介绍" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webRTC/" rel="tag">webRTC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" rel="tag">扩展阅读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/WEB3/【Web3】基本介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WEB3/%E3%80%90Web3%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.702Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web3/">Web3</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WEB3/%E3%80%90Web3%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">【Web3】基本介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用硬件或软件的方式，可以访问资金，与去中心化应用程序进行交互，充当无银行金融服务的网关、收集NFT、创建链上身份与社区，并提供比传统钱包更多的用途</p>
<h3 id="组成条件"><a href="#组成条件" class="headerlink" title="组成条件"></a>组成条件</h3><ul>
<li>公钥：链接到自己可以发售和接收交易的地址</li>
<li>私钥：用于签署新交易并允许访问资金，必须保密</li>
<li>种子短语：用于生成多个私钥。作为根密钥，可以访问用户钱包中其他密钥和地址，也可以创建新的密钥</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="热钱包（软钱包）"><a href="#热钱包（软钱包）" class="headerlink" title="热钱包（软钱包）"></a>热钱包（软钱包）</h4><p>可以存储、发送、接收和查看代币，所以比其他类型的钱包更加方便</p>
<ul>
<li>托管地：可以访问互联网和加密货币网络的设备上</li>
<li>实用性：最高</li>
<li>安全性：容易收到黑客攻击，因为连接到网络了</li>
</ul>
<h4 id="桌面钱包"><a href="#桌面钱包" class="headerlink" title="桌面钱包"></a>桌面钱包</h4><p>会被作为应用程序下载到电脑上，在本地运行<br>被认为是可用的，最安全的热钱包类型</p>
<ul>
<li>托管地：电脑</li>
</ul>
<h4 id="网络钱包"><a href="#网络钱包" class="headerlink" title="网络钱包"></a>网络钱包</h4><p>允许通过浏览器界面进行交互和访问，无须在本地设备上下载或者安装任何内容<br>具有与桌面钱包完全相同的功能，使用相同的区块链和区块浏览器来搜索区块和交易</p>
<ul>
<li>托管地：其他人的计算机或者服务器上</li>
</ul>
<h4 id="手机钱包"><a href="#手机钱包" class="headerlink" title="手机钱包"></a>手机钱包</h4><p>与桌面钱包类似，只是托管地是手机<br>与桌面钱包相比，手机钱包的功能相对更简单一些</p>
<h4 id="冷钱包"><a href="#冷钱包" class="headerlink" title="冷钱包"></a>冷钱包</h4><p>无须连接到互联网，那么这就使得冷钱包是存储加密货币的更安全的替代方案，因为有物理介质可以离线存储密钥</p>
<ul>
<li>安全性：抵抗黑客能力更强，对长期投资者来说很实用</li>
</ul>
<h4 id="硬件钱包"><a href="#硬件钱包" class="headerlink" title="硬件钱包"></a>硬件钱包</h4><p>使用随机生成器生成公钥和私钥的物理电子设备<br>最适合长期投资和存储使用，因为它们不太容易获得</p>
<ul>
<li>主要用例：确保未分配的、用于持续使用的大笔资金的安全性</li>
<li>安全性：最安全的存储方案之一，因为能够在设备中保存公钥和私钥，而无须借助任何互联网连接。这样对加密货币的访问是处于离线状态</li>
</ul>
<h4 id="纸钱包"><a href="#纸钱包" class="headerlink" title="纸钱包"></a>纸钱包</h4><p>由物理打印出的区块链地址和私钥组成，到纸上。这些信息会被打印成二维码，可以通过扫描二维码来汇款</p>
<ul>
<li>托管地：纸</li>
<li>缺点；只能一次性发送全部余额，不能多次发送部分</li>
</ul>
<h4 id="市面上主流钱包"><a href="#市面上主流钱包" class="headerlink" title="市面上主流钱包"></a>市面上主流钱包</h4><blockquote>
<p>以太坊钱包</p>
</blockquote>
<ul>
<li><p>metamask</p>
</li>
<li><p>trust Wallet</p>
</li>
<li><p>argent</p>
</li>
<li><p>imToken</p>
</li>
</ul>
<blockquote>
<p>其他生态</p>
</blockquote>
<ul>
<li><p>phantom：Solana生态</p>
</li>
<li><p>keplr：Cosmos生态</p>
</li>
<li><p>polkadot：Polkadot生态</p>
</li>
<li><p>tezos：Temple生态</p>
</li>
</ul>
<h2 id="助记词"><a href="#助记词" class="headerlink" title="助记词"></a>助记词</h2><p>由于私钥一般情况下，都非常冗长复杂，不适合记忆，为了方便使用，密码学家将其简化成了12或者24位不等的单词或者中文字符，简化之后的就被称为助记词</p>
<p>即：</p>
<ul>
<li><p>助记词是密钥的另外一种形式</p>
</li>
<li><p>通过助记词可以获取相关的多个私钥，但是通过私钥无法获取助记词</p>
</li>
</ul>
<h2 id="区块链浏览器"><a href="#区块链浏览器" class="headerlink" title="区块链浏览器"></a>区块链浏览器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>区块链浏览器是一种软件，它使用api和区块链节点从区块链中提取各种数据，然后使用数据库来排列搜索到的数据，并以可搜索的格式将数据呈现给用户</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>区块链钱包可以提供不同类型的数据，但仅限于与钱包管理的密钥相关的数据。区块链浏览器用于查看与在给定区块链的所有钱包上执行的交易相关的数据。<br>特殊之处就是在于透明度，它允许用户检查智能合约地址的余额和支出，如当用户参数首次代币发行时。</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>查看任何钱包地址的交易历史<br>能够审计任何钱包地址并提高区块链的透明度</li>
<li>查看接收和更改地址<br>可以查看交易接收地址、更改地址。将加密货币返回给支出者，以防输入值过多用于交易费用，提高了交易的透明度</li>
<li>查看当天最大的交易</li>
<li>查看内存池的状态<br>可以查看区块链上未确认的交易及其详细信息</li>
<li>查看双花交易<br>部门浏览器支持</li>
<li>查看孤立和陈旧区块<br>孤立区块：挖掘之后没有附加到最长的区块链上，并且它们的父区块链是未知的</li>
</ul>
<p>陈旧区块：已知父区块链，但未链接到已知最长链的区块</p>
<ul>
<li><p>查看发现或开采特点区块的个人或矿池</p>
</li>
<li><p>查看创世区块</p>
</li>
<li><p>允许用户查看交易费用、区块链难度、哈希率和其他数据</p>
</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>将加密货币发送给某人之前会检查钱包地址是否对区块链有效</p>
</li>
<li><p>检查加密货币是否已经发送给目标个人。所有者可以检查他们的钱包余额</p>
</li>
<li><p>可以帮助解释尚未通过或确认的交易出现的问题以及查看确认jieduan</p>
</li>
<li><p>帮助用户了解交易或Gas当前的成本，从而帮助计划未来的Gas支出</p>
</li>
<li><p>帮助用户了解某个组是不是挖掘交易的人，并有助于决定是否为未来的挖掘活动投入更多的计算资源</p>
</li>
<li><p>可以帮助正在开发钱包的人，如果它可以进行正常的工作（发送、接收、存储和加密货币）</p>
</li>
<li><p>与其他软件一起使用，可以证实数据和信息</p>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li><p>资源管理器首先使用节点接口提取给定区块链中的所有数据，一旦它导出数据，就会将其存储在可搜索的表格中</p>
</li>
<li><p>将收集最新的交易和区块，根据定义的可搜索类别进行排列。它为用户提供了一个界面用于搜索。在技术方面，资源管理器可以使用关系数据库、sql数据库和api</p>
</li>
</ul>
<p>每个区块链节点都可以直接读取区块链上的数据，获取最新交易和挖掘区块等数据等详细信息，然后将其发送到数据库，其中数据以可搜索表格的形式排列，使得资源管理器可以快速使用这些数据。</p>
<p>大部分的区块链使用表格，每一行都有唯一的id或者键用于区分</p>
<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>在区块链中，域名系统和网络中的域名概念不同。区块链中，域名指向的是钱包地址，是一种身份的关联和映射，解决了ip或钱包地址过长的问题</p>
<h3 id="ENS域名系统"><a href="#ENS域名系统" class="headerlink" title="ENS域名系统"></a>ENS域名系统</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>ens由两个以太坊智能合约组成：记录域名的ens注册表和将域名与机器的可读地址互相转换的解析器</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>在ens app上注册</p>
<h3 id="DAS域名账户系统"><a href="#DAS域名账户系统" class="headerlink" title="DAS域名账户系统"></a>DAS域名账户系统</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>das是web3的去中心化身份认证系统，和ens类似，允许用户将个人域名绑定都适用所有链的人类可读地址。</p>
<h2 id="预言机"><a href="#预言机" class="headerlink" title="预言机"></a>预言机</h2><p>预言机充当区块链上的app接口，通过查询可以获取智能合约的相关信息。预言机也可以向真实世界发送数据</p>
<h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>大多数区块链都有用于转移价值、启用协议操作或促进治理的本地加密货币，一些区块链支持智能合约，而智能合约可以在没有第三方的情况下执行，并且可以设计为执行几乎任何可以想象得到的合约。</p>
<p>区块链和链上智能合约需要一种方法来利用外部的链下数据，以便智能合约执行影响现实世界的app，因此预言机就需要被用到</p>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>软件预言机</li>
</ul>
<p>提供来自网站、服务器或数据库等数字源的数据。可以提供实时信息</p>
<ul>
<li>硬件预言机</li>
</ul>
<p>提供来自现实世界的数据，可以传递和中继来自项目运动传感器</p>
<ul>
<li>集中式预言机</li>
</ul>
<p>它由单个实体控制，并充当智能合约的唯一数据提供者。它要求合同参与者对一个实体给予极大的信任；它还代表单点故障，这可能会威胁到智能合约的安全性，如果预言机被破坏，智能合约也会被破坏。智能合约的准确性和有效性在很大程度上取决于所提供数据的质量，因此预言机对智能合约有很大的权利。</p>
<p>预言机问题：预言机可以使智能合约在去信任方之间执行，但当他变得过度中心化时，可能会有它试图成为中间人的风险。</p>
<ul>
<li>去中心化预言机</li>
</ul>
<p>去中心化预言机试图实现依赖因果关系而不是个人关系的去信任和确定性结果。它以与区块链网络相同的方式实现这些结果，在许多网络参与者之间分配信任。通过利用许多不同的数据源并实施不受单个实体控制的预言机系统，去中心化的预言机网络可能成为为智能合约提供更高级别的安全性和公平性。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>Chainlink</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/WEB3/%E3%80%90Web3%E3%80%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" data-id="cmebduixx0070pwfm52g0gg61" data-title="【Web3】基本介绍" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web3/" rel="tag">Web3</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/webpack/【webpack】配置项" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E9%85%8D%E7%BD%AE%E9%A1%B9/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.702Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E9%85%8D%E7%BD%AE%E9%A1%B9/">【webpack】配置项</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h1><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>在查找相对路径时，以context为根目录。<br>默认为webpack启动时的所在工作目录。<br>注：context必须是一个绝对路径的字符串</p>
<h2 id="entry-1"><a href="#entry-1" class="headerlink" title="entry"></a>entry</h2><p>类型：string&#x2F;array&#x2F;object</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>index•js</td>
<td>入口模块的文件路径，可以是相对路径</td>
</tr>
<tr>
<td>array</td>
<td>【index。js，index2。js】</td>
<td>入口模块的文件路径，可以是相对路径</td>
</tr>
<tr>
<td>object</td>
<td>{a：index。js}</td>
<td>配置多个入口，每个入口生成一个chunk</td>
</tr>
</tbody></table>
<p>如果是array，搭配output。library时，只有数组的最后一个入口文件的模块会被导出</p>
<h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><ul>
<li>id：chunk的唯一标识，从0开始</li>
<li>name：chunk的名称</li>
<li>hash：chunk的唯一标识的hash值</li>
<li>chunkhash：chunk内容的hash</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>代码运行的不同环境，默认为web</p>
<ul>
<li>web：针对浏览器，所有代码都集中到一个文件中</li>
<li>node：针对nodejs，使用require加载chunk模块</li>
<li>async-node：针对nodejs，异步加载chunk代码</li>
<li>webworker：针对webworker</li>
<li>electron-main：针对electon主线程</li>
<li>electron-rendrer：针对electron渲染线程</li>
</ul>
<h1 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h1><ul>
<li>svg- inline- loader：和raw- loader类似，但是会分析svg的内容，去除其不必要的部分，减少svg的体积</li>
</ul>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="缩小文件搜索范围"><a href="#缩小文件搜索范围" class="headerlink" title="缩小文件搜索范围"></a>缩小文件搜索范围</h2><ul>
<li><p>loader配置</p>
<blockquote>
<p>可以通过include去告诉webpack只有那些文件会被这个loader处理，用exclude排除不需要的文件</p>
</blockquote>
</li>
<li><p>优化resolve.modules配置<br>配置webpack去哪些目录下寻找第三方模块</p>
<blockquote>
<p>指明依赖包的具体目录位置，减少查询时间。</p>
</blockquote>
</li>
<li><p>优化reslove.main Fields配置<br>配置第三方模块使用哪个入口文件</p>
<blockquote>
<p>指明采用字段作为入口文件的描述字段，减少搜索步骤</p>
</blockquote>
</li>
</ul>
<p>注：需要考虑是否所有依赖包的第三方入口文件的描述字段，一个模块出错，就会导致所有的代码无法正常运行</p>
<ul>
<li><p>优化reslove.alias</p>
<blockquote>
<p>配置库的具体引用路径，减少查询时间</p>
</blockquote>
</li>
<li><p>resolve.extensions</p>
<blockquote>
<p>频率最高的放在最前面。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>列表不能太长</p>
</blockquote>
<ul>
<li>优化module.noParse</li>
</ul>
<h2 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h2><p>将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程</p>
<h2 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h2><p>uglfyjs是webpack内置的，但是在构建线上代码时会卡住，即是在进行代码压缩。压缩代码需要将代码解析成用object抽象表示的ast语法树，再去应用各种规则分析和处理ast，因此导致这个过程计算量很大，非常耗时</p>
<p>ParallelUglifyPlugin会开启多个子线程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程还是用uglfyjs压缩。</p>
<h2 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h2><ul>
<li>文件监听原理：</li>
</ul>
<blockquote>
<p>定时获取文件的最后编辑时间，每次存下最新的最后编辑时间，如果发现当前的获取的时间和最后一次保存的编辑时间不一致，就认为该文件发生了变化</p>
</blockquote>
<blockquote>
<blockquote>
<p>watchOptions.poll用于控制定时时长，每秒检查多少次</p>
</blockquote>
</blockquote>
<blockquote>
<p>当某个文件被判定为发生了变化时，并不会立刻告诉监听者，而是会先缓存起来，搜集一段时间后，再一次性告诉监听者。</p>
<blockquote>
<p>watchOptions.aggregateTimeout 用于配置这个等待时间</p>
</blockquote>
</blockquote>
<ul>
<li>自动刷新原理</li>
</ul>
<p>控制浏览器自动刷新方法：</p>
<ol>
<li><p>借助浏览器扩展去通过浏览器的提供的借口刷新，比如webstorm的liveedit</p>
</li>
<li><p>向要开发的网页中注入代理客户端的代码，通过客户端的去刷新页面</p>
</li>
<li><p>将要开发的网页装入一个iframe中，通过刷新iframe去看到最新效果</p>
</li>
</ol>
<p>webpack通过devServer.inline控制是否向每个chunk中注入代理客户端，在开启inline时，devserver会向每个chunk注入代理客户端的代码，而项目中chunk有很多chunk，因此会导致构建缓慢。</p>
<p>启动项目时，可以通过执行命令webpack-dev-server。—inline false完成。那么就会采用第三种方式进行页面刷新。</p>
<h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><ul>
<li>原理</li>
</ul>
<p>和自动刷新原理类似，都需要在开发的网页中注入一个代理客户端来连接devserver和网页。当子模块发生更新时，更新事件会一层层向上传递，直到有某层的文件接收了当前变化的模块，这时就会掉用callback函数去执行自定义的逻辑。如果事件一直往上抛，到最外层都没有事件接收他，那么会直接刷新页面。</p>
<ul>
<li>优化</li>
</ul>
<p>监听更少的文件，忽略nodemodules目录下的文件。</p>
<h1 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h1><ul>
<li>缓存问题</li>
</ul>
<p>cdn一般会为资源开启很长时间的缓存，可能会导致最新的发布不能用</p>
<blockquote>
<p>针对html入口文件，放到自己的服务器中，关闭自己服务器上的缓存，自己的服务器只提供html和数据接口</p>
</blockquote>
<blockquote>
<p>针对静态的js，css，图片等文件，开启cdn和缓存，每个文件带自己内容的hash值</p>
</blockquote>
<ul>
<li>使用</li>
</ul>
<blockquote>
<p>在output.publicPath设置js的地址</p>
</blockquote>
<blockquote>
<p>在css-loader.publicPath设置css导入的资源地址</p>
</blockquote>
<blockquote>
<p>在webplugin.stylepublicpath设置css文件的地址</p>
</blockquote>
<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><ul>
<li>js</li>
</ul>
<blockquote>
<p>使用 uglifyplugin和paralleugifyplugin（多线程）进行压缩</p>
</blockquote>
<ul>
<li>压缩es6</li>
</ul>
<blockquote>
<p>优点：对于一样的逻辑，es6代码量少于es5；js对es6的语法做了性能优化，例如针对const声明的变量有更快的读取速度。</p>
</blockquote>
<blockquote>
<p>使用uglifyes进行压缩</p>
</blockquote>
<ul>
<li>压缩css</li>
</ul>
<blockquote>
<p>使用cssnano进行压缩</p>
</blockquote>
<h2 id="tree-shaking去除无用的死代码"><a href="#tree-shaking去除无用的死代码" class="headerlink" title="tree shaking去除无用的死代码"></a>tree shaking去除无用的死代码</h2><p>配置babel保留es6模块化语句，presets：modules：false</p>
<p>启动时带上—display-used- exports参数，指出哪些函数有用和无用。</p>
<p>启动时带上—optimize-minimize去除无用代码</p>
<p>配置reslove.mainfields，优先采用jsnext：main（第三方包打包出的es6模块）</p>
<p>export default无法做tree shaking，因为导出的是一整个对象</p>
<h2 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h2><blockquote>
<p>使用commonchunkplugin</p>
</blockquote>
<h2 id="分割代码按需加载"><a href="#分割代码按需加载" class="headerlink" title="分割代码按需加载"></a>分割代码按需加载</h2><blockquote>
<p>原则</p>
</blockquote>
<p>1: 将整个网站划分成一个个小功能，再按照每个功能的相关程度将它们分成几类。</p>
<p>2: 将每一类合并为一个chunk，按需加载对应的chunk</p>
<p>3: 不要按需加载用户首次打开网站时需要看到的画面所对应的功能，将其放入执行入口所在的chunk中，以减少用户能感知的网页加载时间</p>
<p>4: 对于不依赖大量代码的功能点，例如依赖echart画图，将其进行按需加载</p>
<blockquote>
<p>webpackChunkName：name</p>
</blockquote>
<p>import（&#x2F;* webpackChunkName：name *&#x2F; path）：为动态生成的chunk赋予一个名称，方便追踪和调试代码，若不指定名称，那么默认为[id].js</p>
<p>以path路径下的文件为入口重新生成一个chunk，当代码执行到import所在的语句时，才会去加载chunk对应生成的文件。import会返回一个promise，当文件加载成功时可以在promise的then方法获取对应的文件内容。</p>
<h2 id="scope-hoisting"><a href="#scope-hoisting" class="headerlink" title="scope hoisting"></a>scope hoisting</h2><blockquote>
<p>实现原理</p>
</blockquote>
<p>分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中。但前提是不能造成代码冗余，因此只有被引用了一次的模块才能被合并。</p>
<h2 id="prepack"><a href="#prepack" class="headerlink" title="prepack"></a>prepack</h2><blockquote>
<p>在保持运行结果一致的情况下，改变源码的运行逻辑，输出性能更好的js代码</p>
</blockquote>
<p>工作流程：</p>
<p>1: 通过Babel将js源码解析成抽象语法树，以更细粒度地分析yuanma</p>
<p>2: prepack实现了一个js解释器，用于执行源码。借助这个解释器，prepack才能理解源码具体是如何执行的，并将执行过程中的结果返回到输出中。</p>
<p>使用prepack-webpack-plugin插件。</p>
<h2 id="可视化打包结果"><a href="#可视化打包结果" class="headerlink" title="可视化打包结果"></a>可视化打包结果</h2><ul>
<li><p>webpack-bundle- analyzer</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://wepack.github.io/analyse">http://wepack.github.io/analyse</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E9%85%8D%E7%BD%AE%E9%A1%B9/" data-id="cmebduiym009ypwfmezoy9hdy" data-title="【webpack】配置项" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-读书笔记/webpack/【webpack】工作流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.702Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/">【webpack】工作流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="http://wepack.wuhaolin.cn/5-2%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90.zip">http://wepack.wuhaolin.cn/5-2输出文件分析.zip</a></p>
<p>bundle.js能直接中浏览器运行是因为输出的文件中通过__webpack_require__定义了一个可以在浏览器执行的加载函数，模拟nodejs的require。</p>
<p>原本一个个独立的模块文件被合并到了一个单独的bundle.js的原因是浏览器不能像nodejs一样快速在本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件。如果模块数量很多，那么加载时间会很长，因此将所有模块都存放到了数组中，执行一次网络加载。</p>
<h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><ul>
<li>从配置文件和shell语句中读取和合并参数，得出最终的参数</li>
</ul>
<h4 id="发生事件"><a href="#发生事件" class="headerlink" title="发生事件"></a>发生事件</h4><table>
<thead>
<tr>
<th>event name</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>初始化参数</td>
<td>从配置文件和shell语句中读取合并参数，得出最终的参数，在这个过程中还会执行配置文件中的插件实例化语句 new Plugin（）</td>
</tr>
<tr>
<td>实例化compiler</td>
<td>用上一步得到的参数初始化compiler实例，compiler负责文件监听和启动编译，在compiler实例中包含了完整的webpack配置，全局只有一个compiler实例</td>
</tr>
<tr>
<td>加载插件</td>
<td>依次调用插件的apply方法，让插件可以监听后续的所有事件节点。同时向插件传入compiler实例的引用，以方便插件通过compiler调用webpack提供的api</td>
</tr>
<tr>
<td>environment</td>
<td>开始应用nodejs风格的文件系统到complier对象，以方便后续的文件寻找和读取</td>
</tr>
<tr>
<td>entry-option</td>
<td>读取配置的entrys，为每个entry实例化一个对应的entrypath，为后面该entry的递归解析工作做准备</td>
</tr>
<tr>
<td>after-plugins</td>
<td>调用完所有的内置和配置的插件apply方法</td>
</tr>
<tr>
<td>after-resolvers</td>
<td>根据配置初始化resolver，resolver负责在文件系统中寻找指定路径的文件</td>
</tr>
</tbody></table>
<h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><h4 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h4><ul>
<li>用上一步得到的参数初始化compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译</li>
</ul>
<h4 id="确定入口"><a href="#确定入口" class="headerlink" title="确定入口"></a>确定入口</h4><ul>
<li>配置的entry找出所有的入口文件</li>
</ul>
<h4 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h4><p>从入口文件出发，调用所有的配置的loader对模块进行翻译，再找出模块依赖的模块，再递归本步骤直至所有的入口依赖的文件都经过本步骤的处理</p>
<h4 id="完成编译模块"><a href="#完成编译模块" class="headerlink" title="完成编译模块"></a>完成编译模块</h4><p>使用loader翻译完所有的模块后，得到每个模块被翻译后的最终内容以及它们之间的依赖关系</p>
<h4 id="发生事件-1"><a href="#发生事件-1" class="headerlink" title="发生事件"></a>发生事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>启动一次新的编译</td>
</tr>
<tr>
<td>watch-run</td>
<td>和run类似，但是是在监听模式下启动编译，可以获取是哪些文件发生变化导致重新启动编译</td>
</tr>
<tr>
<td>compile</td>
<td>告诉插件一次新的编译将要启动，同时会给插件带上compiler对象</td>
</tr>
<tr>
<td>compilation</td>
<td>当webpack以开发模式运行时，每当检测到文件的变化，便有一次新的Compilation被创建。一个Compilation对象包含了当前当模块资源，编译生成资源，变化的文件等，此对象也提供很多事件回调给插件进行扩展</td>
</tr>
<tr>
<td>make</td>
<td>一个新的Compilation创建完毕，即将从entry开始读取文件，根据文件当类型和配置的loader对文件进行编译，编译完成后再找出该文件依赖的文件，递归的编译解析</td>
</tr>
<tr>
<td>after-compile</td>
<td>一次Compilation执行完成</td>
</tr>
<tr>
<td>invalid</td>
<td>当遇到文件不存在，文件编译错误等异常时会触发该事件，该事件不会导致webpack退出</td>
</tr>
</tbody></table>
<h4 id="compilation阶段的事件"><a href="#compilation阶段的事件" class="headerlink" title="compilation阶段的事件"></a>compilation阶段的事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>build-module</td>
<td>使用对应的loader去转换一个模块</td>
</tr>
<tr>
<td>normal- module- loader</td>
<td>在用loader转换完一个模块后，使用acorn解析转换后的内容，输出对应的ast，方便web pack对后面的代码进行分析</td>
</tr>
<tr>
<td>program</td>
<td>从配置的入口模块开始，分析其ast，当遇到require等导入其他模块的语句时，便将其加入依赖的模块列表中，同时对新找出的依赖模块递归分析，最终弄清所有模块的依赖关系</td>
</tr>
<tr>
<td>seal</td>
<td>所有模块及其依赖的模块都通过loader转换完成，依据依赖关系开始生成chunk</td>
</tr>
</tbody></table>
<h3 id="输出阶段"><a href="#输出阶段" class="headerlink" title="输出阶段"></a>输出阶段</h3><h4 id="输出资源"><a href="#输出资源" class="headerlink" title="输出资源"></a>输出资源</h4><p>根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中。</p>
<h4 id="输出完成"><a href="#输出完成" class="headerlink" title="输出完成"></a>输出完成</h4><p>确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中</p>
<h4 id="发生事件-2"><a href="#发生事件-2" class="headerlink" title="发生事件"></a>发生事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>should-emit</td>
<td>所有需要输出的文件已经生成，询问插件哪些文件需要输出，哪些不需要输出</td>
</tr>
<tr>
<td>emit</td>
<td>确定好要输出哪些文件后，执行文件输出，可以在此回调中获取和修改输出的内容</td>
</tr>
<tr>
<td>after-emit</td>
<td>文件输出完毕</td>
</tr>
<tr>
<td>done</td>
<td>成功完成一次完整的编译输出流程</td>
</tr>
<tr>
<td>failed</td>
<td>如果在编译和输出的流程中遇到异常，导致webpack退出，就会直接跳转到本步骤，插件在本事件中可以获取具体的错误原因</td>
</tr>
</tbody></table>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>webpack通过tapable来组织广播打包流程。webpack在运行时会广播事件，插件只需要监听它所关心的事件，就能加入这条线中，去改变打包的结果。</p>
<p>webpack的事件流机制保证了插件的有序性，使得整个系统的扩展性良好。事件流机制应用了观察者模式，和nodejs的eventemitter类似。compiler和compilation都继承至tapable，可以直接中在complier和compilation对象上广播和监听事件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/webpack/%E3%80%90webpack%E3%80%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" data-id="cmebduiym00a1pwfmdiyd63oi" data-title="【webpack】工作流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWA/">PWA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Typescript/">Typescript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VueTest/">VueTest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/axios-%E6%BA%90%E7%A0%81/">axios 源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuex-%E6%BA%90%E7%A0%81/">vuex 源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web3/">web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webAssembly/">webAssembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webwork/">webwork</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/">业务场景</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/">扩展阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/">额外内容</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typescript/" rel="tag">Typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueTest/" rel="tag">VueTest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web3/" rel="tag">Web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios-%E6%BA%90%E7%A0%81/" rel="tag">axios 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/" rel="tag">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console/" rel="tag">console</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex-%E6%BA%90%E7%A0%81/" rel="tag">vuex 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web3/" rel="tag">web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webAssembly/" rel="tag">webAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webRTC/" rel="tag">webRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webwork/" rel="tag">webwork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" rel="tag">业务场景</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" rel="tag">扩展阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8-Performance-Chrome/" rel="tag">浏览器 Performance Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/" rel="tag">额外内容</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Typescript/" style="font-size: 12px;">Typescript</a> <a href="/tags/VueTest/" style="font-size: 10px;">VueTest</a> <a href="/tags/Web3/" style="font-size: 20px;">Web3</a> <a href="/tags/axios-%E6%BA%90%E7%A0%81/" style="font-size: 14px;">axios 源码</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/console/" style="font-size: 10px;">console</a> <a href="/tags/css/" style="font-size: 18px;">css</a> <a href="/tags/http/" style="font-size: 12px;">http</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/react/" style="font-size: 12px;">react</a> <a href="/tags/vue/" style="font-size: 12px;">vue</a> <a href="/tags/vuex-%E6%BA%90%E7%A0%81/" style="font-size: 12px;">vuex 源码</a> <a href="/tags/web3/" style="font-size: 12px;">web3</a> <a href="/tags/webAssembly/" style="font-size: 10px;">webAssembly</a> <a href="/tags/webRTC/" style="font-size: 12px;">webRTC</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/webwork/" style="font-size: 10px;">webwork</a> <a href="/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" style="font-size: 10px;">业务场景</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 12px;">小程序</a> <a href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" style="font-size: 12px;">扩展阅读</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 16px;">浏览器</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8-Performance-Chrome/" style="font-size: 10px;">浏览器 Performance Chrome</a> <a href="/tags/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/" style="font-size: 10px;">额外内容</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/14/%E6%89%8B%E5%86%99%E9%A2%98/">手写题</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90%E6%89%8B%E5%86%99%E3%80%91call%E3%80%81apply%E3%80%81bind/">【手写】call、apply、bind</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90wasb%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">【wasb】环境搭建</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90RN%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">【RN】环境搭建</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90AST%E3%80%91-%E8%A7%A3%E6%9E%90attrs/">解析 attrs</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 yangxin<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>