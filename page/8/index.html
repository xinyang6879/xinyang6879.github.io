<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yangxin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yangxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" class="post-title-link" itemprop="url">记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:06" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-25 15:32:58" itemprop="dateModified" datetime="2025-07-25T15:32:58+08:00">2025-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变"></a>协变与逆变</h3><p>   ┌───────────┐       ┌───────────┐<br>   │  父类型    │       │  子类型    │<br>   │ (宽泛)    │       │ (具体)    │<br>   └─────┬─────┘       └─────┬─────┘<br>         │                   │<br>         ▼ 协变（同向）       ▼ 逆变（反向）<br>┌────────────────┐     ┌────────────────┐<br>│ 集合&#x2F;返回值类型 │     │ 函数参数类型    │<br>│   协变领域     │     │   逆变领域      │<br>└────────────────┘     └────────────────┘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;strictFunctionTypes&quot;: true //严格函数参数（启用逆变检查）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h4><p>如果类型A是类型B的子类型，那么由A组成的复杂类型（比如数组、泛型等）也是由B组成的复杂类型的子类型。换句话说，子类型关系与复杂类型构造器保持同向。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">animal</span>: <span class="title class_">Animal</span> = dog;<span class="comment">// ✅ 允许：Dog → Animal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协变示例：返回值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalFactory</span> = <span class="function">() =&gt;</span> <span class="title class_">Animal</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogFactory</span> = <span class="function">() =&gt;</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">makeDog</span>: <span class="title class_">DogFactory</span> = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="attr">makeAnimal</span>: <span class="title class_">AnimalFactory</span> = makeDog; <span class="comment">// ✅ 允许</span></span><br></pre></td></tr></table></figure>

<h4 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h4><p>如果类型A是类型B的子类型，那么在某些情况下，由B组成的复杂类型反而成为由A组成的复杂类型的子类型。在函数参数中，这种关系是逆变的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AnimalCallback</span> = <span class="function">(<span class="params"><span class="attr">animal</span>: <span class="title class_">Animal</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogCallback</span> = <span class="function">(<span class="params"><span class="attr">dog</span>: <span class="title class_">Dog</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">animalCallback</span>: <span class="title class_">AnimalCallback</span> = <span class="function">(<span class="params"><span class="attr">animal</span>: <span class="title class_">Animal</span></span>) =&gt;</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">dogCallback</span>: <span class="title class_">DogCallback</span> = <span class="function">(<span class="params"><span class="attr">dog</span>: <span class="title class_">Dog</span></span>) =&gt;</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是逆变的：因为Dog是Animal的子类型，但AnimalCallback是DogCallback的子类型</span></span><br><span class="line">dogCallback = animalCallback; <span class="comment">// 允许，因为AnimalCallback可以赋值给DogCallback</span></span><br><span class="line"><span class="comment">// animalCallback = dogCallback; // 错误，DogCallback不能赋值给AnimalCallback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑一个函数dogCallback，它接受一个Dog参数。如果我们把一个animalCallback赋值给它，那么dogCallback在调用时传入一个Dog（它是Animal的子类型）是安全的，因为animalCallback可以处理任何Animal，包括Dog。</span></span><br><span class="line"><span class="comment">// 反过来，如果我们将dogCallback赋值给animalCallback，那么当我们用animalCallback去处理一个Cat（也是Animal）时，实际上会调用dogCallback，而它只处理Dog，这样就会出错。</span></span><br></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>函数重载允许单个函数根据不同的输入类型或数量提供不同的返回类型和实现逻辑。与传统的面向对象语言不同，TS 重载是类型系统层面的解决方案。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载签名（类型声明）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">boolean</span></span>): <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现签名（实际实现）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">unknown</span></span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 返回字符串数组</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input * <span class="number">2</span>; <span class="comment">// 返回数字</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !input; <span class="comment">// 返回布尔值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> strResult = <span class="title function_">processInput</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// string[] 类型</span></span><br><span class="line"><span class="keyword">const</span> numResult = <span class="title function_">processInput</span>(<span class="number">10</span>);      <span class="comment">// number 类型</span></span><br><span class="line"><span class="keyword">const</span> boolResult = <span class="title function_">processInput</span>(<span class="literal">true</span>);   <span class="comment">// boolean 类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>精确的类型推断（根据输入返回对应类型）</li>
<li>参数多态（支持不同参数组合）</li>
<li>接口契约强化（明确调用约束）</li>
<li>代码自文档化（声明即文档）</li>
</ul>
<h3 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h3><p>有点类似于class的<code>extends</code>，只能用于class，是类的专属语法糖</p>
<p>用于<strong>强制类遵循特定接口或类的契约</strong>，确保类结构符合预定义规范。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>class可以继承多个，也可以继承单个</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="title function_">serialize</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deserializable</span> &#123;</span><br><span class="line">  <span class="title function_">deserialize</span>(<span class="attr">data</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, <span class="title class_">Deserializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">settings</span>: <span class="built_in">object</span> = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">serialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>.<span class="property">settings</span>); <span class="comment">// ✅</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">deserialize</span>(<span class="params"><span class="attr">data</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">settings</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data); <span class="comment">// ✅</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>动态接口</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureFlags</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">boolean</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeatureService</span> <span class="keyword">implements</span> <span class="title class_">FeatureFlags</span> &#123;</span><br><span class="line">  darkMode = <span class="literal">true</span>;     <span class="comment">// ✅</span></span><br><span class="line">  analytics = <span class="literal">false</span>;   <span class="comment">// ✅</span></span><br><span class="line">  <span class="comment">// ❌ 缺少 string 类型的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型接口</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Repository</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">getById</span>(<span class="attr">id</span>: <span class="built_in">number</span>): T | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="title function_">save</span>(<span class="attr">entity</span>: T): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepository</span> <span class="keyword">implements</span> <span class="title class_">Repository</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> users = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="title class_">User</span>&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">getById</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">get</span>(id); <span class="comment">// ✅ 返回 User 类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">save</span>(<span class="params"><span class="attr">user</span>: <span class="title class_">User</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">set</span>(user.<span class="property">id</span>, user); <span class="comment">// ✅</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="和extends区别"><a href="#和extends区别" class="headerlink" title="和extends区别"></a>和extends区别</h4><p>extends和implements都类似，都用于class上，都需要加上已定义的对应的属性和函数</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>implements</th>
<th>extends</th>
</tr>
</thead>
<tbody><tr>
<td>继承关系</td>
<td>实现接口契约（非继承）</td>
<td>继承父类属性和方法</td>
</tr>
<tr>
<td>多继承</td>
<td>支持多接口（,分隔）</td>
<td>仅支持单类继承</td>
</tr>
<tr>
<td>方法实现</td>
<td>必须重写所有接口方法</td>
<td>可选择重写父类方法</td>
</tr>
<tr>
<td>构造函数</td>
<td>不调用父构造函数</td>
<td>必须调用super()</td>
</tr>
<tr>
<td>类型兼容性</td>
<td>确保符合接口形状</td>
<td>创建父子类型关系</td>
</tr>
</tbody></table>
<h3 id="value-is-string和value-as-string类型断言区别"><a href="#value-is-string和value-as-string类型断言区别" class="headerlink" title="value is string和value as string类型断言区别"></a>value is string和value as string类型断言区别</h3><h4 id="value-is-string"><a href="#value-is-string" class="headerlink" title="value is string"></a><code>value is string</code></h4><p>属于<code>类型谓词</code>，用于自定义类型保护函数</p>
<p>特点：</p>
<pre><code>- 在类型收窄中使用
- 返回 boolean 值
- 用于函数返回类型声明
- 执行运行时检查
</code></pre>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型谓词函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processInput</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isString</span>(input)) &#123;</span><br><span class="line">    <span class="comment">// 在这个代码块中，TypeScript 知道 input 是 string 类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input.<span class="title function_">toUpperCase</span>()); <span class="comment">// ✅ 安全调用字符串方法</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// input 被收窄为非 string 类型</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Input is not a string&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="value-as-string"><a href="#value-as-string" class="headerlink" title="value as string"></a><code>value as string</code></h4><p>属于类型断言，强制将某个值视为特定类型</p>
<p>特点：</p>
<pre><code>- 直接应用于值
- 不进行运行时检查
- 仅影响编译时类型检查
- 强制转换类型（可能不安全）
</code></pre>
<p>使用场景</p>
<ul>
<li>创建类型守卫函数</li>
<li>需要运行时类型检查</li>
<li>在条件语句中收窄类型</li>
<li>构建类型安全的验证函数</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型断言 - 告诉编译器 someValue 应该被视为 string 类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用尖括号语法（在 JSX 中不推荐）</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength2</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<ul>
<li>确定值的类型但 TypeScript 不知道</li>
<li>从第三方库获取的值，你知道其类型</li>
<li>在联合类型中明确指定具体类型</li>
<li>与 DOM API 交互时（TypeScript 通常给出更宽泛的类型）</li>
</ul>
<h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>value is string</th>
<th>value as string</th>
</tr>
</thead>
<tbody><tr>
<td>用途</td>
<td>类型谓词，用于类型保护函数</td>
<td>类型断言，强制指定值的类型</td>
</tr>
<tr>
<td>位置</td>
<td>函数返回类型位置</td>
<td>直接应用于值</td>
</tr>
<tr>
<td>运行时行为</td>
<td>执行实际的类型检查</td>
<td>不执行任何运行时检查</td>
</tr>
<tr>
<td>安全性</td>
<td>安全，基于实际检查</td>
<td>可能不安全，仅是编译时假设</td>
</tr>
<tr>
<td>类型收窄</td>
<td>用于 if 语句中收窄类型</td>
<td>直接当作指定类型使用</td>
</tr>
</tbody></table>
<h3 id="type和interface区别"><a href="#type和interface区别" class="headerlink" title="type和interface区别"></a>type和interface区别</h3><p>type和interface都可以用于ts中定义类型</p>
<ul>
<li><p>声明合并</p>
<ul>
<li>type如果重复定义，那么后面会覆盖前面的</li>
<li>interface如果重复定义，那么会合并  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并后：&#123; name: string; age: number &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>扩展方式</p>
<ul>
<li><code>interface</code> 使用 <code>extends</code> 关键字进行扩展。</li>
<li><code>type</code> 使用交叉类型（<code>&amp;</code>）进行扩展。 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface 扩展</span></span><br><span class="line"><span class="keyword">interface</span> A &#123; <span class="attr">a</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> B <span class="keyword">extends</span> A &#123; <span class="attr">b</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="comment">// type 扩展</span></span><br><span class="line"><span class="keyword">type</span> C = &#123; <span class="attr">c</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> D = C &amp; &#123; <span class="attr">d</span>: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure>
 注意：interface也可以扩展type，type也可以使用交叉类型扩展interface。</li>
</ul>
</li>
<li><p>implements<br>  implements可以使用interface和type作为class类的继承</p>
<ul>
<li>interface可以继承联合类型</li>
<li>type不可以使用联合类型  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型定义</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PointUnion</span> = </span><br><span class="line">| &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125; </span><br><span class="line">| &#123; <span class="attr">lat</span>: <span class="built_in">number</span>; <span class="attr">lng</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3</span> <span class="keyword">implements</span> <span class="title class_">PointUnion</span> &#123; </span><br><span class="line"><span class="comment">// ❌ 错误：无法实现联合类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>类型范围</p>
<ul>
<li><code>interface</code> 只能用于定义对象类型（包括函数、索引签名等），不能用于定义非对象类型，如原始类型、联合类型、元组等。</li>
<li><code>type</code> 更灵活，可以定义任意类型，包括原始类型、联合类型、元组、映射类型、条件类型等。</li>
</ul>
</li>
<li><p>工具提示</p>
<ul>
<li>interface：鼠标悬停时，不显示具体的定义内容</li>
<li>type: 鼠标悬停时，会显示具体的定义内容</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>interface：编译更快</li>
<li>type：复杂类型时编译稍慢</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">【TS】类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 11:19:48" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ts除了基础类型，还有通过ts的语法来定义的很多类型</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>symbol: 表示唯一且不可变的值，通常用作对象属性的键。</li>
<li>bigint：大整数</li>
<li>Null：表示 null 值，未赋值</li>
<li>Undefined：表示未定义</li>
</ul>
<h2 id="对象结构类型"><a href="#对象结构类型" class="headerlink" title="对象结构类型"></a>对象结构类型</h2><ul>
<li>Object</li>
<li>Function： 函数类型</li>
<li>接口	interface User { id: number }	结构化契约</li>
<li>构造函数类型	new (name: string) &#x3D;&gt; Animal	类构造函数</li>
<li>索引签名	{ [key: string]: number }	动态键值类型</li>
</ul>
<h2 id="内置对象类型"><a href="#内置对象类型" class="headerlink" title="内置对象类型"></a>内置对象类型</h2><ul>
<li>Array  Array<T> 数组</li>
<li>Date	new Date()	日期对象</li>
<li>RegExp	&#x2F;ab+c&#x2F;	正则表达式</li>
<li>Error	new Error()	错误对象</li>
<li>Map&lt;K,V&gt;	new Map&lt;string, number&gt;()	ES6 Map</li>
<li>Set<T>	new Set<number>()	ES6 Set</li>
<li>Promise<T>	Promise.resolve(42)	异步操作</li>
</ul>
<h2 id="特殊基础类型"><a href="#特殊基础类型" class="headerlink" title="特殊基础类型"></a>特殊基础类型</h2><ul>
<li>Never：永远也不出现的值，一般表示为错误</li>
<li>any：任何类型</li>
<li>void: 表示空，一般用于函数返回</li>
<li>unknown：表示未知类型，比any更安全，因为不能直接对其进行操作</li>
</ul>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><ul>
<li>enum： 枚举</li>
<li>tuple：元组，固定长度和类型的数组<ul>
<li>[T, …T[]]: 至少有一个元素（T），长度不固定（…T[]）</li>
</ul>
</li>
<li>联合类型： type T &#x3D; string | number | boolean;</li>
<li>可辨识联合类型： type T &#x3D;  { kind: “circle”; radius: number } | { kind: “square”; size: number };例如redux的action</li>
<li>交叉类型： type T &#x3D; { a: string } &amp; { b: number };</li>
<li>字面量类型：type T &#x3D; “success” | “fail” | “loading”</li>
</ul>
<p>可辨识联合类型和联合类型区别</p>
<ul>
<li>可辨识联合类型<strong>必须有共同字面量类型标签属性</strong>； 联合类型<strong>没有</strong>可辨识联合类型</li>
<li>因此可辨识联合类型可以通过标签属性自动精确区分， 而联合类型不行  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = </span><br><span class="line">&#123; <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>; <span class="attr">radius</span>: <span class="built_in">number</span> &#125; </span><br><span class="line">| &#123; <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>; <span class="attr">size</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通联合类型无法直接区分具体类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>) &#123;</span><br><span class="line"><span class="comment">// ❌ 错误：TS 不知道 shape 是 circle 还是 square</span></span><br><span class="line"> <span class="keyword">return</span> shape.<span class="property">radius</span> * shape.<span class="property">radius</span> * <span class="title class_">Math</span>.<span class="property">PI</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用标签属性进行类型收窄</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">DiscriminatedShape</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">    <span class="comment">// ✅ 自动识别为 circle 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">    <span class="comment">// ✅ 自动识别为 square 类型</span></span><br><span class="line">    <span class="keyword">return</span> shape.<span class="property">size</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可辨识联合需要用switch&#x2F;case手动收窄，联合类型需要手动类型断言</li>
<li>可辨识联合安全性高于联合类型</li>
</ul>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是 TypeScript 的核心类型编程特性，它允许创建可重用的类型&#x2F;函数组件，这些组件可以动态适应不同数据类型而不丢失类型安全</p>
<p>泛型本质：类型参数化</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础语法：在尖括号中声明类型变量</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：显式或隐式指定类型</span></span><br><span class="line"><span class="keyword">const</span> num = identity&lt;<span class="built_in">number</span>&gt;(<span class="number">42</span>);     <span class="comment">// 显式</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="title function_">identity</span>(<span class="string">&quot;hello&quot;</span>);        <span class="comment">// 隐式推断为 string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>命名规范：使用单字母大写（T, U, K）或描述性名称（TData）</li>
<li>避免 any：优先用泛型替代 any 保持类型安全</li>
<li>渐进复杂：从简单约束开始，逐步增加类型操作</li>
<li>组合使用：泛型 + 条件类型 + 映射类型 &#x3D; 强大类型系统</li>
</ul>
<h4 id="函数泛型"><a href="#函数泛型" class="headerlink" title="函数泛型"></a>函数泛型</h4><p>自动推断函数的参数和返回的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"><span class="attr">parans</span>: T[]</span>): T[] | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> parans[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> num = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// number | undefined</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]); <span class="comment">// string | undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="接口泛型"><a href="#接口泛型" class="headerlink" title="接口泛型"></a>接口泛型</h4><p>定义灵活数据结构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TResponse</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="attr">data</span>: T</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">msg</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TRequest1</span> = <span class="title class_">TResponse</span>&lt;&#123;</span><br><span class="line">  <span class="attr">list</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;&gt;  </span><br><span class="line"><span class="comment">// TRequest1 = &#123;</span></span><br><span class="line"><span class="comment">//     data: &#123;</span></span><br><span class="line"><span class="comment">//         list: number[];</span></span><br><span class="line"><span class="comment">//     &#125;;</span></span><br><span class="line"><span class="comment">//     code: number;</span></span><br><span class="line"><span class="comment">//     msg: string;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="类泛型"><a href="#类泛型" class="headerlink" title="类泛型"></a>类泛型</h4><p>创建可复用组件</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型栈类（支持任意元素类型）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">items</span>: T[] = [];</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">push</span>(<span class="params"><span class="attr">item</span>: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">pop</span>(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">numberStack.<span class="title function_">push</span>(<span class="number">1</span>);  <span class="comment">// ✅ 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">stringStack.<span class="title function_">push</span>(<span class="string">&quot;text&quot;</span>); <span class="comment">// ✅ 合法</span></span><br><span class="line">stringStack.<span class="title function_">push</span>(<span class="number">123</span>);    <span class="comment">// ❌ 类型错误</span></span><br></pre></td></tr></table></figure>

<p>使用原型属性推断并约束构造函数与类实例的关系</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeeKeeper</span> &#123;</span><br><span class="line">    <span class="attr">hasMask</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooKeeper</span> &#123;</span><br><span class="line">    <span class="attr">nametag</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">numLegs</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="attr">keeper</span>: <span class="title class_">BeeKeeper</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="attr">keeper</span>: <span class="title class_">ZooKeeper</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createInstance&lt;A <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt;(<span class="attr">c</span>: <span class="title function_">new</span> () =&gt; A): A &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Lion</span>).<span class="property">keeper</span>.<span class="property">nametag</span>;  <span class="comment">// typechecks!</span></span><br><span class="line"><span class="title function_">createInstance</span>(<span class="title class_">Bee</span>).<span class="property">keeper</span>.<span class="property">hasMask</span>;   <span class="comment">// typechecks!</span></span><br></pre></td></tr></table></figure>

<h4 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h4><p>限制泛型范围</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求 T 必须包含 length 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Lengthwise</span> = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> logLength&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">obj</span>: T) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logLength</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// ✅ 合法 (length=5)</span></span><br><span class="line"><span class="title function_">logLength</span>(<span class="number">42</span>);      <span class="comment">// ❌ 错误：数字没有 length</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="默认类型参数"><a href="#默认类型参数" class="headerlink" title="默认类型参数"></a>默认类型参数</h4><p>提供备用类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认泛型类型为 number</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pagination</span>&lt;T = <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="attr">currentPage</span>: T;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">page</span>: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentPage</span> = page;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page1 = <span class="keyword">new</span> <span class="title class_">Pagination</span>(<span class="number">1</span>);     <span class="comment">// T = number</span></span><br><span class="line"><span class="keyword">const</span> page2 = <span class="keyword">new</span> <span class="title class_">Pagination</span>&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;home&quot;</span>); <span class="comment">// T = string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取函数返回类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnType</span>&lt;T&gt; = T <span class="title function_">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FnReturn</span> = <span class="title class_">ReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="过滤筛选"><a href="#过滤筛选" class="headerlink" title="过滤筛选"></a>过滤筛选</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤出函数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionType</span>&lt;T&gt; = T <span class="title function_">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span> ? T : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mixed</span> = <span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionsOnly</span> = <span class="title class_">FunctionType</span>&lt;<span class="title class_">Mixed</span>&gt;; <span class="comment">// () =&gt; void</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="keyof-操作符"><a href="#keyof-操作符" class="headerlink" title="keyof 操作符"></a>keyof 操作符</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fun&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">params</span>: T, <span class="attr">key</span>: K): T[K] &#123;</span><br><span class="line">  <span class="keyword">return</span> params[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="title function_">fun</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="string">&#x27;b&#x27;</span>)<span class="comment">//错误，b不在params的属性中</span></span><br></pre></td></tr></table></figure>

<h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>基于类型条件来定义类型的机制，使用extends关键字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsString</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">IsString</span>&lt;<span class="string">&quot;abc&quot;</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>可以依据传入的参数而返回不同的类型，比如判断传入的参数是否为字符串，如果是字符串则返回 true，否则返回 false</p>
<h4 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h4><p>infer是只能和extends一起搭配使用，因为infer 的设计初衷是在类型匹配的过程中提取信息，它依赖于 extends 所提供的类型匹配机制。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Example</span>&lt;T&gt; = T <span class="keyword">extends</span> infer U ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>使用规则：</p>
<ul>
<li>infer 必须出现在extends 条件类型的左侧</li>
<li>作用是在类型系统中推断某个子类型</li>
</ul>
<p>和<code>typeof</code>区别：</p>
<ul>
<li><p><code>typeof</code>: 获取一个值的类型，即某个值&#x2F;函数的类型是已经确定好了的，在运行时获取这个值的类型</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> name; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> user; <span class="comment">// &#123; name: string; age: number &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T = <span class="keyword">typeof</span> add; <span class="comment">// (a: number, b: number) =&gt; number</span></span><br></pre></td></tr></table></figure>

<ul>
<li>适用场景：<ul>
<li>获取变量的类型</li>
<li>获取函数的类型签名</li>
<li>获取对象的结构类型</li>
<li>用于类型守卫中做运行时判断</li>
</ul>
</li>
</ul>
</li>
<li><p><code>infer</code>: 推断某个类型的子类型，只能和<code>extends</code>一起使用</p>
  <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetReturnType</span>&lt;T&gt; = T <span class="title function_">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">GetReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">string</span>&gt;; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetElementType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer E&gt; ? E : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">GetElementType</span>&lt;<span class="built_in">number</span>[]&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnwrapPromise</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;infer P&gt; ? P : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">UnwrapPromise</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<ul>
<li>适用场景：<ul>
<li>提取函数返回值类型（如 ReturnType<T>）</li>
<li>提取数组元素类型（如 ExtractArrayElement<T>）</li>
<li>提取 Promise 内部类型（如 UnwrapPromise<T>）</li>
<li>类型编程中做类型转换和提取</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>typeof</th>
<th>infer</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>获取值的类型</td>
<td>在类型中提取子类型</td>
</tr>
<tr>
<td>使用位置</td>
<td>可用于任意类型声明</td>
<td>只能在 extends 条件类型中使用</td>
</tr>
<tr>
<td>作用对象</td>
<td>运行时值（变量、对象、函数等）</td>
<td>类型（函数类型、数组类型、Promise 等）</td>
</tr>
<tr>
<td>是否用于类型推断</td>
<td>是，基于值推断类型</td>
<td>是，基于类型推断子类型</td>
</tr>
<tr>
<td>是否影响运行时</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>典型用途</td>
<td>类型复用、类型守卫</td>
<td>类型提取、类型转换、泛型编程</td>
</tr>
</tbody></table>
<h4 id="分布式条件类型"><a href="#分布式条件类型" class="headerlink" title="分布式条件类型"></a>分布式条件类型</h4><p>分布式条件类型是 TypeScript 中的一种特殊行为，当条件类型作用于泛型类型参数时，如果该类型是 联合类型（A | B），则条件会 分布 到每一个联合成员上，分别计算，再将结果合并成一个新的联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToFlag</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;num&quot;</span> : <span class="string">&quot;other&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">ToFlag</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt;;</span><br><span class="line"><span class="comment">// 分布后：</span></span><br><span class="line"><span class="comment">// ToFlag&lt;number&gt; | ToFlag&lt;string&gt; | ToFlag&lt;boolean&gt;</span></span><br><span class="line"><span class="comment">// =&gt; &#x27;num&#x27; | &#x27;other&#x27; | &#x27;other&#x27;</span></span><br><span class="line"><span class="comment">// =&gt; &#x27;num&#x27; | &#x27;other&#x27;</span></span><br><span class="line"><span class="comment">// =&gt; R=&#x27;num&#x27; | &#x27;other&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="裸类型参数"><a href="#裸类型参数" class="headerlink" title="裸类型参数"></a>裸类型参数</h4><p>裸类型参数，就是指这个类型参数 T 被直接写在 extends 的左侧，没有被任何结构包裹住</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>这里的<code>T</code>就是裸类型参数，它没有被放进数组、对象或别的东西里</p>
<p>条件类型中，如果 T 是裸类型参数，并且 T 是联合类型，TypeScript 会将其拆分每个成员进行判断；一旦我们用结构包裹了 T，它就失去了这种分布能力。</p>
<ul>
<li>分布式特性</li>
</ul>
<p>当我们传入的泛型类型是联合类型，比如 number | string | boolean，而条件类型的写法又是 T extends U ? X : Y 这种形式时，TypeScript 会自动对联合类型的每个成员<strong>分别</strong>进行判断。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToFlag</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">ToFlag</span>&lt;<span class="built_in">number</span>&gt;;<span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">ToFlag</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt;; <span class="comment">// boolean(true | false)</span></span><br></pre></td></tr></table></figure>

<p>但只有当T是裸类型参数时，才会进行分布式判断。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToFlag</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">number</span>] ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">ToFlag</span>&lt;<span class="built_in">number</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = <span class="title class_">ToFlag</span>&lt;[<span class="built_in">number</span>]&gt;; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> R = <span class="title class_">ToFlag</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span> | <span class="built_in">boolean</span>&gt;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>因为这里的T已经被包裹起来的，所以是对整体进行一个判断，如果满足条件，则返回true，否则返回false。</p>
<p>条件类型中，如果 T 是裸类型参数，并且 T 是联合类型，TypeScript 会将其拆分每个成员进行判断；一旦我们用结构包裹了 T，它就失去了这种分布能力。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><h5 id="类型推断-1"><a href="#类型推断-1" class="headerlink" title="类型推断"></a>类型推断</h5><p>对无子类型进行推断：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">IsString</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetStyle</span>&lt;T&gt; = <span class="title class_">IsString</span>&lt;T&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? T : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test1</span> = <span class="title class_">GetStyle</span>&lt;<span class="string">&#x27;abc&#x27;</span>&gt;;   <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test2</span> = <span class="title class_">GetStyle</span>&lt;<span class="built_in">number</span>&gt;;  <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<p>对带子类型进行推断：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetChildType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer E&gt; ? E : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 类型为number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumType</span> = <span class="title class_">GetChildType</span>&lt;<span class="keyword">typeof</span> numbers&gt;; <span class="comment">// NumType 推断为 number</span></span><br></pre></td></tr></table></figure>

<h5 id="类型过滤"><a href="#类型过滤" class="headerlink" title="类型过滤"></a>类型过滤</h5><p>从一个联合类型中，筛选出需要的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FunctionFilter</span>&lt;T&gt; = T <span class="title function_">extends</span> (...args) =&gt; <span class="built_in">void</span> ? T : <span class="built_in">never</span>;S</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mixed</span> = <span class="built_in">string</span> | (<span class="function">() =&gt;</span> <span class="built_in">void</span>) | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyFunctions</span> = <span class="title class_">FunctionFilter</span>&lt;<span class="title class_">Mixed</span>&gt;; <span class="comment">// OnlyFunctions 为 () =&gt; void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义条件类型：提取键名，如果属性值是字符串类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractStringKeys</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? K : <span class="built_in">never</span></span><br><span class="line">&#125;[keyof T]; <span class="comment">// 映射类型过滤，并提取非 never 的键</span></span><br></pre></td></tr></table></figure>

<h5 id="条件映射"><a href="#条件映射" class="headerlink" title="条件映射"></a>条件映射</h5><p>在映射类型中使用条件，例如创建只读或可写版本、选择或排除满足条件的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将联合类型合并为一个类型，例如 &#123;a: string&#125; &amp; &#123;b: number&#125; =&gt; &#123;a: string, b: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Combine</span>&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]: T[K] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类型中，string类型的数据转为只读类型，其他类型不变</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyIfString</span>&lt;T&gt; = <span class="title class_">Combine</span>&lt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 筛选出string类型的属性，将其加上readonly变为只读</span></span><br><span class="line">    <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? K : <span class="built_in">never</span>]: T[K]</span><br><span class="line">  &#125; &amp; &#123;</span><br><span class="line">    <span class="comment">// T[K] extends string ? never : K  排除掉string类型</span></span><br><span class="line">    <span class="comment">// K in keyof T  循环非string类型的属性</span></span><br><span class="line">    <span class="comment">// T[K] extends object如果是对象，那么递归处理，当然如果不需要递归，可以直接省略掉这里的extends，直接返回T[K]</span></span><br><span class="line">    [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="built_in">never</span> : K]: T[K] <span class="keyword">extends</span> <span class="built_in">object</span></span><br><span class="line">      ? <span class="title class_">ReadonlyIfString</span>&lt;T[K]&gt;</span><br><span class="line">      : T[K]</span><br><span class="line">  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h5 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h5><p>依据不同的输入返回不同的结果</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义条件类型：基于输入类型返回不同输出</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ConvertedType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="built_in">number</span> : T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="built_in">string</span> : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型函数实现（使用类型断言简化）</span></span><br><span class="line"><span class="keyword">function</span> convert&lt;T&gt;(<span class="attr">input</span>: T): <span class="title class_">ConvertedType</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(input) <span class="keyword">as</span> <span class="title class_">ConvertedType</span>&lt;T&gt;; <span class="comment">// 实际实现需处理转换</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="title function_">toString</span>() <span class="keyword">as</span> <span class="title class_">ConvertedType</span>&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported type&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">strResult</span>: <span class="built_in">number</span> = <span class="title function_">convert</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// 输入 string, 输出 number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">numResult</span>: <span class="built_in">string</span> = <span class="title function_">convert</span>(<span class="number">123</span>); <span class="comment">// 输入 number, 输出 string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数重载简化</li>
</ul>
<p>用条件类型替代多个函数重载，使类型定义更简洁。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统函数重载（多个声明）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="comment">// 实现略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用条件类型简化：定义单一泛型函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ProcessedType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="built_in">number</span> : T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="built_in">string</span> : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> process&lt;T&gt;(<span class="attr">input</span>: T): <span class="title class_">ProcessedType</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="property">length</span> <span class="keyword">as</span> <span class="title class_">ProcessedType</span>&lt;T&gt;; <span class="comment">// 示例：返回字符串长度</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.<span class="title function_">toString</span>() <span class="keyword">as</span> <span class="title class_">ProcessedType</span>&lt;T&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Invalid input&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">result1</span>: <span class="built_in">number</span> = <span class="title function_">process</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 输入 string, 输出 number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">result2</span>: <span class="built_in">string</span> = <span class="title function_">process</span>(<span class="number">42</span>); <span class="comment">// 输入 number, 输出 string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>允许你基于现有类型动态创建新类型，通过遍历键集合并应用转换规则实现</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础语法：遍历键集合（K in KeyType）并转换值类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MappedType</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="title class_">NewType</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过映射实现ts部分使用工具类型"><a href="#通过映射实现ts部分使用工具类型" class="headerlink" title="通过映射实现ts部分使用工具类型"></a>通过映射实现ts部分使用工具类型</h4><table>
<thead>
<tr>
<th>工具类型</th>
<th>作用</th>
<th>映射类型实现</th>
</tr>
</thead>
<tbody><tr>
<td>Partial<T></td>
<td>将所有属性变为可选</td>
<td><code>[P in keyof T]?: T[P]</code></td>
</tr>
<tr>
<td>Required<T></td>
<td>将所有属性变为必选</td>
<td><code>[P in keyof T]-?: T[P]</code></td>
</tr>
<tr>
<td>Readonly<T></td>
<td>将所有属性变为只读</td>
<td><code>[P in keyof T]: T[P]</code></td>
</tr>
<tr>
<td>Pick&lt;T,K&gt;</td>
<td>从T中选择一组键位于并集K中的属性</td>
<td><code>[P in K]: T[P]</code></td>
</tr>
<tr>
<td>Record&lt;K,T&gt;</td>
<td>构造一个具有类型T的一组属性K的类型</td>
<td><code>[P in K]: T</code></td>
</tr>
</tbody></table>
<p><code>-?</code>：移除可选标记</p>
<h4 id="类型值转换"><a href="#类型值转换" class="headerlink" title="类型值转换"></a>类型值转换</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有属性转为 boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flags</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有属性转为 Promise</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AsyncData</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]: <span class="title class_">Promise</span>&lt;T[P]&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserFlags</span> = <span class="title class_">Flags</span>&lt;<span class="title class_">User</span>&gt;; </span><br><span class="line"><span class="comment">// &#123; name: boolean; age: boolean &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AsyncUser</span> = <span class="title class_">AsyncData</span>&lt;<span class="title class_">User</span>&gt;;</span><br><span class="line"><span class="comment">// &#123; name: Promise&lt;string&gt;; age: Promise&lt;number&gt; &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="键名重映射"><a href="#键名重映射" class="headerlink" title="键名重映射"></a>键名重映射</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加前缀（模板字面量类型）</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AddPrefix</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; P&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserAccessors</span> = <span class="title class_">AddPrefix</span>&lt;<span class="title class_">User</span>&gt;;</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   getName: () =&gt; string; </span></span><br><span class="line"><span class="comment">//   getAge: () =&gt; number </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="深度递归映射"><a href="#深度递归映射" class="headerlink" title="深度递归映射"></a>深度递归映射</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归所有层级添加 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> <span class="built_in">object</span> </span><br><span class="line">    ? <span class="title class_">DeepReadonly</span>&lt;T[P]&gt; </span><br><span class="line">    : T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NestedData</span> = &#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">permissions</span>: <span class="built_in">string</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LockedData</span> = <span class="title class_">DeepReadonly</span>&lt;<span class="title class_">NestedData</span>&gt;;</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   readonly user: &#123;</span></span><br><span class="line"><span class="comment">//     readonly name: string;</span></span><br><span class="line"><span class="comment">//     readonly permissions: readonly string[];</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="枚举键的映射"><a href="#枚举键的映射" class="headerlink" title="枚举键的映射"></a>枚举键的映射</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span> &#123;</span><br><span class="line">  <span class="variable constant_">DEBUG</span>,</span><br><span class="line">  <span class="variable constant_">INFO</span>,</span><br><span class="line">  <span class="variable constant_">ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建基于枚举键的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LogConfig</span> = &#123;</span><br><span class="line">  [<span class="title class_">Level</span> <span class="keyword">in</span> keyof <span class="keyword">typeof</span> <span class="title class_">LogLevel</span>]: &#123;</span><br><span class="line">    <span class="attr">output</span>: <span class="string">&quot;console&quot;</span> | <span class="string">&quot;file&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   DE<span class="doctag">BUG:</span> &#123; output: &quot;console&quot; | &quot;file&quot; &#125;;</span></span><br><span class="line"><span class="comment">//   INFO: &#123; output: &quot;console&quot; | &quot;file&quot; &#125;;</span></span><br><span class="line"><span class="comment">//   ERROR: &#123; output: &quot;console&quot; | &quot;file&quot; &#125;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>基于字符串字面量创建新类型，支持模式匹配和动态字符串类型生成</p>
<ul>
<li>动态生成字符串字面量类型。</li>
<li>结合联合类型，可以创建所有可能的字符串组合。</li>
<li>常用于事件名称、路径模式、CSS类名等场景。</li>
<li>类型层面的模式匹配</li>
</ul>
<p>但是这些都只能是在编译时的校验，无法使用动态的数据校验</p>
<h4 id="遍历组合生成新类型"><a href="#遍历组合生成新类型" class="headerlink" title="遍历组合生成新类型"></a>遍历组合生成新类型</h4><ul>
<li>事件名称</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventType</span> = <span class="string">&#x27;click&#x27;</span> | <span class="string">&#x27;scroll&#x27;</span>;</span><br><span class="line"><span class="comment">// Capitalize 函数将字符串的第一个字符大写</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EventName</span> = <span class="string">`on<span class="subst">$&#123;Capitalize&lt;EventType&gt;&#125;</span>`</span>;  <span class="comment">// &quot;onClick&quot; | &quot;onScroll&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleEvent</span> = (<span class="params"><span class="attr">event</span>: <span class="title class_">EventName</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Handling event: <span class="subst">$&#123;event&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="string">&quot;onClick&quot;</span>);  <span class="comment">// ✅</span></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="string">&quot;onScroll&quot;</span>); <span class="comment">// ✅</span></span><br><span class="line"><span class="title function_">handleEvent</span>(<span class="string">&quot;onhover&quot;</span>);  <span class="comment">// ❌ 错误，因为&#x27;onhover&#x27;不在允许的类型中</span></span><br></pre></td></tr></table></figure>

<ul>
<li>props：例如弹窗位置的ts定义</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">VerticalAlignment</span> = <span class="string">&quot;top&quot;</span> | <span class="string">&quot;middle&quot;</span> | <span class="string">&quot;bottom&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">HorizontalAlignment</span> = <span class="string">&quot;left&quot;</span> | <span class="string">&quot;center&quot;</span> | <span class="string">&quot;right&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Alignment</span> = <span class="string">`<span class="subst">$&#123;VerticalAlignment&#125;</span>-<span class="subst">$&#123;HorizontalAlignment&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 结果为： &quot;top-left&quot; | &quot;top-center&quot; | &quot;top-right&quot; </span></span><br><span class="line"><span class="comment">//        | &quot;middle-left&quot; | &quot;middle-center&quot; | &quot;middle-right&quot;</span></span><br><span class="line"><span class="comment">//        | &quot;bottom-left&quot; | &quot;bottom-center&quot; | &quot;bottom-right&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象取键</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NestedKeyPaths</span>&lt;T, <span class="title class_">Prefix</span> <span class="keyword">extends</span> <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">object</span> </span><br><span class="line">    ? &#123;</span><br><span class="line">        [K <span class="keyword">in</span> keyof T]: K <span class="keyword">extends</span> <span class="built_in">string</span> </span><br><span class="line">          ? (<span class="title class_">Prefix</span> <span class="keyword">extends</span> <span class="string">&#x27;&#x27;</span> ? K : <span class="string">`<span class="subst">$&#123;Prefix&#125;</span>.<span class="subst">$&#123;K&#125;</span>`</span>) | <span class="title class_">NestedKeyPaths</span>&lt;T[K], <span class="title class_">Prefix</span> <span class="keyword">extends</span> <span class="string">&#x27;&#x27;</span> ? K : <span class="string">`<span class="subst">$&#123;Prefix&#125;</span>.<span class="subst">$&#123;K&#125;</span>`</span>&gt;</span><br><span class="line">          : <span class="built_in">never</span>;</span><br><span class="line">      &#125;[keyof T]</span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Messages</span> &#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    <span class="attr">login</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">logout</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">error</span>: &#123;</span><br><span class="line">    <span class="attr">notFound</span>: <span class="built_in">string</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MessageKeys</span> = <span class="title class_">NestedKeyPaths</span>&lt;<span class="title class_">Messages</span>&gt;; </span><br><span class="line"><span class="comment">// &quot;user&quot; | &quot;user.login&quot; | &quot;user.logout&quot; | &quot;error&quot; | &quot;error.notFound&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结合infer进行模式匹配"><a href="#结合infer进行模式匹配" class="headerlink" title="结合infer进行模式匹配"></a>结合infer进行模式匹配</h4><p>结合infer和条件类型，可以从字符串中提取部分内容。</p>
<ul>
<li><p>提取路由</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractRouteParams</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T extenhs <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/:<span class="subst">$&#123;infer Param&#125;</span>/<span class="subst">$&#123;infer Param2&#125;</span>`</span> ? <span class="title class_">Param</span> | <span class="title class_">ExtractRouteParams</span>&lt;<span class="title class_">Param2</span>&gt; : T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/:<span class="subst">$&#123;infer Param&#125;</span>`</span> ? <span class="title class_">Param</span> : <span class="built_in">never</span>; </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Params</span> = <span class="title class_">ExtractRouteParams</span>&lt;<span class="string">&#x27;/user/:userId/post/:postId&#x27;</span>&gt;;</span><br><span class="line"><span class="comment">// 结果为: &quot;userId&quot; | &quot;postId&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createRoute&lt;<span class="title class_">Path</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">path</span>: <span class="title class_">Path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">match</span>: <span class="function">(<span class="params"><span class="attr">url</span>: <span class="built_in">string</span></span>) =&gt;</span> url === path ? &#123;&#125; : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125; <span class="keyword">as</span> <span class="title class_">ExtractRouteParams</span>&lt;<span class="title class_">Path</span>&gt;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userRoute = <span class="title function_">createRoute</span>(<span class="string">&quot;/user/:id/post/:postId&quot;</span>);</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Params</span> = <span class="keyword">typeof</span> userRoute.<span class="property">params</span>;</span><br><span class="line"><span class="comment">// 自动推断为: &#123; id: string; postId: string &#125;</span></span><br><span class="line"></span><br><span class="line">userRoute.<span class="title function_">match</span>(<span class="string">&quot;/user/123/post/456&quot;</span>)?.<span class="property">params</span>.<span class="property">id</span>; <span class="comment">// ✅ &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取url参数</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 URL 模式</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">URLPattern</span> = <span class="string">`<span class="subst">$&#123;<span class="string">&quot;http&quot;</span> | <span class="string">&quot;https&quot;</span>&#125;</span>://<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>.<span class="subst">$&#123;<span class="string">&quot;com&quot;</span> | <span class="string">&quot;org&quot;</span> | <span class="string">&quot;net&quot;</span>&#125;</span>/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取域名部分</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractDomain</span>&lt;T&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>://<span class="subst">$&#123;infer Domain&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> </span><br><span class="line">    ? <span class="title class_">Domain</span> </span><br><span class="line">    : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BlogDomain</span> = <span class="title class_">ExtractDomain</span>&lt;<span class="string">&quot;https://blog.example.com/posts&quot;</span>&gt;;</span><br><span class="line"><span class="comment">// 推断为 &quot;blog.example&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 应用：安全路由处理</span></span><br><span class="line"><span class="keyword">function</span> handleRoute&lt;<span class="title class_">Path</span> <span class="keyword">extends</span> <span class="title class_">URLPattern</span>&gt;(<span class="attr">path</span>: <span class="title class_">Path</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> domain = path.<span class="title function_">split</span>(<span class="string">&quot;://&quot;</span>)[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 自动推断 domain 类型为 string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归模板"><a href="#递归模板" class="headerlink" title="递归模板"></a>递归模板</h4><p>自动生成文档结构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GenerateMarkdown</span>&lt;<span class="title class_">Depth</span> <span class="keyword">extends</span> <span class="built_in">number</span>&gt; = </span><br><span class="line">  <span class="title class_">Depth</span> <span class="keyword">extends</span> <span class="number">1</span> ? <span class="string">`# <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> :</span><br><span class="line">  <span class="title class_">Depth</span> <span class="keyword">extends</span> <span class="number">2</span> ? <span class="string">`## <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> :</span><br><span class="line">  <span class="title class_">Depth</span> <span class="keyword">extends</span> <span class="number">3</span> ? <span class="string">`### <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> :</span><br><span class="line">  <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> createHeading&lt;D <span class="keyword">extends</span> <span class="built_in">number</span>&gt;(<span class="attr">depth</span>: D, <span class="attr">text</span>: <span class="built_in">string</span>)</span><br><span class="line">  : <span class="title class_">GenerateMarkdown</span>&lt;D&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="string">&quot;#&quot;</span>.repeat(depth)&#125;</span> <span class="subst">$&#123;text&#125;</span>`</span> <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 = <span class="title function_">createHeading</span>(<span class="number">1</span>, <span class="string">&quot;Title&quot;</span>); <span class="comment">// &quot;# Title&quot;</span></span><br><span class="line"><span class="keyword">const</span> h3 = <span class="title function_">createHeading</span>(<span class="number">3</span>, <span class="string">&quot;Subtitle&quot;</span>); <span class="comment">// &quot;### Subtitle&quot;</span></span><br><span class="line"><span class="keyword">const</span> invalid = <span class="title function_">createHeading</span>(<span class="number">4</span>, <span class="string">&quot;Error&quot;</span>); <span class="comment">// ❌ 类型错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SQL校验"><a href="#SQL校验" class="headerlink" title="SQL校验"></a>SQL校验</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义安全查询模式</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SafeSelectQuery</span>&lt;<span class="title class_">Table</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  <span class="string">`SELECT <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> FROM <span class="subst">$&#123;Table&#125;</span> WHERE <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> = <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 执行类型安全查询</span></span><br><span class="line"><span class="keyword">function</span> query&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">sql</span>: <span class="title class_">SafeSelectQuery</span>&lt;T&gt;) &#123;</span><br><span class="line">  <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">query</span>(<span class="string">`SELECT * FROM users WHERE email = &#x27;user@example.com&#x27;`</span>); <span class="comment">// ✅</span></span><br><span class="line"><span class="title function_">query</span>(<span class="string">`DELETE FROM users`</span>); <span class="comment">// ❌ 不符合模式</span></span><br><span class="line"><span class="title function_">query</span>(<span class="string">`SELECT * FROM products WHERE id = 123`</span>); <span class="comment">// ❌ 值未加引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 扩展：带 JOIN 的复杂查询</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">JoinQuery</span> = </span><br><span class="line">  <span class="string">`SELECT <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> FROM <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> JOIN <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> ON <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span> = <span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-API-路径参数自动提取（RESTful-服务）"><a href="#5-API-路径参数自动提取（RESTful-服务）" class="headerlink" title="5. API 路径参数自动提取（RESTful 服务）"></a>5. <strong>API 路径参数自动提取（RESTful 服务）</strong></h4><p><strong>场景</strong>：自动推断路由参数类型  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义路由模式</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RoutePattern</span>&lt;<span class="title class_">Path</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = </span><br><span class="line">  <span class="title class_">Path</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Start&#125;</span>/:<span class="subst">$&#123;infer Param&#125;</span>/<span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">    ? &#123; [K <span class="keyword">in</span> <span class="title class_">Param</span>]: <span class="built_in">string</span> &#125; &amp; <span class="title class_">RoutePattern</span>&lt;<span class="string">`/<span class="subst">$&#123;Rest&#125;</span>`</span>&gt;</span><br><span class="line">    : <span class="title class_">Path</span> <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>/:<span class="subst">$&#123;infer Param&#125;</span>`</span></span><br><span class="line">      ? &#123; [K <span class="keyword">in</span> <span class="title class_">Param</span>]: <span class="built_in">string</span> &#125;</span><br><span class="line">      : &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现类型安全路由</span></span><br><span class="line"><span class="keyword">function</span> createRoute&lt;<span class="title class_">Path</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">path</span>: <span class="title class_">Path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">match</span>: <span class="function">(<span class="params"><span class="attr">url</span>: <span class="built_in">string</span></span>) =&gt;</span> url === path ? &#123;&#125; : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125; <span class="keyword">as</span> <span class="title class_">RoutePattern</span>&lt;<span class="title class_">Path</span>&gt;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> userRoute = <span class="title function_">createRoute</span>(<span class="string">&quot;/user/:id/post/:postId&quot;</span>);</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Params</span> = <span class="keyword">typeof</span> userRoute.<span class="property">params</span>;</span><br><span class="line"><span class="comment">// 自动推断为: &#123; id: string; postId: string &#125;</span></span><br><span class="line"></span><br><span class="line">userRoute.<span class="title function_">match</span>(<span class="string">&quot;/user/123/post/456&quot;</span>)?.<span class="property">params</span>.<span class="property">id</span>; <span class="comment">// ✅ &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-编译时正则表达式验证（高级模式匹配）"><a href="#6-编译时正则表达式验证（高级模式匹配）" class="headerlink" title="6. 编译时正则表达式验证（高级模式匹配）"></a>6. <strong>编译时正则表达式验证（高级模式匹配）</strong></h4><p><strong>场景</strong>：确保字符串符合复杂正则规则  </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建类型安全邮箱格式</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ValidEmail</span> = </span><br><span class="line">  <span class="string">`<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>@<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>.<span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> &amp; &#123; </span><br><span class="line">    <span class="attr">_pattern</span>: <span class="regexp">/^[^\s@]+@[^\s@]+\.[^\s@]+$/</span> </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用条件类型验证</span></span><br><span class="line"><span class="keyword">function</span> assertEmail&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(</span><br><span class="line">  <span class="attr">value</span>: T <span class="keyword">extends</span> <span class="title class_">ValidEmail</span> ? T : <span class="built_in">never</span></span><br><span class="line">): <span class="title class_">ValidEmail</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value <span class="keyword">as</span> <span class="title class_">ValidEmail</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> valid = <span class="title function_">assertEmail</span>(<span class="string">&quot;user@example.com&quot;</span>); <span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">const</span> invalid = <span class="title function_">assertEmail</span>(<span class="string">&quot;invalid-email&quot;</span>); <span class="comment">// ❌ 类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 扩展：密码强度验证</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrongPassword</span> = <span class="built_in">string</span> &amp; &#123;</span><br><span class="line">  <span class="attr">_pattern</span>: <span class="regexp">/^(?=.*[A-Z])(?=.*[!@#$%^&amp;*])(?=.&#123;8,&#125;)/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setPassword</span>(<span class="params"><span class="attr">pwd</span>: <span class="title class_">StrongPassword</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型谓词-类型收窄：in"><a href="#类型谓词-类型收窄：in" class="headerlink" title="类型谓词&#x2F;类型收窄：in"></a>类型谓词&#x2F;类型收窄：in</h3><p>允许我们在函数中编写逻辑来判断某个值是否属于特定类型，并在条件分支中缩小类型范围。</p>
<p>用于自定义类型保护，通过返回布尔值的函数来缩小类型范围，增强类型安全性</p>
<p>语法：<code>parameterName is Type</code></p>
<ul>
<li>在函数中执行运行时检查，并告诉TypeScript编译器在某个作用域内变量的具体类型。</li>
<li>自定义复杂的类型保护逻辑。</li>
</ul>
<h4 id="判断数组是否是非空"><a href="#判断数组是否是非空" class="headerlink" title="判断数组是否是非空"></a>判断数组是否是非空</h4><p>利用了元组的特性，再加上<code>in</code>关键词</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NonEmptyArray</span>&lt;T&gt; = [T, ...T[]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isNonEmptyArray&lt;T&gt;(<span class="attr">arr</span>: T[]): arr is <span class="title class_">NonEmptyArray</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span> &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">arr2</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isNonEmptyArray</span>(arr1)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;First element:&#x27;</span>, arr1[<span class="number">0</span>]); <span class="comment">// 这里arr1被识别为NonEmptyArray&lt;number&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isNonEmptyArray</span>(arr2)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;First element:&#x27;</span>, arr2[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Array is empty&#x27;</span>); <span class="comment">// 会执行这个分支</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="类型谓词工厂"><a href="#类型谓词工厂" class="headerlink" title="类型谓词工厂"></a>类型谓词工厂</h4><p>创建可配置的类型守卫，避免重复代码</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义工厂函数</span></span><br><span class="line"><span class="keyword">function</span> isType&lt;T&gt;(<span class="attr">typeName</span>: <span class="built_in">string</span>): <span class="function">(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>) =&gt;</span> value is T &#123;</span><br><span class="line">  <span class="keyword">return</span> (value): value is T =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">`[object <span class="subst">$&#123;typeName&#125;</span>]`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建特定类型守卫</span></span><br><span class="line"><span class="keyword">const</span> isArray = isType&lt;<span class="title class_">Array</span>&lt;<span class="built_in">any</span>&gt;&gt;(<span class="string">&#x27;Array&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> isDate = isType&lt;<span class="title class_">Date</span>&gt;(<span class="string">&#x27;Date&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="built_in">unknown</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">  data.<span class="title function_">push</span>(<span class="number">4</span>) <span class="comment">// ✅ data 被识别为 any[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">input</span>: <span class="built_in">unknown</span> = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isDate</span>(input)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input.<span class="title function_">getFullYear</span>()) <span class="comment">// ✅ 识别为 Date</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="联合类型收窄（处理复杂联合类型）"><a href="#联合类型收窄（处理复杂联合类型）" class="headerlink" title="联合类型收窄（处理复杂联合类型）"></a>联合类型收窄（处理复杂联合类型）</h4><p>当联合类型成员结构相似但无公共判别属性时，使用类型谓词精确区分</p>
<p>类似于<code>switch case</code>语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义易混淆的联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = </span><br><span class="line">  | &#123; <span class="attr">success</span>: <span class="literal">true</span>; <span class="attr">data</span>: <span class="built_in">string</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">error</span>: <span class="literal">true</span>; <span class="attr">code</span>: <span class="built_in">number</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">status</span>: <span class="string">&quot;pending&quot;</span>; <span class="attr">id</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 没有公共可辨识属性，需要自定义守卫</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSuccess</span>(<span class="params"><span class="attr">result</span>: <span class="title class_">Result</span></span>): result is &#123; <span class="attr">success</span>: <span class="literal">true</span>; <span class="attr">data</span>: <span class="built_in">string</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;success&quot;</span> <span class="keyword">in</span> result &amp;&amp; result.<span class="property">success</span> === <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isError</span>(<span class="params"><span class="attr">result</span>: <span class="title class_">Result</span></span>): result is &#123; <span class="attr">error</span>: <span class="literal">true</span>; <span class="attr">code</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> <span class="keyword">in</span> result &amp;&amp; result.<span class="property">error</span> === <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params"><span class="attr">result</span>: <span class="title class_">Result</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSuccess</span>(result)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>); <span class="comment">// ✅ 收窄到成功类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isError</span>(result)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(result.<span class="property">code</span>); <span class="comment">// ✅ 收窄到错误类型</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">id</span>); <span class="comment">// ✅ 收窄到 pending 类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归类型守卫（处理嵌套数据结构）"><a href="#递归类型守卫（处理嵌套数据结构）" class="headerlink" title="递归类型守卫（处理嵌套数据结构）"></a>递归类型守卫（处理嵌套数据结构）</h4><p>验证递归结构的数据（如树形结构、嵌套对象）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义树节点类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TreeNode</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">children</span>?: <span class="title class_">TreeNode</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建递归类型守卫</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isTreeNode</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): value is <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;object&quot;</span> || value === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = value <span class="keyword">as</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">unknown</span>&gt;;</span><br><span class="line">  <span class="comment">// 检查 value 属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj.<span class="property">value</span> !== <span class="string">&quot;number&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 递归检查 children</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;children&quot;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj.<span class="property">children</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">children</span>.<span class="title function_">every</span>(isTreeNode); <span class="comment">// 递归验证每个子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="built_in">unknown</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">children</span>: [&#123; <span class="attr">value</span>: <span class="number">4</span> &#125;] &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isTreeNode</span>(data)) &#123;</span><br><span class="line">  <span class="comment">// ✅ 识别为 TreeNode 类型</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">children</span>?.[<span class="number">0</span>]?.<span class="property">value</span>); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步类型守卫（结合-Promise）"><a href="#异步类型守卫（结合-Promise）" class="headerlink" title="异步类型守卫（结合 Promise）"></a>异步类型守卫（结合 Promise）</h4><p>在异步流程中验证数据形状（如 API 响应）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义远程数据类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoteData</span> = &#123; <span class="attr">ok</span>: <span class="literal">true</span>; <span class="attr">data</span>: <span class="built_in">string</span> &#125; | &#123; <span class="attr">ok</span>: <span class="literal">false</span>; <span class="attr">error</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建异步类型守卫</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">isRemoteDataSuccess</span>(<span class="params"><span class="attr">response</span>: <span class="title class_">Promise</span>&lt;<span class="title class_">RemoteData</span>&gt;</span>)</span><br><span class="line">  : <span class="title class_">Promise</span>&lt;response is <span class="title class_">Promise</span>&lt;&#123; <span class="attr">ok</span>: <span class="literal">true</span>; <span class="attr">data</span>: <span class="built_in">string</span> &#125;&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> response;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="property">ok</span> === <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">response</span>: <span class="title class_">Promise</span>&lt;<span class="title class_">RemoteData</span>&gt; = <span class="title function_">fetchAPI</span>(); <span class="comment">// 模拟 API 调用</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">await</span> <span class="title function_">isRemoteDataSuccess</span>(response)) &#123;</span><br><span class="line">    <span class="keyword">const</span> resolved = <span class="keyword">await</span> response;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resolved.<span class="property">data</span>); <span class="comment">// ✅ 类型收窄为 &#123; ok: true; data: string &#125;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resolved = <span class="keyword">await</span> response;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(resolved.<span class="property">error</span>); <span class="comment">// ✅ 类型收窄为 &#123; ok: false; error: string &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="品牌化类型（Nominal-Typing）验证"><a href="#品牌化类型（Nominal-Typing）验证" class="headerlink" title="品牌化类型（Nominal Typing）验证"></a>品牌化类型（Nominal Typing）验证</h4><p>在结构类型系统中模拟名义类型检查（如验证 UUID 格式）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义品牌化类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">UUID</span> = <span class="built_in">string</span> &amp; &#123; <span class="keyword">readonly</span> <span class="attr">brand</span>: unique <span class="built_in">symbol</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 类型守卫验证格式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isUUID</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">string</span></span>): value is <span class="variable constant_">UUID</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> regex = <span class="regexp">/^[0-9a-f]&#123;8&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;4&#125;-[0-9a-f]&#123;12&#125;$/i</span>;</span><br><span class="line">  <span class="keyword">return</span> regex.<span class="title function_">test</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">saveId</span>(<span class="params"><span class="attr">id</span>: UUID</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">input</span>: <span class="built_in">string</span> = <span class="string">&quot;550e8400-e29b-41d4-a716-446655440000&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isUUID</span>(input)) &#123;</span><br><span class="line">  <span class="title function_">saveId</span>(input); <span class="comment">// ✅ 允许：input 被识别为 UUID</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid UUID&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类型谓词与断言函数结合"><a href="#类型谓词与断言函数结合" class="headerlink" title="类型谓词与断言函数结合"></a>类型谓词与断言函数结合</h4><ul>
<li>类型谓词（Type Predicate）：value is string <ul>
<li>返回 boolean 值，用于类型收窄</li>
</ul>
</li>
<li>断言函数（Assertion Function）：asserts value is string <ul>
<li>不返回值，而是抛出异常或继续执行</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义断言函数（类型谓词 + throw）</span></span><br><span class="line"><span class="comment">// 运行时行为：如果 condition 为 false，函数会抛出错误</span></span><br><span class="line"><span class="comment">// 编译时行为：如果函数成功返回（没有抛出错误），TypeScript 会认为 condition 为 true，并相应地缩小类型范围</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assert</span>(<span class="params"><span class="attr">condition</span>: <span class="built_in">boolean</span>, <span class="attr">msg</span>?: <span class="built_in">string</span></span>): asserts condition &#123;</span><br><span class="line">  <span class="keyword">if</span> (!condition) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 自定义类型断言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">assertString</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">unknown</span></span>): asserts value is <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="title function_">assert</span>(<span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>, <span class="string">&quot;Value must be string&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="title function_">assertString</span>(input);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input.<span class="title function_">toUpperCase</span>()); <span class="comment">// ✅ input 被识别为 string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 组合类型谓词</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validateUser</span>(<span class="params"><span class="attr">user</span>: <span class="built_in">unknown</span></span>): asserts user is &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> user === <span class="string">&quot;object&quot;</span> &amp;&amp; </span><br><span class="line">    user !== <span class="literal">null</span> &amp;&amp; </span><br><span class="line">    <span class="string">&quot;name&quot;</span> <span class="keyword">in</span> user &amp;&amp; </span><br><span class="line">    <span class="keyword">typeof</span> user.<span class="property">name</span> === <span class="string">&quot;string&quot;</span> &amp;&amp;</span><br><span class="line">    <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> user.<span class="property">age</span> === <span class="string">&quot;number&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid user&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内置高级类型"><a href="#内置高级类型" class="headerlink" title="内置高级类型"></a>内置高级类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Partial&lt;T&gt;</code></td>
<td>Partial<User></td>
<td>所有属性变为可选</td>
</tr>
<tr>
<td><code>Required&lt;T&gt;</code></td>
<td>Required<User></td>
<td>所有属性变为必选</td>
</tr>
<tr>
<td><code>Readonly&lt;T&gt;</code></td>
<td>Readonly<User></td>
<td>所有属性变为只读</td>
</tr>
<tr>
<td><code>Record&lt;K,T&gt;</code></td>
<td>Record&lt;’id’, string&gt;</td>
<td>键值映射</td>
</tr>
<tr>
<td><code>Pick&lt;T,K&gt;</code></td>
<td>Pick&lt;User, ‘name’&gt;</td>
<td>选择部分属性</td>
</tr>
<tr>
<td><code>Omit&lt;T,K&gt;</code></td>
<td>Omit&lt;User, ‘password’&gt;</td>
<td>排除部分属性</td>
</tr>
<tr>
<td><code>Exclude&lt;T,U&gt;</code></td>
<td>Exclude&lt;string</td>
<td>number, number&gt;</td>
</tr>
<tr>
<td><code>Extract&lt;T,U&gt;</code></td>
<td>Extract&lt;string</td>
<td>number, number&gt;</td>
</tr>
<tr>
<td><code>NonNullable&lt;T&gt;</code></td>
<td>NonNullable&lt;string</td>
<td>null&gt;	排除 null&#x2F;undefined</td>
</tr>
<tr>
<td><code>Parameters&lt;T&gt;</code></td>
<td>Parameters&lt;(a: string) &#x3D;&gt; void&gt;</td>
<td>获取函数参数类型元组</td>
</tr>
<tr>
<td><code>ReturnType&lt;T&gt;</code></td>
<td>ReturnType&lt;() &#x3D;&gt; number&gt;</td>
<td>获取函数返回值类型</td>
</tr>
<tr>
<td><code>ConstructorParameters&lt;T&gt;</code></td>
<td>ConstructorParameters<Error></td>
<td>获取构造函数参数类型</td>
</tr>
</tbody></table>
<h2 id="参链"><a href="#参链" class="headerlink" title="参链"></a>参链</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7511568225987346467">不是只有服务能分布，类型也能分布：解密 TypeScript 分布式条件类型</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">【TS】模块解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 11:19:41" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在文件中，如果使用 import 导入或者 export 导出，那么这个文件就会被认为是一个模块</p>
<p>如果一个文件中没有 import 或者 export，那么在里面声明的变量或者函数会被视为全局。即如果有多个文件都不包含导入导出语法，那么当这几个文件中有相同命名的变量或者函数时，就会报错</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.ts</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.ts</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">//报错:Cannot redeclare block-scoped variable &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在有 import 或者 export 时</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.ts</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">//不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="特点语法"><a href="#特点语法" class="headerlink" title="特点语法"></a>特点语法</h3><p><code>export =</code> 和 <code>import = require()</code></p>
<p>为了兼容Commonjs和Amd的exports语法，ts提供的特有语法</p>
<p>若使用 export &#x3D;导出一个模块，则必须使用 TypeScript 的特定语法 import module &#x3D; require(“module”)来导入此模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">import</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="模块解析流程"><a href="#模块解析流程" class="headerlink" title="模块解析流程"></a>模块解析流程</h2><p>分为<code>Node</code>和<code>Classic</code>，使用 <code>--moduleResolution</code>标记来指定使用哪种模块解析策略。若未指定，那么在使用了 <code>--module AMD</code> | <code>System</code> | <code>ES2015</code>时的默认值为<code>Classic</code>，其它情况时则为<code>Node</code>。</p>
<h3 id="Classic"><a href="#Classic" class="headerlink" title="Classic"></a>Classic</h3><h4 id="相对路径解析"><a href="#相对路径解析" class="headerlink" title="相对路径解析"></a>相对路径解析</h4><p>相对于导入它的文件进行解析的</p>
<p><code>/root/src/folder/A.ts</code>文件里的<code>import &#123; b &#125; from &quot;./moduleB&quot;</code></p>
<p>查找流程：</p>
<ul>
<li><p>&#x2F;root&#x2F;src&#x2F;folder&#x2F;moduleB.ts</p>
</li>
<li><p>&#x2F;root&#x2F;src&#x2F;folder&#x2F;moduleB.d.ts</p>
</li>
</ul>
<h4 id="绝对路径解析"><a href="#绝对路径解析" class="headerlink" title="绝对路径解析"></a>绝对路径解析</h4><p>从包含导入文件的目录开始<code>依次向上</code>级目录遍历</p>
<p><code>/root/src/folder/A.ts</code>文件里的<code>import &#123; b &#125; from &quot;moduleB&quot;</code></p>
<p>查找流程：</p>
<ul>
<li><code>/root/src/folder/moduleB.ts</code></li>
<li><code>/root/src/folder/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/moduleB.ts</code></li>
<li><code>/root/moduleB.d.ts</code></li>
<li><code>/moduleB.ts</code></li>
<li><code>/moduleB.d.ts</code></li>
</ul>
<h1 />

<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>ts是仿照<a target="_blank" rel="noopener" href="https://nodejs.org/api/modules.html#modules_all_together">Node</a>解析机制</p>
<h4 id="Node-大概解析方案"><a href="#Node-大概解析方案" class="headerlink" title="Node 大概解析方案"></a>Node 大概解析方案</h4><h5 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h5><p><code>/root/src/folder/A.ts</code>文件里的<code>require(&quot;./moduleB&quot;)</code></p>
<p>查找流程：</p>
<ul>
<li><p>检查<code>/root/src/moduleB.js</code>文件是否存在。</p>
</li>
<li><p>检查<code>/root/src/moduleB</code>目录是否包含一个<code>package.json</code>文件，且<code>package.json</code>文件指定了一个<code>&quot;main&quot;</code>模块。</p>
<ul>
<li>如果 Node.js 发现文件 <code>/root/src/moduleB/package.json</code>包含了<code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么 Node.js 会引用<code>/root/src/moduleB/lib/mainModule.js</code></li>
</ul>
</li>
<li><p>检查<code>/root/src/moduleB</code>目录是否包含一个<code>index.js</code>文件。 这个文件会被隐式地当作那个文件夹下的”main”模块</p>
</li>
</ul>
<h5 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h5><p><code>/root/src/folder/A.ts</code>文件里的<code>require(&quot;moduleB&quot;)</code></p>
<p>查找流程：</p>
<ul>
<li><p><code>/root/src/node_modules/moduleB.js</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB/package.json </code>(如果指定了”main”属性)</p>
</li>
<li><p><code>/root/src/node_modules/moduleB/index.js</code></p>
</li>
<li><p><code>/root/node_modules/moduleB.js</code></p>
</li>
<li><p><code>/root/node_modules/moduleB/package.json</code> (如果指定了”main”属性)</p>
</li>
<li><p><code>/root/node_modules/moduleB/index.js</code></p>
</li>
<li><p><code>/node_modules/moduleB.js</code></p>
</li>
<li><p><code>/node_modules/moduleB/package.json</code> (如果指定了”main”属性)</p>
</li>
<li><p><code>/node_modules/moduleB/index.js</code></p>
</li>
</ul>
<h4 id="TS解析"><a href="#TS解析" class="headerlink" title="TS解析"></a>TS解析</h4><p>TypeScript是模仿Node.js运行时的解析策略来在编译阶段定位模块定义文件</p>
<blockquote>
<p>不同点：</p>
</blockquote>
<ul>
<li><p>TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（ .ts，.tsx和.d.ts）</p>
</li>
<li><p>在 package.json里使用字段”types”来表示类似”main”的意义 - 编译器会使用它来找到要使用的”main”定义文件</p>
</li>
</ul>
<h5 id="相对路径-1"><a href="#相对路径-1" class="headerlink" title="相对路径"></a>相对路径</h5><p><code>/root/src/folder/A.ts</code>文件里的<code>require(&quot;./moduleB&quot;)</code></p>
<p>查找流程：</p>
<ul>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.tsx</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB/package.json</code> (如果指定了”types”属性)</li>
<li><code>/root/src/moduleB/index.ts</code></li>
<li><code>/root/src/moduleB/index.tsx</code></li>
<li><code>/root/src/moduleB/index.d.ts</code></li>
</ul>
<h5 id="绝对路径-1"><a href="#绝对路径-1" class="headerlink" title="绝对路径"></a>绝对路径</h5><p><code>/root/src/folder/A.ts</code>文件里的<code>require(&quot;moduleB&quot;)</code></p>
<ul>
<li><p><code>/root/src/node_modules/moduleB.ts</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB.tsx</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB.d.ts</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了”types”属性)</p>
</li>
<li><p><code>/root/src/node_modules/moduleB/index.ts</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB/index.tsx</code></p>
</li>
<li><p><code>/root/src/node_modules/moduleB/index.d.ts</code></p>
</li>
<li><p><code>/root/node_modules/moduleB.ts</code></p>
</li>
<li><p><code>/root/node_modules/moduleB.tsx</code></p>
</li>
<li><p><code>/root/node_modules/moduleB.d.ts</code></p>
</li>
<li><p><code>/root/node_modules/moduleB/package.json</code> (如果指定了”types”属性)</p>
</li>
<li><p><code>/root/node_modules/moduleB/index.ts</code></p>
</li>
<li><p><code>/root/node_modules/moduleB/index.tsx</code></p>
</li>
<li><p><code>/node_modules/moduleB.ts</code></p>
</li>
<li><p><code>/node_modules/moduleB.tsx</code></p>
</li>
<li><p><code>/node_modules/moduleB.d.ts</code></p>
</li>
<li><p><code>/node_modules/moduleB/package.json</code> (如果指定了”types”属性)</p>
</li>
<li><p><code>/node_modules/moduleB/index.ts</code></p>
</li>
<li><p><code>/node_modules/moduleB/index.tsx</code></p>
</li>
<li><p><code>/node_modules/moduleB/index.d.ts</code></p>
</li>
</ul>
<h3 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;packageName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;packagePath&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>paths</code>是相对于<code>baseUrl</code>进行解析</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/Typescript/%E3%80%90TS%E3%80%91%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">【TS】内置方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 11:19:34" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Typescript/" itemprop="url" rel="index"><span itemprop="name">Typescript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>?</li>
</ul>
<p>当前属性或者参数为非必传，参数有默认值时会默认转为非必传</p>
<ul>
<li>()</li>
</ul>
<p>定义函数类型时，()会作为函数参数类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> bb = &lt;<span class="variable constant_">T1</span>&gt;<span class="keyword">function</span> (<span class="params"><span class="attr">start</span>: <span class="built_in">number</span>, <span class="attr">v</span>: <span class="string">&quot;&quot;</span></span>) &#123;&#125;;</span><br><span class="line">  bb.<span class="property">interval</span> = <span class="number">0</span>;</span><br><span class="line">  bb.<span class="property">reset</span> = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = &#123;</span><br><span class="line">  (<span class="attr">start</span>: <span class="built_in">number</span>, <span class="attr">v</span>: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">interval</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">reset</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><ul>
<li><p>abstract class{}</p>
<p>抽象类，做为其它派生类的基类使用。 它们一般不会直接被实例化</p>
</li>
<li><p>abstract function</p>
<p>抽象方法不包含具体实现，并且<strong>必须</strong>在子类中实现</p>
</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错，必须要声明hello方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h3><p>属于 ts 中的 mixin，用于对多个类的类型继承</p>
<h4 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h4><ul>
<li><p>相同点</p>
<p>都可以继承父类的类型</p>
<p><code>extends</code>、<code>implements</code>和<code>abstract</code>在子类中都可以覆写父类的方法</p>
</li>
<li><p>不同点</p>
<blockquote>
<p>覆写方法</p>
</blockquote>
<p>  <code>extends</code>不是强制要求，子类可以继承父类的方法。</p>
<p>  <code>implements</code>是强制要求全部覆写父类的方法</p>
<p>  <code>abstract</code>是强制要求加了<code>abstract</code>的方法或者变量</p>
<blockquote>
<p>继承个数</p>
</blockquote>
<p>  <code>extends</code> 只能继承一个，<code>implements</code> 可以继承多个</p>
<blockquote>
<p>访问范围</p>
</blockquote>
<p>  <code>extends</code> 的子类实例可以访问到父类内容</p>
<p>  <code>implements</code> 只是定义了一个类型，即使在父类里面有方法，子类实例也不能访问，只能访问到子类自身的方法</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">a_cb</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">b_cb</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> A, B &#123;</span><br><span class="line">  <span class="title function_">a_cb</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title function_">b_cb</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="///指令"></a><code>///</code>指令</h3><p>作用：告诉编译器在编译过程中需要额外的处理</p>
<h4 id="使用类型"><a href="#使用类型" class="headerlink" title="使用类型"></a>使用类型</h4><ul>
<li><p><code>/// &lt;reference path=&quot;...&quot; /&gt;</code></p>
<ul>
<li>作用：声明文件间的依赖。告诉编译器在编译过程中需要引入的额外文件</li>
</ul>
<p>当使用<code>--out</code>或<code>--outFile</code>时，可以做为调整顺序的一种方式。</p>
<ul>
<li><p>过滤：使用<code>--noResolve</code></p>
<p>如果指定了–noResolve 编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>
</li>
<li><p><code>/// &lt;reference types=&quot;...&quot; /&gt;</code></p>
<ul>
<li><p>作用：声明了对某个包类型文件的依赖</p>
<p>例如：<code>/// &lt;reference types=&quot;node&quot; /</code>表示使用<code>@types/node/index.d.ts</code></p>
</li>
</ul>
</li>
<li><p><code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code></p>
<ul>
<li><p>作用：把文件标记为默认库</p>
</li>
<li><p>忽略：<code>--skipDefaultLibCheck</code></p>
</li>
</ul>
</li>
<li><p><code>/// &lt;amd-module name=&quot;xxx&quot;/&gt;</code></p>
<ul>
<li>作用：给编译器传入一个可选的模块名</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意点：</p>
</blockquote>
<ul>
<li><p>三斜线指令<font color=red>只能</font>可放在包含它的文件的<font color=red>最顶端</font></p>
<p>  <code>///</code>指令之前只能出现单&#x2F;多行注释或者<code>///</code>指令，如果出现在语句或者声明之后，那么就会被当做是一个注释</p>
</li>
<li><p>引用不存在的文件会报错，自身引用自身也会报错</p>
</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ul>
<li><p>Exclude&lt;T, U&gt;</p>
<p>从 T 中剔除可以赋值给 U 的类型。</p>
</li>
<li><p>Extract&lt;T, U&gt;</p>
<p>提取 T 中可以赋值给 U 的类型。</p>
</li>
<li><p>Omit&lt;T, U&gt;</p>
<p>构造一个除类型 U 中的属性外具有 T 属性的类型。</p>
</li>
<li><p>NonNullable<T></p>
<p>从 T 中剔除 null 和 undefined。</p>
</li>
<li><p>Record&lt;K, T&gt;</p>
<p>构造一个具有类型 T 的一组属性 K 的类型</p>
</li>
<li><p>Pick&lt;T, K extends keyof T&gt;</p>
<p>从 T 中选择一组键位于并集 K 中的属性</p>
</li>
</ul>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul>
<li><p>Readonly<T></p>
<p>将 T 类型属性全部变为 readonly</p>
</li>
<li><p>Partial<T></p>
<p>将 T 类型属性全部变为可选</p>
</li>
<li><p>Required<T></p>
<p>将 T 类型属性全部变为必选</p>
</li>
</ul>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><ul>
<li><p>Uppercase<T extends string></p>
<p>将字符串文字类型转换为大写</p>
</li>
<li><p>Lowercase<T extends string></p>
<p>将字符串文字类型转换为小写</p>
</li>
<li><p>Capitalize<T extends string> &#x2F; Uncapitalize<T extends string></p>
<p>将字符串文字类型的第一个字符转换为大&#x2F;小写</p>
</li>
</ul>
<h3 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h3><ul>
<li><p>Parameters&lt;T extends (…args: any) &#x3D;&gt; any&gt;</p>
<p>返回函数的参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">string</span>, b = <span class="number">2</span></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> fn1&gt;;</span><br><span class="line"><span class="comment">// T1: [a: string, b?: number]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ConstructorParameters&lt;T extends abstract new (…args: any) &#x3D;&gt; any&gt;</p>
<p>获取构造函数的参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fn1</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, b = <span class="number">2</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ConstructorParameters</span>&lt;<span class="keyword">typeof</span> fn1&gt;;</span><br><span class="line"><span class="comment">// T1: [a: number, b?: number]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ReturnType&lt;T extends (…args: any) &#x3D;&gt; any&gt;</p>
<p>获取函数返回参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> fn&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>InstanceType&lt;T extends abstract new (…args: any) &#x3D;&gt; any&gt;</p>
<p>获取构造函数函数类型的返回类型</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/React/%E3%80%90React%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/React/%E3%80%90React%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" class="post-title-link" itemprop="url">记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:06" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-25 16:31:30" itemprop="dateModified" datetime="2025-07-25T16:31:30+08:00">2025-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/react/" itemprop="url" rel="index"><span itemprop="name">react</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="useMemo-和-React-memo-优化组件的区别"><a href="#useMemo-和-React-memo-优化组件的区别" class="headerlink" title="useMemo 和 React.memo 优化组件的区别"></a>useMemo 和 React.memo 优化组件的区别</h2><p>react 中，如果父组件的状态更新了，那么也会导致子组件也会重新渲染，从头开始渲染一次子组件（若无其他优化手段的情况下</p>
<p>useMemo 和 React.memo 都可以用于缓存组件，当父组件的状态变化时，如果不涉及到其子组件对应条件修改时，对应的子组件是会重新跳过渲染的</p>
<p>React.memo 缓存的是组件渲染结果，useMemo 缓存的是计算结果。</p>
<ul>
<li><p>React.memo</p>
<p>包装组件，在 props 未变化时跳过重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 可选的自定义比较函数 */</span></span><br><span class="line">  <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 true 表示 props 相等（跳过渲染）</span></span><br><span class="line">    <span class="comment">// 返回 false 表示 props 不同（需要渲染）</span></span><br><span class="line">    <span class="keyword">return</span> prevProps.<span class="property">value</span> === nextProps.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>useMemo</p>
<p>缓存计算结果，只有当依赖项变化时才重新计算</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>,</span><br><span class="line">  [a, b] <span class="comment">// 依赖项数组</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>对比</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>React.memo</th>
<th>useMemo</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>缓存 JSX 元素</td>
<td>包装组件</td>
</tr>
<tr>
<td>类型</td>
<td>高阶组件 (HOC)</td>
<td>React Hook</td>
</tr>
<tr>
<td>作用对象</td>
<td>整个组件</td>
<td>单个值&#x2F;计算结果</td>
</tr>
<tr>
<td>优化级别</td>
<td>父组件内部优化</td>
<td>子组件自身优化</td>
</tr>
<tr>
<td>主要用途</td>
<td>防止不必要的组件重新渲染</td>
<td>避免昂贵的重复计算</td>
</tr>
<tr>
<td>触发条件</td>
<td>当 props 改变时</td>
<td>当依赖项改变时</td>
</tr>
<tr>
<td>返回值</td>
<td>记忆化组件</td>
<td>记忆化值</td>
</tr>
<tr>
<td>使用位置</td>
<td>组件定义处</td>
<td>组件内部</td>
</tr>
<tr>
<td>优化级别</td>
<td>组件级别</td>
<td>计算级别</td>
</tr>
<tr>
<td>重新执行是否状态重置</td>
<td>❌（不会导致状态重置</td>
<td>✔</td>
</tr>
<tr>
<td>影响范围</td>
<td>仅影响当前使用位置</td>
<td>影响所有使用该组件的地方</td>
</tr>
</tbody></table>
</li>
<li><p>场景推荐</p>
<ul>
<li>useMemo<ul>
<li>避免大规模组件树重复渲染</li>
<li>保持组件引用稳定</li>
<li>条件渲染优化</li>
</ul>
</li>
<li>React.memo<ul>
<li>纯展示组件优化</li>
<li>防止props未变的重新渲染</li>
<li>自定义比较逻辑</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>纯展示组件</td>
<td>React.memo</td>
<td>保持状态，响应props变化</td>
</tr>
<tr>
<td>大型列表项渲染</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>避免重复创建大量元素</td>
</tr>
<tr>
<td>需要保持内部状态的组件</td>
<td>React.memo</td>
<td>防止状态意外重置</td>
</tr>
<tr>
<td>需要稳定引用的组件（如动画）</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>确保组件引用不变</td>
</tr>
<tr>
<td>条件渲染的昂贵组件</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>避免重复挂载&#x2F;卸载开销</td>
</tr>
<tr>
<td>需要深度比较props的组件</td>
<td>React.memo + 比较函数</td>
<td>自定义比较逻辑更灵活</td>
</tr>
</tbody></table>
<p>  优化组件的创建过程时 → 使用 useMemo(() &#x3D;&gt; <Component />)</p>
<p>  想优化组件的渲染行为时 → 使用 React.memo(Component)</p>
</li>
<li><p>useMemo会导致状态重置</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 内部伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">parentFiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 首次渲染：挂载新组件</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">createFiberFromElement</span>(element);</span><br><span class="line">    parentFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新：比较新旧元素</span></span><br><span class="line">    <span class="keyword">const</span> oldFiber = parentFiber.<span class="property">alternate</span>.<span class="property">child</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldFiber.<span class="property">elementType</span> === element.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="comment">// 类型相同：复用 Fiber（保持状态）</span></span><br><span class="line">      <span class="title function_">reuseFiber</span>(oldFiber, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型不同：创建新 Fiber（重置状态）</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = <span class="title function_">createFiberFromElement</span>(element);</span><br><span class="line">      parentFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当依赖项变化时，返回的是新 React 元素</li>
<li>React 比较新旧元素时发现 element.type 相同但 element !&#x3D;&#x3D; oldFiber.element</li>
<li>React 将其视为新组件实例，创建新 Fiber 节点 → 状态重置</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/React/%E3%80%90React%E3%80%91hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/React/%E3%80%90React%E3%80%91hooks/" class="post-title-link" itemprop="url">hooks</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:06" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-29 10:50:58" itemprop="dateModified" datetime="2025-08-29T10:50:58+08:00">2025-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/react/" itemprop="url" rel="index"><span itemprop="name">react</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>缓存相关</p>
<ul>
<li>useEffect&#x2F;useLayoutEffect </li>
<li>useCallback</li>
<li>useMemo</li>
</ul>
</li>
<li><p>react相关</p>
<ul>
<li>useContext</li>
<li>useDebugValue</li>
<li>useId</li>
<li>useImperativeHandle</li>
<li>useReducer</li>
<li>useSyncExternalStore</li>
</ul>
</li>
<li><p>数据相关</p>
<ul>
<li>useDeferredValue</li>
<li>useRef</li>
<li>useState</li>
<li>useTransition</li>
</ul>
</li>
</ul>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li><p>参数：<code>useCallback(fn, dependencies)</code></p>
<ul>
<li><p><code>fn: function</code>: 缓存的函数。此函数可以接受任何参数并且返回任何值。React 将会在初次渲染而非调用时返回该函数。当进行下一次渲染时，如果 dependencies 相比于上一次渲染时没有改变，那么 React 将会返回相同的函数。否则，React 将返回在最新一次渲染中传入的函数，并且将其缓存以便之后使用。React 不会调用此函数，而是返回此函数。你可以自己决定何时调用以及是否调用。</p>
</li>
<li><p><code>dependencies: array</code>: 依赖项，当依赖项发生变化时，fn会重新执行。响应式值包括 props、state，和所有在你组件内部直接声明的变量和函数。如果你的代码检查工具 配置了 React，那么它将校验每一个正确指定为依赖的响应式值。依赖列表必须具有确切数量的项，并且必须像 [dep1, dep2, dep3] 这样编写。React 使用 <code>Object.is</code> 比较每一个依赖和它的之前的值。</p>
</li>
<li><p>返回值：<code>function</code>: 缓存的函数在初次渲染时，useCallback 返回你已经传入的 fn 函数。在之后的渲染中, 如果依赖没有改变，useCallback 返回上一次渲染中缓存的 fn 函数；否则返回这一次渲染传入的 fn。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p>返回一个 ref 对象。这个 ref 对象在组件的整个生命周期内保持不变，但是修改这个值的时候不会触发组件的更新</p>
<ul>
<li><p>与定义一个普通变量的区别是</p>
<ul>
<li>useRef：</li>
</ul>
<p>  在组件重新渲染时保持其值</p>
<p>  修改.current属性不会触发重新渲染</p>
<p>  适合存储需要在渲染间保持但不影响渲染逻辑的值</p>
<ul>
<li>普通变量：</li>
</ul>
<p>  每次组件重新渲染时都会重新初始化</p>
<p>  无法在多次渲染之间保持状态</p>
<p>  适合存储临时计算值或单次渲染所需数据</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91Service%20Worker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91Service%20Worker/" class="post-title-link" itemprop="url">【pwa】Service Worker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 11:19:54" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PWA/" itemprop="url" rel="index"><span itemprop="name">PWA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>是一个独立的worker线程，有自己的上下文，独立于当前网页的进程</p>
</li>
<li><p>安装成功后，只能手动卸载，否则将永远存在</p>
</li>
<li><p>service worker节省性能，使用时自动唤醒，不使用时自动休眠</p>
<p>属于事件驱动型Worker，Service Worker在空闲时进入空闲状态节省内存和处理器使用；当有onfetch&#x2F;onasync&#x2F;onmessage&#x2F;onpush等事件时才会激活线程</p>
</li>
<li><p>必须运行在https下或者localhost下</p>
</li>
<li><p>注册时必须是当前域名下</p>
</li>
</ul>
<h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><h3 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h3><p>对ServiceWorker线程的引用，可用于获取线程信息和向线程发送信息</p>
<h3 id="ServiceWorkerRegistration"><a href="#ServiceWorkerRegistration" class="headerlink" title="ServiceWorkerRegistration"></a>ServiceWorkerRegistration</h3><ul>
<li><p>对于ServiceWorker注册实例的引用，可用于注册同步消息，推送消息，通知等</p>
</li>
<li><p>Service Worker注册成功后的实例，可以控制共享相同源的一个或者多个页面</p>
</li>
<li><p>该对象的持久化列表由浏览器维护</p>
</li>
<li><p>ServiceWorkerContainer和ServiceWorkerGlobalScope可以通过<code>await navigator.serviceWorker.ready</code>、<code>navigator.serviceWorker.getRegistration()</code>、<code>self.registration</code>获取</p>
</li>
</ul>
<h3 id="ServiceWorkerContaine"><a href="#ServiceWorkerContaine" class="headerlink" title="ServiceWorkerContaine"></a>ServiceWorkerContaine</h3><ul>
<li><p>window环境下用于注册、注销Service Worker线程的容器</p>
</li>
<li><p>对Service Worker从注册到卸载的整个流程进行控制</p>
</li>
<li><p>通过window.navigator.serviceWorker访问Service WorkerRegistration和Service Worker接口</p>
</li>
</ul>
<h3 id="ServiceWorkerGlobalScope"><a href="#ServiceWorkerGlobalScope" class="headerlink" title="ServiceWorkerGlobalScope"></a>ServiceWorkerGlobalScope</h3><ul>
<li><p>Service Worker线程中的Context</p>
</li>
<li><p>不支持处理同步请求，只能处理异步</p>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h3><ul>
<li>parsed（解析成功）</li>
</ul>
<p> 当ServiceWorkerContainer.register执行成功后，并不意味着注册的Service Worker文件已经安装或者激活了，而是注册的Service Worker文件解析完成了，符合文件同源及https协议等</p>
<ul>
<li><p>installing（正在安装）</p>
<p>ServiceWorkerGlobalScope.oninstall事件被触发，可以在这个事件中做一些静态资源的缓存等操作</p>
</li>
<li><p>installed（安装成功）</p>
<p>ServiceWorkerGlobalScope.oninstall处理完成后，状态即为installed，此时新的Service Worker线程处于等待状态，可以手动调用self.skipWating或者重新打开页面进行激活</p>
<p>网站第一次安装时会自动触发激活</p>
</li>
<li><p>activating（正在激活）</p>
</li>
</ul>
<p> 触发ServiceWorkerGlobalScope.onactivate事件，可以在这个事件中处理一些旧版本的资源删除操作。</p>
<p> 此状态手动调用self.clients.claim()，相关页面会立刻被新的Service Worker线程控制，并触发ServiceWorkerContainer.oncontrollerchange事件</p>
<ul>
<li><p>activated（激活成功）</p>
<p>ServiceWorkerGlobalScope.onactivate事件中的处理逻辑完成后，状态变为已激活</p>
</li>
<li><p>redundant（废弃）</p>
<p>安装失败、激活失败会导致当前注册的Service Worker线程废弃。</p>
<p>新的Service Worker线程激活成功会导致旧的Service Worker线程废弃</p>
</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li><p>STARTING（正在启动）</p>
</li>
<li><p>RUNNING（正在运行）</p>
</li>
<li><p>STOPPING（正在停止）</p>
</li>
<li><p>STOPPED（已停止）</p>
</li>
</ul>
<h3 id="线程退出条件"><a href="#线程退出条件" class="headerlink" title="线程退出条件"></a>线程退出条件</h3><ul>
<li><p>Service Worker文件中存在异常情况（Js语法错误、worker安装失败&#x2F;激活失败、Service Worker线程执行时存在未捕获的异常）</p>
</li>
<li><p>Service Worker线程监听事件函数是否处理完成，变为空闲状态时，Service Worker线程会自动退出</p>
</li>
<li><p>Service Worker Js执行时间过长（js执行时间超过30s，fetch请求超过5min）</p>
</li>
<li><p>启动Service Worker线程的30s后，浏览器会周期性检查线程是否可以退出，关掉超过30s的线程</p>
</li>
</ul>
<h3 id="更新Service-Worker文件的条件"><a href="#更新Service-Worker文件的条件" class="headerlink" title="更新Service Worker文件的条件"></a>更新Service Worker文件的条件</h3><ul>
<li><p>线上运行的文件与浏览器运行的文件有一个字节不同</p>
</li>
<li><p>注册的Service Worker文件发生变化时，即使只是换了一个名字，也会认为这是一个新的文件，会触发更新</p>
</li>
<li><p>手动调用ServiceWorkerRegistration.update()时，浏览器会主动拉去新的Service Worker文件进行比对，比如发现不一致，那么会触发更新</p>
</li>
<li><p>importScripts包含进来的js文件内容发生变化时，默认情况下遵循http缓存规则，也可以通过设置updateViaCache配置不走缓存</p>
</li>
<li><p>当安装24h后，浏览器会主动无缓存地拉取相关文件进行比较</p>
</li>
</ul>
<h4 id="触发更新后"><a href="#触发更新后" class="headerlink" title="触发更新后"></a>触发更新后</h4><ul>
<li><p>更新的线程和现在的线程一起启动，并且都有自己的install事件</p>
</li>
<li><p>如果新的Service Worker线程出现不正常的状态码(4xx&#x2F;5xx)、解析失败、执行过程中发生错误等，浏览器会丢弃新的Service Worker线程，但当前的Service Worker线程仍处于活跃状态</p>
</li>
<li><p>新的Service Worker安装成功后将处于waiting状态，直到当前的Service Worker控制的client为0</p>
</li>
<li><p>可以使用self.skipWaiting()防止等待状态，将其立即激活</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91mainifest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91mainifest/" class="post-title-link" itemprop="url">【pwa】mainifest</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:06" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PWA/" itemprop="url" rel="index"><span itemprop="name">PWA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="mainifest-json"><a href="#mainifest-json" class="headerlink" title="mainifest.json"></a>mainifest.json</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>通过 manifest.json 可以实现自定义启动画面、打开 url、设置界面颜色、设置桌面图标等</p>
<h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;short_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwa1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwa-测试用例1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qr-code-fill-144.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;144x144&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/test1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;display&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standalone&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;theme_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;background_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>name: string</code></li>
</ul>
<p>描述应用的名称，会显示在桌面图标的标题位置和启动画面中</p>
<ul>
<li><p><code>short_name: string</code></p>
<p>描述应用的短名称。当应用名字过长，在桌面图标无法全部显示时，会显示 shortname</p>
</li>
<li><p><code>scope：string</code></p>
<p>设置 manifest 对于网站的作用范围。</p>
</li>
<li><p><code>start_url: string</code></p>
<p>描述用户从设备主屏幕点击图标进入时的第一个地址，start_url 必须在 scope 的作用范围内</p>
<ul>
<li><p>如果为空，则以 manifest.json 作为 url</p>
</li>
<li><p>如果 url 打开失败，则和正常显示的网页打开错误的样式一样</p>
</li>
<li><p>如果设置的 url 和当前的项目不在一个域下，无法正常显示</p>
</li>
<li><p>如果 starturl 为相对地址，那么根路径基于 manifest 的路径</p>
</li>
<li><p>如果 starturl 为绝对路径，那么根路径为将</p>
</li>
</ul>
</li>
<li><p><code>icon：TIcon</code></p>
<p>设置 webapp 图标集合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TIcon</span> = &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="built_in">string</span>; <span class="comment">//图标地址</span></span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>; <span class="comment">//图标mime类型，只能为image/png</span></span><br><span class="line">  <span class="attr">sizes</span>: <span class="built_in">string</span>; <span class="comment">//图标大小，用来表示width x height，单位为px，如果图标要适配多个尺寸，则多个尺寸用空格隔开。与真实图片大小要一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>适配规则：</p>
<ul>
<li><p>将 webapp 添加到桌面时，浏览器会适配最合适尺寸的图标。浏览器会首先去找与显示密度想匹配且尺寸调整为 48dp 屏幕密度的图标。例如在 2 倍像素的设备上使用 96px，3 倍像素的设备上使用 144px 的</p>
</li>
<li><p>如果没有找到合适的图标，那么会查找与设备特性匹配度最高的图标</p>
</li>
<li><p>如果图标路径错误，那么将显示浏览器的默认图标</p>
</li>
</ul>
</li>
<li><p><code>background_color: string</code></p>
<p>启动画面的背景颜色。rgbs、hsl、hsla 等写法浏览器不支持。未设置时，默认白色</p>
</li>
<li><p><code>theme_color: string</code></p>
<p>显示 web app 的主题色，显示在 banner 位置</p>
</li>
<li><p><code>display: &#39;fullscreen&#39;|&#39;standalone&#39;|&#39;minimal-ui&#39;|&#39;browser&#39;</code></p>
<p>webapp 被启动时显示的类型</p>
</li>
<li><p><code>orientation</code>: <code>&#39;landscape-primary&#39;|&#39;landscape-secondary&#39;|&#39;landscape&#39;|&#39;portrait-primary&#39;|&#39;portrait-secondary&#39;|&#39;portrait&#39;|&#39;natural&#39;|&#39;any&#39;</code></p>
<p>webapp 在屏幕上的显示方向</p>
</li>
<li><p><code>dir: &#39;ltr&#39;|&#39;rtl&#39;|&#39;auto&#39;</code></p>
<p>文字的显示方向</p>
</li>
<li><p><code>related_applications: &#39;platform&#39;|&#39;id&#39;</code></p>
<p>用于定义对应的原生应用，类似应用安装横幅提示的形式去推广、引流原生应用</p>
</li>
<li><p><code>prefer_related_applications: Boolean</code></p>
<p>设置是否只允许用户安装原生应用</p>
</li>
</ul>
<h2 id="生效条件"><a href="#生效条件" class="headerlink" title="生效条件"></a>生效条件</h2><ul>
<li><p>必须是 https 或者 localhost</p>
</li>
<li><p>必须注册运行 service worker，且有 fetch 事件监听</p>
</li>
<li><p>manifest 必须要有 icons,且必须要至少有尺寸为144x144的</p>
</li>
<li><p>diaplay 设置为 standalone 或者 fullscreen</p>
</li>
<li><p>必须有 name 或者 short_name，start_url</p>
</li>
<li><p>prefer_related_applications 未设置或者为 false</p>
</li>
</ul>
<h2 id="引导安装"><a href="#引导安装" class="headerlink" title="引导安装"></a>引导安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeinstallprompt&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeinstallprompt&quot;</span>);</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  e.<span class="title function_">prompt</span>();<span class="comment">//显示安装弹窗</span></span><br><span class="line">&#125;);</span><br><span class="line">navigator.<span class="property">serviceWorker</span></span><br><span class="line">  .<span class="title function_">register</span>(<span class="string">&quot;pwa1.js&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;service-pwa1注册成功&quot;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;service-pwa1注册失败&quot;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91pwa%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91pwa%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">【pwa】pwa功能模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 11:20:00" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PWA/" itemprop="url" rel="index"><span itemprop="name">PWA</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="pwa-功能模块"><a href="#pwa-功能模块" class="headerlink" title="pwa 功能模块"></a>pwa 功能模块</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>对 http 接口进行抽象，包含<code>Request</code>、<code>Response</code>、<code>Headers</code>、<code>Body</code>模块。Fetch Api 是异步化接口，所有请求接口都以<code>Promise</code>结果返回</p>
<p><code>fetch()</code>方法由<code>Content Security Policy</code>的<code>connect-src</code>指令控制，而不是他请求的资源。fetch()接收到一个错误的 http 状态码时（如 4xx、5xx），并不会标记为<code>Promise.reject</code>，而是<code>Promise.reslove</code>，但返回的 Response 接口对象的 ok 属性会被置为<code>false</code>。</p>
<p>仅在网络出现故障或者请求被浏览器取消时才会返回<code>Promise.reject</code></p>
<h1></h1>

<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Fetch Api 的 Request 接口表示资源请求，和 fetch()方法拥有相同的构造器</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = <span class="keyword">new</span> <span class="title class_">Request</span>(url, options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<blockquote>
<p><code>clone()</code>: 用于创建请求对象的副本</p>
</blockquote>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;xxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;no-cors&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>用于构造 Request 的 headers 属性，主要用于 http 请求和响应头的各种操作，可以通过 Request.headers 和 Response.headers 属性获取 Headers 对象</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<ul>
<li><p>append(name, value)</p>
<p>将新值附加到 Headers 接口对象上，主要用于为一个属性添加多个值，如果没有，则添加该字段及值</p>
</li>
<li><p>delete(name):</p>
<p>删除 Header 接口对象上的标头字段</p>
</li>
<li><p>entries():</p>
<p>返回一个包含 Header 接口对象字段和值的迭代器</p>
</li>
<li><p>forEach(callback(values, name)):</p>
<p>为 Header 接口对象的遍历器增加回调函数</p>
</li>
<li><p>get(name):</p>
<p>获取 Header 中键为 name 的值</p>
</li>
<li><p>has(name):</p>
<p>判断 Header 是否有键为 name 的</p>
</li>
<li><p>keys():</p>
<p>返回 Header 接口对象所有字段的迭代器</p>
</li>
<li><p>set(name, value):</p>
<p>为 Headers 接口对象设置字段和值</p>
</li>
<li><p>values():</p>
<p>返回 Header 接口对象所有值的迭代器</p>
</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;xxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;no-cors&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>请求响应类型为 Reponse，通过 Reponse 接口可以直接创建一个新的 Reponse 接口对象</p>
<p>Reponse 接口对象的正文信息只能使用一次，多次使用需要进行复制</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="attr">body</span>: <span class="title class_">TBody</span>, options)</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TBody</span> =</span><br><span class="line">  | <span class="string">&quot;Blob&quot;</span></span><br><span class="line">  | <span class="string">&quot;BufferSource&quot;</span></span><br><span class="line">  | <span class="string">&quot;FormData&quot;</span></span><br><span class="line">  | <span class="string">&quot;ReadableStream&quot;</span></span><br><span class="line">  | <span class="string">&quot;URLSearchParams&quot;</span></span><br><span class="line">  | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<ul>
<li><p>clone()</p>
<p>创建响应对象的副本，响应内容完全一样</p>
</li>
<li><p>error()</p>
<p>用于返回与网络错误关联的新的 Response 对象</p>
</li>
<li><p>redirect(url, status)</p>
<p>用于返回一个重定向到指定的 Url 的 Response 对象</p>
</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Response</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">data</span>: <span class="number">1</span> &#125;), &#123;</span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;&#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>由 Response 和 Request 接口对象实现，为这些接口对象提供了主体流和是否使用标志及 MIME 类型</p>
<ul>
<li><p>方法</p>
<ul>
<li><p>arrayBuffer():</p>
<p>将 Response 流读完并返回一个 ArrayBuffer 类型的 Promise 对象</p>
</li>
<li><p>blob():</p>
<p>将 Response 流读取完成并返回一个 blob 类型的 Promise 对象。当 Response.type&#x3D;opaque 时，则生成的 Blob.size&#x3D;0，Blob.type 为空，使用 URL.createObjectURL 会报错</p>
</li>
<li><p>formData():</p>
<p>将 Response 流读取完成并返回一个 FormData 类型的 Promise 对象。</p>
</li>
<li><p>json():</p>
<p>将 Response 流读取完成并返回一个 json 类型的 Promise 对象。如果 Response 流的内容不符合 json 字符串规则，报错</p>
</li>
<li><p>text():</p>
<p>将 Response 流读取完成并返回一个字符串类型的 Promise 对象，使用 UTF-8 解码</p>
</li>
</ul>
</li>
</ul>
<h1></h1>

<h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>用于配置和显示用户的桌面通知。</p>
<ul>
<li>必须在 https 或者本地域名下使用<h1></h1></li>
</ul>
<h3 id="消息展示流程"><a href="#消息展示流程" class="headerlink" title="消息展示流程"></a>消息展示流程</h3><ul>
<li><p>判断是否支持 Notification</p>
</li>
<li><p>支持的情况下判断是否授权，未授权会进行授权确认</p>
</li>
<li><p>授权成功后就可以展示通知信息</p>
<h1></h1></li>
</ul>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> not = <span class="keyword">new</span> <span class="title class_">Notification</span>(title, options);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>options:</p>
<ul>
<li><p>actions: TNotificationActions[]，表示在显示通知用户可用的操作选项</p>
<p>当用户选择这些操作项后，Service Worker 会通过 onnotificationclick 事件获取用户的选择操作，此属性只在 Service Worker 下有效。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TNotificationActions</span> = &#123;</span><br><span class="line">  <span class="attr">action</span>: <span class="built_in">string</span>; <span class="comment">//显示在通知上的action标志</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>; <span class="comment">//显示在通知上的action标题</span></span><br><span class="line">  <span class="attr">icon</span>: <span class="built_in">string</span>; <span class="comment">//显示在action上的icon Url</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>badge: 在没有足够空间显示消息时，显示 badge 设置的图片</p>
</li>
<li><p>body： 通知中显示的内容消息</p>
</li>
<li><p>data：用于消息通知的数据传递。通过 e.currentTarget.data 获取</p>
</li>
<li><p>dir：设置显示通知的方向</p>
</li>
<li><p>icon：消息通知中显示的图标的 url</p>
</li>
<li><p>lang：设置通知中的语言，必须是有效 bcp 47 语言标记</p>
</li>
<li><p>renotify：Boolean，新通知替换旧通知时是否通知用户，默认为 false，表示不会通知</p>
</li>
<li><p>requireInteraction：通知应该保持活动状态，直到用户单击或者关闭它，而不是自动关闭。必须带 tag 才有效果</p>
</li>
<li><p>silent：消息是否是静默通知</p>
</li>
<li><p>tag：给消息 tag，用于进行消息分组</p>
</li>
<li><p>timestamp：设置创建通知的时机</p>
</li>
<li><p>vibrate：收到消息通知时的震动模式。以毫秒为单位的时间数组。如[100,200,300]表示震动 100ms，暂停 200ms，然后震动 300ms</p>
</li>
</ul>
</li>
</ul>
<h1></h1>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ready&quot;</span>);</span><br><span class="line">  <span class="comment">//   打开授权</span></span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> not = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">body</span>: <span class="string">&quot;测试内容内容11111&quot;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&quot;qr-code-fill.png&quot;</span>,</span><br><span class="line">      <span class="attr">requireInteraction</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">swReg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ready&quot;</span>);</span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用actions属性，不能用new来创建了</span></span><br><span class="line">    swReg.<span class="title function_">showNotification</span>(<span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">body</span>: <span class="string">&quot;测试内容内容11111&quot;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&quot;qr-code-fill.png&quot;</span>,</span><br><span class="line">      <span class="attr">requireInteraction</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">actions</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">action</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&quot;傻狗&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">action</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&quot;laoto&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1></h1>

<h2 id="Sync后台同步"><a href="#Sync后台同步" class="headerlink" title="Sync后台同步"></a>Sync后台同步</h2><p>Sync Api可以在用户处理一些数据上传的操作时，无需关心网络环境，所有相关操作均会在合适的时机去完成数据同步</p>
<h3 id="SyncManager"><a href="#SyncManager" class="headerlink" title="SyncManager"></a>SyncManager</h3><ul>
<li><p>获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function"><span class="params">swReg</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">SyncManager</span> = swReg.<span class="property">sync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>register(tag)</p>
<p>注册一个Sync tag。tag值自定义，注册成功后，当网络成功时，会立即触发onsync事件</p>
</li>
<li><p>getTags()</p>
<p>获取已注册但未完成的Sync tag</p>
</li>
</ul>
<h1></h1>

<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Sync注册成功后，当前网络会立即触发onsync事件，可在该事件里处理Sync tag是否完成。此事件需要在ServiceWorkerGlobalScope中监听</p>
<h1></h1>

<h3 id="Sync流程"><a href="#Sync流程" class="headerlink" title="Sync流程"></a>Sync流程</h3><ul>
<li><p>Registered sync: 注册sync</p>
</li>
<li><p>Dispatched sync event：发出event事件</p>
</li>
<li><p>Sync completed： Sync完成</p>
</li>
</ul>
<p>Sync tag是否完成取决于SyncEvent.waitUntil中的Promise是否返回reject。如果不是reject则立即完成；如果是reject，目前chrome浏览器会最多尝试3此onsync事件的触发，每次周期间隔至少5min</p>
<h1></h1>

<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ul>
<li><p>Cache Api与其他存储的主要区别</p>
<ul>
<li><p>Cache存储虽然也是键值对进行存储，主要存储流式数据，但键是Request，值为Response。</p>
</li>
<li><p>Cache存储是异步化的</p>
</li>
</ul>
</li>
</ul>
<p>Cache主要涉及CacheStorage接口和Cache接口</p>
<h1></h1>

<h3 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a>CacheStorage</h3><ul>
<li><p>用于管理Cache接口对象</p>
</li>
<li><p>一个域名浏览器指挥创建一个CacheStorage，底层会创建相应的目录，相关的Cache会被存储在该目录下。</p>
<h1></h1></li>
</ul>
<h3 id="Cache-1"><a href="#Cache-1" class="headerlink" title="Cache"></a>Cache</h3><ul>
<li><p>键是Request，值为Response</p>
</li>
<li><p>Cache数据生成后，缓存数据会一直存在，修改删除操作需要api方法调用</p>
</li>
<li><p>Cache只能存储Get请求的Request，Cache的添加方法进行相同的请求时会覆盖之前的</p>
<h1></h1></li>
</ul>
<h3 id="opaque响应缓存问题"><a href="#opaque响应缓存问题" class="headerlink" title="opaque响应缓存问题"></a>opaque响应缓存问题</h3><p>不透明响应：采用mode:no-cors的不允许跨域的跨域请求，Response的类型为opaque</p>
<p>这类响应的status为0，body长度不可读，因此不能确认响应完整性及正确性，所以缓存下来无法查看其长度和内容</p>
<p>Chrome浏览器对这种响应做了一层数据填充，来保证不透明响应的数据安全性</p>
<h1></h1>

<h2 id="Push消息推送"><a href="#Push消息推送" class="headerlink" title="Push消息推送"></a>Push消息推送</h2><h3 id="涉及接口"><a href="#涉及接口" class="headerlink" title="涉及接口"></a>涉及接口</h3><ul>
<li><p>PushManager：推送服务器的订阅和订阅信息的获取等</p>
</li>
<li><p>PushSubscription：订阅成功后的对象，主要用于获取订阅信息</p>
</li>
<li><p>PushMessageData：push事件推送的消息对象</p>
</li>
</ul>
<h1></h1>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><h4 id="浏览器订阅"><a href="#浏览器订阅" class="headerlink" title="浏览器订阅"></a>浏览器订阅</h4><p>需要应用服务器的公钥，通过公钥和浏览器的用户通知得到授权，然后由浏览器向关联的消息推送服务器进行订阅，获取包含消息推送服务器的信息，最后将这些信息发送到应用服务器进行保存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nagigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function"><span class="params">swReg</span>=&gt;</span>&#123;</span><br><span class="line">    swReg.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">        <span class="attr">userVisibleOnly</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">applicationServerKey</span>: <span class="title function_">urlB64ToUint8Array</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">pushSub</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&quot;https://server-address&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">            <span class="attr">bdy</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pushSub.<span class="title function_">toJSON</span>())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1></h1>

<h4 id="应用服务器推送"><a href="#应用服务器推送" class="headerlink" title="应用服务器推送"></a>应用服务器推送</h4><p>应用服务器安装web push协议将消息发送到订阅信息中的消息推送服务器即可，无需关心浏览器端</p>
<h1></h1>

<h4 id="浏览器端接收"><a href="#浏览器端接收" class="headerlink" title="浏览器端接收"></a>浏览器端接收</h4><p>消息推送服务器接收到消息后会进行校验，通过后会向订阅的浏览器客户端进行消息推送。</p>
<p>此时将收到的消息通过Ntification Api进行展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;push&quot;</span>, <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = e.<span class="property">data</span>.<span class="title function_">json</span>()</span><br><span class="line">    self.<span class="property">registration</span>.<span class="title function_">showNotification</span>(data.<span class="property">title</span>, &#123;</span><br><span class="line">        <span class="attr">body</span>: data.<span class="property">body</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" class="post-title-link" itemprop="url">【JS】记录小点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:06 / Modified: 20:29:54" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:06+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Object-is、-和"><a href="#Object-is、-和" class="headerlink" title="Object.is、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;"></a>Object.is、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</h3><p>判断两个值是否相等，满足其中一项条件则返回true</p>
<ul>
<li><p>&#x3D;&#x3D; </p>
<ul>
<li><p>相同类型的数据</p>
<ul>
<li>数组&#x2F;对象： 判断引用地址是否相同</li>
<li>字符串：判断相同的字符且顺序相同</li>
<li>数字：+0和-0相等；任何一个NaN不等（两个NaN不等）；值相同相等</li>
<li>Boolean： 相同时相等</li>
<li>BigInt：值相同相等</li>
<li>Simple：引用相同符号相等</li>
</ul>
</li>
<li><p>不相同的数据类型</p>
<ul>
<li>undefined&#x2F;null：undefined和null相等，其他任意类型都不相等</li>
<li>对象：非引用类型&#x2F;symbol比较时，会先把对象通过<code>valueOf()</code>转换一下，然后再进行比较</li>
<li>boolean：如果另一个是数字，那么把布尔值转为数字，true-&gt;1，false-&gt;0</li>
<li>number和string：number转为string，转换失败导致NaN，而导致结果为false</li>
<li>number与BigInt：按数值进行比较，如果数字是+∞或者NaN，返回false</li>
<li>string与BigInt：使用与BigInt()构造函数相同的算法将string转为BigInt，然后进行比较</li>
</ul>
</li>
<li><p>document.all<br>  在比较中被视为undefined，因此<code>document.all == null</code>&#x2F;<code>document.all == undefined</code>为true</p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;&#x3D;</p>
<p>  不会进行数据格式转换</p>
<ul>
<li>数据类型不同：返回false</li>
<li>都是对象时：比较引用地址是否相同</li>
<li>null !&#x3D;&#x3D; undefined</li>
<li>NaN与任意一个都不相等，包括NaN，即NaN !&#x3D;&#x3D; NaN为true</li>
<li>数字：+0与-0相等</li>
</ul>
</li>
<li><p>Object.is</p>
<ul>
<li>都是undefined</li>
<li>都是null</li>
<li>都是true或者false</li>
<li>都是长度相同、字符相同、顺序相同的字符串</li>
<li>数据&#x2F;对象引用的是同一个地址</li>
<li>BigInt：有相同的数值</li>
<li>Symbol：引用相同的symbol值</li>
<li>都是数字且<ul>
<li>都是+0</li>
<li>都是-0</li>
<li>都是NaN</li>
<li>有相同的值且非零且不是NaN</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Object.is()与&#x3D;&#x3D;&#x3D;区别：</p>
<ul>
<li>+0和-0：Object.is()把+0和-0判断为相等，&#x3D;&#x3D;&#x3D;把-0和+0判断为不相等</li>
<li>NaN： Object.is()把NaN判断为相等，&#x3D;&#x3D;&#x3D;把NaN判断为不相等</li>
</ul>
<p>Object.is()与&#x3D;&#x3D;区别：</p>
<p>不会进行数据类型转换</p>
<h3 id="WeakMap、Map"><a href="#WeakMap、Map" class="headerlink" title="WeakMap、Map"></a>WeakMap、Map</h3><p>Map和Object类似，object的键只能是字符串或者Sysmbol，而Map的键可以是任意类型，且顺序是按照插入顺序储存和迭代的。</p>
<p>而WeakMap和Map类似，只是WeakMap的键只能是object，且其对object的引用是弱引用(当键引用不存在时，对象会被垃圾回收)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = &#123; <span class="attr">foo</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> bar = &#123; <span class="attr">bar</span>: <span class="number">2</span>&#125;</span><br><span class="line">    map.<span class="title function_">set</span>(foo, <span class="number">1</span>)</span><br><span class="line">    weakmap.<span class="title function_">set</span>(bar, <span class="number">2</span>)</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakmap)</span><br></pre></td></tr></table></figure>

<p>这里的输出结果为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>(<span class="number">1</span>) &#123;&#123;…&#125; =&gt; <span class="number">1</span>&#125;[[<span class="title class_">Entries</span>]]<span class="number">0</span>: &#123;<span class="function"><span class="params">Object</span> =&gt;</span> <span class="number">1</span>&#125;<span class="attr">key</span>: &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;<span class="attr">value</span>: 1<span class="attr">size</span>: <span class="number">1</span>[[<span class="title class_">Prototype</span>]]: <span class="title class_">Map</span></span><br><span class="line"><span class="title class_">WeakMap</span> &#123; <span class="language-xml"><span class="tag">&lt;<span class="name">items</span> <span class="attr">unknown</span>&gt;</span> &#125; </span></span><br></pre></td></tr></table></figure>

<p>因为weakmap的键bar在函数执行后没有被引用的地方，因此会被回收掉，所以在后续输出的时候，weakmap是bar这个键了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yangxin</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
