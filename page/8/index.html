<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yangxin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-React/【React】记录小点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/React/%E3%80%90React%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.419Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react/">react</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/React/%E3%80%90React%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/">记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="useMemo-和-React-memo-优化组件的区别"><a href="#useMemo-和-React-memo-优化组件的区别" class="headerlink" title="useMemo 和 React.memo 优化组件的区别"></a>useMemo 和 React.memo 优化组件的区别</h2><p>react 中，如果父组件的状态更新了，那么也会导致子组件也会重新渲染，从头开始渲染一次子组件（若无其他优化手段的情况下</p>
<p>useMemo 和 React.memo 都可以用于缓存组件，当父组件的状态变化时，如果不涉及到其子组件对应条件修改时，对应的子组件是会重新跳过渲染的</p>
<p>React.memo 缓存的是组件渲染结果，useMemo 缓存的是计算结果。</p>
<ul>
<li><p>React.memo</p>
<p>包装组件，在 props 未变化时跳过重新渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 可选的自定义比较函数 */</span></span><br><span class="line">  <span class="function">(<span class="params">prevProps, nextProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回 true 表示 props 相等（跳过渲染）</span></span><br><span class="line">    <span class="comment">// 返回 false 表示 props 不同（需要渲染）</span></span><br><span class="line">    <span class="keyword">return</span> prevProps.<span class="property">value</span> === nextProps.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>useMemo</p>
<p>缓存计算结果，只有当依赖项变化时才重新计算</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>&#123;a&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>,</span><br><span class="line">  [a, b] <span class="comment">// 依赖项数组</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>对比</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>React.memo</th>
<th>useMemo</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>缓存 JSX 元素</td>
<td>包装组件</td>
</tr>
<tr>
<td>类型</td>
<td>高阶组件 (HOC)</td>
<td>React Hook</td>
</tr>
<tr>
<td>作用对象</td>
<td>整个组件</td>
<td>单个值&#x2F;计算结果</td>
</tr>
<tr>
<td>优化级别</td>
<td>父组件内部优化</td>
<td>子组件自身优化</td>
</tr>
<tr>
<td>主要用途</td>
<td>防止不必要的组件重新渲染</td>
<td>避免昂贵的重复计算</td>
</tr>
<tr>
<td>触发条件</td>
<td>当 props 改变时</td>
<td>当依赖项改变时</td>
</tr>
<tr>
<td>返回值</td>
<td>记忆化组件</td>
<td>记忆化值</td>
</tr>
<tr>
<td>使用位置</td>
<td>组件定义处</td>
<td>组件内部</td>
</tr>
<tr>
<td>优化级别</td>
<td>组件级别</td>
<td>计算级别</td>
</tr>
<tr>
<td>重新执行是否状态重置</td>
<td>❌（不会导致状态重置</td>
<td>✔</td>
</tr>
<tr>
<td>影响范围</td>
<td>仅影响当前使用位置</td>
<td>影响所有使用该组件的地方</td>
</tr>
</tbody></table>
</li>
<li><p>场景推荐</p>
<ul>
<li>useMemo<ul>
<li>避免大规模组件树重复渲染</li>
<li>保持组件引用稳定</li>
<li>条件渲染优化</li>
</ul>
</li>
<li>React.memo<ul>
<li>纯展示组件优化</li>
<li>防止props未变的重新渲染</li>
<li>自定义比较逻辑</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>纯展示组件</td>
<td>React.memo</td>
<td>保持状态，响应props变化</td>
</tr>
<tr>
<td>大型列表项渲染</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>避免重复创建大量元素</td>
</tr>
<tr>
<td>需要保持内部状态的组件</td>
<td>React.memo</td>
<td>防止状态意外重置</td>
</tr>
<tr>
<td>需要稳定引用的组件（如动画）</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>确保组件引用不变</td>
</tr>
<tr>
<td>条件渲染的昂贵组件</td>
<td>useMemo(() &#x3D;&gt; &lt;&gt;)</td>
<td>避免重复挂载&#x2F;卸载开销</td>
</tr>
<tr>
<td>需要深度比较props的组件</td>
<td>React.memo + 比较函数</td>
<td>自定义比较逻辑更灵活</td>
</tr>
</tbody></table>
<p>  优化组件的创建过程时 → 使用 useMemo(() &#x3D;&gt; <Component />)</p>
<p>  想优化组件的渲染行为时 → 使用 React.memo(Component)</p>
</li>
<li><p>useMemo会导致状态重置</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 内部伪代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">parentFiber</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (parentFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 首次渲染：挂载新组件</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">createFiberFromElement</span>(element);</span><br><span class="line">    parentFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新：比较新旧元素</span></span><br><span class="line">    <span class="keyword">const</span> oldFiber = parentFiber.<span class="property">alternate</span>.<span class="property">child</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldFiber.<span class="property">elementType</span> === element.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="comment">// 类型相同：复用 Fiber（保持状态）</span></span><br><span class="line">      <span class="title function_">reuseFiber</span>(oldFiber, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型不同：创建新 Fiber（重置状态）</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = <span class="title function_">createFiberFromElement</span>(element);</span><br><span class="line">      parentFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当依赖项变化时，返回的是新 React 元素</li>
<li>React 比较新旧元素时发现 element.type 相同但 element !&#x3D;&#x3D; oldFiber.element</li>
<li>React 将其视为新组件实例，创建新 Fiber 节点 → 状态重置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/React/%E3%80%90React%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" data-id="cmebduivv001gpwfmbezrff0l" data-title="记录" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React/【React】hooks" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/React/%E3%80%90React%E3%80%91hooks/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.413Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/react/">react</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/React/%E3%80%90React%E3%80%91hooks/">hooks</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>缓存相关</p>
<ul>
<li>useEffect&#x2F;useLayoutEffect </li>
<li>useCallback</li>
<li>useMemo</li>
</ul>
</li>
<li><p>react相关</p>
<ul>
<li>useContext</li>
<li>useDebugValue</li>
<li>useId</li>
<li>useImperativeHandle</li>
<li>useReducer</li>
<li>useSyncExternalStore</li>
</ul>
</li>
<li><p>数据相关</p>
<ul>
<li>useDeferredValue</li>
<li>useRef</li>
<li>useState</li>
<li>useTransition</li>
</ul>
</li>
</ul>
<h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li><p>参数：<code>useCallback(fn, dependencies)</code></p>
<ul>
<li><p><code>fn: function</code>: 缓存的函数。此函数可以接受任何参数并且返回任何值。React 将会在初次渲染而非调用时返回该函数。当进行下一次渲染时，如果 dependencies 相比于上一次渲染时没有改变，那么 React 将会返回相同的函数。否则，React 将返回在最新一次渲染中传入的函数，并且将其缓存以便之后使用。React 不会调用此函数，而是返回此函数。你可以自己决定何时调用以及是否调用。</p>
</li>
<li><p><code>dependencies: array</code>: 依赖项，当依赖项发生变化时，fn会重新执行。响应式值包括 props、state，和所有在你组件内部直接声明的变量和函数。如果你的代码检查工具 配置了 React，那么它将校验每一个正确指定为依赖的响应式值。依赖列表必须具有确切数量的项，并且必须像 [dep1, dep2, dep3] 这样编写。React 使用 <code>Object.is</code> 比较每一个依赖和它的之前的值。</p>
</li>
<li><p>返回值：<code>function</code>: 缓存的函数在初次渲染时，useCallback 返回你已经传入的 fn 函数。在之后的渲染中, 如果依赖没有改变，useCallback 返回上一次渲染中缓存的 fn 函数；否则返回这一次渲染传入的 fn。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/React/%E3%80%90React%E3%80%91hooks/" data-id="cmebduivt0019pwfm9qz0gh3z" data-title="hooks" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PWA/【pwa】Service Worker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91Service%20Worker/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.388Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PWA/">PWA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91Service%20Worker/">【pwa】Service Worker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>是一个独立的worker线程，有自己的上下文，独立于当前网页的进程</p>
</li>
<li><p>安装成功后，只能手动卸载，否则将永远存在</p>
</li>
<li><p>service worker节省性能，使用时自动唤醒，不使用时自动休眠</p>
<p>属于事件驱动型Worker，Service Worker在空闲时进入空闲状态节省内存和处理器使用；当有onfetch&#x2F;onasync&#x2F;onmessage&#x2F;onpush等事件时才会激活线程</p>
</li>
<li><p>必须运行在https下或者localhost下</p>
</li>
<li><p>注册时必须是当前域名下</p>
</li>
</ul>
<h2 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h2><h3 id="ServiceWorker"><a href="#ServiceWorker" class="headerlink" title="ServiceWorker"></a>ServiceWorker</h3><p>对ServiceWorker线程的引用，可用于获取线程信息和向线程发送信息</p>
<h3 id="ServiceWorkerRegistration"><a href="#ServiceWorkerRegistration" class="headerlink" title="ServiceWorkerRegistration"></a>ServiceWorkerRegistration</h3><ul>
<li><p>对于ServiceWorker注册实例的引用，可用于注册同步消息，推送消息，通知等</p>
</li>
<li><p>Service Worker注册成功后的实例，可以控制共享相同源的一个或者多个页面</p>
</li>
<li><p>该对象的持久化列表由浏览器维护</p>
</li>
<li><p>ServiceWorkerContainer和ServiceWorkerGlobalScope可以通过<code>await navigator.serviceWorker.ready</code>、<code>navigator.serviceWorker.getRegistration()</code>、<code>self.registration</code>获取</p>
</li>
</ul>
<h3 id="ServiceWorkerContaine"><a href="#ServiceWorkerContaine" class="headerlink" title="ServiceWorkerContaine"></a>ServiceWorkerContaine</h3><ul>
<li><p>window环境下用于注册、注销Service Worker线程的容器</p>
</li>
<li><p>对Service Worker从注册到卸载的整个流程进行控制</p>
</li>
<li><p>通过window.navigator.serviceWorker访问Service WorkerRegistration和Service Worker接口</p>
</li>
</ul>
<h3 id="ServiceWorkerGlobalScope"><a href="#ServiceWorkerGlobalScope" class="headerlink" title="ServiceWorkerGlobalScope"></a>ServiceWorkerGlobalScope</h3><ul>
<li><p>Service Worker线程中的Context</p>
</li>
<li><p>不支持处理同步请求，只能处理异步</p>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h3><ul>
<li>parsed（解析成功）</li>
</ul>
<p> 当ServiceWorkerContainer.register执行成功后，并不意味着注册的Service Worker文件已经安装或者激活了，而是注册的Service Worker文件解析完成了，符合文件同源及https协议等</p>
<ul>
<li><p>installing（正在安装）</p>
<p>ServiceWorkerGlobalScope.oninstall事件被触发，可以在这个事件中做一些静态资源的缓存等操作</p>
</li>
<li><p>installed（安装成功）</p>
<p>ServiceWorkerGlobalScope.oninstall处理完成后，状态即为installed，此时新的Service Worker线程处于等待状态，可以手动调用self.skipWating或者重新打开页面进行激活</p>
<p>网站第一次安装时会自动触发激活</p>
</li>
<li><p>activating（正在激活）</p>
</li>
</ul>
<p> 触发ServiceWorkerGlobalScope.onactivate事件，可以在这个事件中处理一些旧版本的资源删除操作。</p>
<p> 此状态手动调用self.clients.claim()，相关页面会立刻被新的Service Worker线程控制，并触发ServiceWorkerContainer.oncontrollerchange事件</p>
<ul>
<li><p>activated（激活成功）</p>
<p>ServiceWorkerGlobalScope.onactivate事件中的处理逻辑完成后，状态变为已激活</p>
</li>
<li><p>redundant（废弃）</p>
<p>安装失败、激活失败会导致当前注册的Service Worker线程废弃。</p>
<p>新的Service Worker线程激活成功会导致旧的Service Worker线程废弃</p>
</li>
</ul>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li><p>STARTING（正在启动）</p>
</li>
<li><p>RUNNING（正在运行）</p>
</li>
<li><p>STOPPING（正在停止）</p>
</li>
<li><p>STOPPED（已停止）</p>
</li>
</ul>
<h3 id="线程退出条件"><a href="#线程退出条件" class="headerlink" title="线程退出条件"></a>线程退出条件</h3><ul>
<li><p>Service Worker文件中存在异常情况（Js语法错误、worker安装失败&#x2F;激活失败、Service Worker线程执行时存在未捕获的异常）</p>
</li>
<li><p>Service Worker线程监听事件函数是否处理完成，变为空闲状态时，Service Worker线程会自动退出</p>
</li>
<li><p>Service Worker Js执行时间过长（js执行时间超过30s，fetch请求超过5min）</p>
</li>
<li><p>启动Service Worker线程的30s后，浏览器会周期性检查线程是否可以退出，关掉超过30s的线程</p>
</li>
</ul>
<h3 id="更新Service-Worker文件的条件"><a href="#更新Service-Worker文件的条件" class="headerlink" title="更新Service Worker文件的条件"></a>更新Service Worker文件的条件</h3><ul>
<li><p>线上运行的文件与浏览器运行的文件有一个字节不同</p>
</li>
<li><p>注册的Service Worker文件发生变化时，即使只是换了一个名字，也会认为这是一个新的文件，会触发更新</p>
</li>
<li><p>手动调用ServiceWorkerRegistration.update()时，浏览器会主动拉去新的Service Worker文件进行比对，比如发现不一致，那么会触发更新</p>
</li>
<li><p>importScripts包含进来的js文件内容发生变化时，默认情况下遵循http缓存规则，也可以通过设置updateViaCache配置不走缓存</p>
</li>
<li><p>当安装24h后，浏览器会主动无缓存地拉取相关文件进行比较</p>
</li>
</ul>
<h4 id="触发更新后"><a href="#触发更新后" class="headerlink" title="触发更新后"></a>触发更新后</h4><ul>
<li><p>更新的线程和现在的线程一起启动，并且都有自己的install事件</p>
</li>
<li><p>如果新的Service Worker线程出现不正常的状态码(4xx&#x2F;5xx)、解析失败、执行过程中发生错误等，浏览器会丢弃新的Service Worker线程，但当前的Service Worker线程仍处于活跃状态</p>
</li>
<li><p>新的Service Worker安装成功后将处于waiting状态，直到当前的Service Worker控制的client为0</p>
</li>
<li><p>可以使用self.skipWaiting()防止等待状态，将其立即激活</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91Service%20Worker/" data-id="cmebduivm000upwfm9wdue43g" data-title="【pwa】Service Worker" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PWA/【pwa】mainifest" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91mainifest/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.386Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PWA/">PWA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91mainifest/">【pwa】mainifest</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mainifest-json"><a href="#mainifest-json" class="headerlink" title="mainifest.json"></a>mainifest.json</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>通过 manifest.json 可以实现自定义启动画面、打开 url、设置界面颜色、设置桌面图标等</p>
<h2 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;short_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwa1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwa-测试用例1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qr-code-fill-144.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;144x144&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;start_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/test1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;display&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standalone&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;theme_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;background_color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>name: string</code></li>
</ul>
<p>描述应用的名称，会显示在桌面图标的标题位置和启动画面中</p>
<ul>
<li><p><code>short_name: string</code></p>
<p>描述应用的短名称。当应用名字过长，在桌面图标无法全部显示时，会显示 shortname</p>
</li>
<li><p><code>scope：string</code></p>
<p>设置 manifest 对于网站的作用范围。</p>
</li>
<li><p><code>start_url: string</code></p>
<p>描述用户从设备主屏幕点击图标进入时的第一个地址，start_url 必须在 scope 的作用范围内</p>
<ul>
<li><p>如果为空，则以 manifest.json 作为 url</p>
</li>
<li><p>如果 url 打开失败，则和正常显示的网页打开错误的样式一样</p>
</li>
<li><p>如果设置的 url 和当前的项目不在一个域下，无法正常显示</p>
</li>
<li><p>如果 starturl 为相对地址，那么根路径基于 manifest 的路径</p>
</li>
<li><p>如果 starturl 为绝对路径，那么根路径为将</p>
</li>
</ul>
</li>
<li><p><code>icon：TIcon</code></p>
<p>设置 webapp 图标集合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TIcon</span> = &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="built_in">string</span>; <span class="comment">//图标地址</span></span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span>; <span class="comment">//图标mime类型，只能为image/png</span></span><br><span class="line">  <span class="attr">sizes</span>: <span class="built_in">string</span>; <span class="comment">//图标大小，用来表示width x height，单位为px，如果图标要适配多个尺寸，则多个尺寸用空格隔开。与真实图片大小要一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>适配规则：</p>
<ul>
<li><p>将 webapp 添加到桌面时，浏览器会适配最合适尺寸的图标。浏览器会首先去找与显示密度想匹配且尺寸调整为 48dp 屏幕密度的图标。例如在 2 倍像素的设备上使用 96px，3 倍像素的设备上使用 144px 的</p>
</li>
<li><p>如果没有找到合适的图标，那么会查找与设备特性匹配度最高的图标</p>
</li>
<li><p>如果图标路径错误，那么将显示浏览器的默认图标</p>
</li>
</ul>
</li>
<li><p><code>background_color: string</code></p>
<p>启动画面的背景颜色。rgbs、hsl、hsla 等写法浏览器不支持。未设置时，默认白色</p>
</li>
<li><p><code>theme_color: string</code></p>
<p>显示 web app 的主题色，显示在 banner 位置</p>
</li>
<li><p><code>display: &#39;fullscreen&#39;|&#39;standalone&#39;|&#39;minimal-ui&#39;|&#39;browser&#39;</code></p>
<p>webapp 被启动时显示的类型</p>
</li>
<li><p><code>orientation</code>: <code>&#39;landscape-primary&#39;|&#39;landscape-secondary&#39;|&#39;landscape&#39;|&#39;portrait-primary&#39;|&#39;portrait-secondary&#39;|&#39;portrait&#39;|&#39;natural&#39;|&#39;any&#39;</code></p>
<p>webapp 在屏幕上的显示方向</p>
</li>
<li><p><code>dir: &#39;ltr&#39;|&#39;rtl&#39;|&#39;auto&#39;</code></p>
<p>文字的显示方向</p>
</li>
<li><p><code>related_applications: &#39;platform&#39;|&#39;id&#39;</code></p>
<p>用于定义对应的原生应用，类似应用安装横幅提示的形式去推广、引流原生应用</p>
</li>
<li><p><code>prefer_related_applications: Boolean</code></p>
<p>设置是否只允许用户安装原生应用</p>
</li>
</ul>
<h2 id="生效条件"><a href="#生效条件" class="headerlink" title="生效条件"></a>生效条件</h2><ul>
<li><p>必须是 https 或者 localhost</p>
</li>
<li><p>必须注册运行 service worker，且有 fetch 事件监听</p>
</li>
<li><p>manifest 必须要有 icons,且必须要至少有尺寸为144x144的</p>
</li>
<li><p>diaplay 设置为 standalone 或者 fullscreen</p>
</li>
<li><p>必须有 name 或者 short_name，start_url</p>
</li>
<li><p>prefer_related_applications 未设置或者为 false</p>
</li>
</ul>
<h2 id="引导安装"><a href="#引导安装" class="headerlink" title="引导安装"></a>引导安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeinstallprompt&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeinstallprompt&quot;</span>);</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  e.<span class="title function_">prompt</span>();<span class="comment">//显示安装弹窗</span></span><br><span class="line">&#125;);</span><br><span class="line">navigator.<span class="property">serviceWorker</span></span><br><span class="line">  .<span class="title function_">register</span>(<span class="string">&quot;pwa1.js&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;service-pwa1注册成功&quot;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;service-pwa1注册失败&quot;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91mainifest/" data-id="cmebduivq0012pwfmcmq8gwfg" data-title="【pwa】mainifest" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PWA/【pwa】pwa功能模块" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91pwa%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.386Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PWA/">PWA</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/PWA/%E3%80%90pwa%E3%80%91pwa%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/">【pwa】pwa功能模块</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="pwa-功能模块"><a href="#pwa-功能模块" class="headerlink" title="pwa 功能模块"></a>pwa 功能模块</h1><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>对 http 接口进行抽象，包含<code>Request</code>、<code>Response</code>、<code>Headers</code>、<code>Body</code>模块。Fetch Api 是异步化接口，所有请求接口都以<code>Promise</code>结果返回</p>
<p><code>fetch()</code>方法由<code>Content Security Policy</code>的<code>connect-src</code>指令控制，而不是他请求的资源。fetch()接收到一个错误的 http 状态码时（如 4xx、5xx），并不会标记为<code>Promise.reject</code>，而是<code>Promise.reslove</code>，但返回的 Response 接口对象的 ok 属性会被置为<code>false</code>。</p>
<p>仅在网络出现故障或者请求被浏览器取消时才会返回<code>Promise.reject</code></p>
<h1></h1>

<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>Fetch Api 的 Request 接口表示资源请求，和 fetch()方法拥有相同的构造器</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = <span class="keyword">new</span> <span class="title class_">Request</span>(url, options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<blockquote>
<p><code>clone()</code>: 用于创建请求对象的副本</p>
</blockquote>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;xxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;no-cors&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>用于构造 Request 的 headers 属性，主要用于 http 请求和响应头的各种操作，可以通过 Request.headers 和 Response.headers 属性获取 Headers 对象</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = <span class="keyword">new</span> <span class="title class_">Headers</span>(options);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<ul>
<li><p>append(name, value)</p>
<p>将新值附加到 Headers 接口对象上，主要用于为一个属性添加多个值，如果没有，则添加该字段及值</p>
</li>
<li><p>delete(name):</p>
<p>删除 Header 接口对象上的标头字段</p>
</li>
<li><p>entries():</p>
<p>返回一个包含 Header 接口对象字段和值的迭代器</p>
</li>
<li><p>forEach(callback(values, name)):</p>
<p>为 Header 接口对象的遍历器增加回调函数</p>
</li>
<li><p>get(name):</p>
<p>获取 Header 中键为 name 的值</p>
</li>
<li><p>has(name):</p>
<p>判断 Header 是否有键为 name 的</p>
</li>
<li><p>keys():</p>
<p>返回 Header 接口对象所有字段的迭代器</p>
</li>
<li><p>set(name, value):</p>
<p>为 Headers 接口对象设置字段和值</p>
</li>
<li><p>values():</p>
<p>返回 Header 接口对象所有值的迭代器</p>
</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;xxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;no-cors&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>请求响应类型为 Reponse，通过 Reponse 接口可以直接创建一个新的 Reponse 接口对象</p>
<p>Reponse 接口对象的正文信息只能使用一次，多次使用需要进行复制</p>
<ul>
<li><p>构造器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="attr">body</span>: <span class="title class_">TBody</span>, options)</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TBody</span> =</span><br><span class="line">  | <span class="string">&quot;Blob&quot;</span></span><br><span class="line">  | <span class="string">&quot;BufferSource&quot;</span></span><br><span class="line">  | <span class="string">&quot;FormData&quot;</span></span><br><span class="line">  | <span class="string">&quot;ReadableStream&quot;</span></span><br><span class="line">  | <span class="string">&quot;URLSearchParams&quot;</span></span><br><span class="line">  | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<ul>
<li><p>clone()</p>
<p>创建响应对象的副本，响应内容完全一样</p>
</li>
<li><p>error()</p>
<p>用于返回与网络错误关联的新的 Response 对象</p>
</li>
<li><p>redirect(url, status)</p>
<p>用于返回一个重定向到指定的 Url 的 Response 对象</p>
</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Response</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">data</span>: <span class="number">1</span> &#125;), &#123;</span><br><span class="line">  <span class="attr">headers</span>: <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123;&#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1></h1>

<h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>由 Response 和 Request 接口对象实现，为这些接口对象提供了主体流和是否使用标志及 MIME 类型</p>
<ul>
<li><p>方法</p>
<ul>
<li><p>arrayBuffer():</p>
<p>将 Response 流读完并返回一个 ArrayBuffer 类型的 Promise 对象</p>
</li>
<li><p>blob():</p>
<p>将 Response 流读取完成并返回一个 blob 类型的 Promise 对象。当 Response.type&#x3D;opaque 时，则生成的 Blob.size&#x3D;0，Blob.type 为空，使用 URL.createObjectURL 会报错</p>
</li>
<li><p>formData():</p>
<p>将 Response 流读取完成并返回一个 FormData 类型的 Promise 对象。</p>
</li>
<li><p>json():</p>
<p>将 Response 流读取完成并返回一个 json 类型的 Promise 对象。如果 Response 流的内容不符合 json 字符串规则，报错</p>
</li>
<li><p>text():</p>
<p>将 Response 流读取完成并返回一个字符串类型的 Promise 对象，使用 UTF-8 解码</p>
</li>
</ul>
</li>
</ul>
<h1></h1>

<h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>用于配置和显示用户的桌面通知。</p>
<ul>
<li>必须在 https 或者本地域名下使用<h1></h1></li>
</ul>
<h3 id="消息展示流程"><a href="#消息展示流程" class="headerlink" title="消息展示流程"></a>消息展示流程</h3><ul>
<li><p>判断是否支持 Notification</p>
</li>
<li><p>支持的情况下判断是否授权，未授权会进行授权确认</p>
</li>
<li><p>授权成功后就可以展示通知信息</p>
<h1></h1></li>
</ul>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> not = <span class="keyword">new</span> <span class="title class_">Notification</span>(title, options);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>options:</p>
<ul>
<li><p>actions: TNotificationActions[]，表示在显示通知用户可用的操作选项</p>
<p>当用户选择这些操作项后，Service Worker 会通过 onnotificationclick 事件获取用户的选择操作，此属性只在 Service Worker 下有效。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TNotificationActions</span> = &#123;</span><br><span class="line">  <span class="attr">action</span>: <span class="built_in">string</span>; <span class="comment">//显示在通知上的action标志</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>; <span class="comment">//显示在通知上的action标题</span></span><br><span class="line">  <span class="attr">icon</span>: <span class="built_in">string</span>; <span class="comment">//显示在action上的icon Url</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>badge: 在没有足够空间显示消息时，显示 badge 设置的图片</p>
</li>
<li><p>body： 通知中显示的内容消息</p>
</li>
<li><p>data：用于消息通知的数据传递。通过 e.currentTarget.data 获取</p>
</li>
<li><p>dir：设置显示通知的方向</p>
</li>
<li><p>icon：消息通知中显示的图标的 url</p>
</li>
<li><p>lang：设置通知中的语言，必须是有效 bcp 47 语言标记</p>
</li>
<li><p>renotify：Boolean，新通知替换旧通知时是否通知用户，默认为 false，表示不会通知</p>
</li>
<li><p>requireInteraction：通知应该保持活动状态，直到用户单击或者关闭它，而不是自动关闭。必须带 tag 才有效果</p>
</li>
<li><p>silent：消息是否是静默通知</p>
</li>
<li><p>tag：给消息 tag，用于进行消息分组</p>
</li>
<li><p>timestamp：设置创建通知的时机</p>
</li>
<li><p>vibrate：收到消息通知时的震动模式。以毫秒为单位的时间数组。如[100,200,300]表示震动 100ms，暂停 200ms，然后震动 300ms</p>
</li>
</ul>
</li>
</ul>
<h1></h1>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ready&quot;</span>);</span><br><span class="line">  <span class="comment">//   打开授权</span></span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> not = <span class="keyword">new</span> <span class="title class_">Notification</span>(<span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">body</span>: <span class="string">&quot;测试内容内容11111&quot;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&quot;qr-code-fill.png&quot;</span>,</span><br><span class="line">      <span class="attr">requireInteraction</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">swReg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ready&quot;</span>);</span><br><span class="line">  <span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用actions属性，不能用new来创建了</span></span><br><span class="line">    swReg.<span class="title function_">showNotification</span>(<span class="string">&quot;test&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">body</span>: <span class="string">&quot;测试内容内容11111&quot;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&quot;qr-code-fill.png&quot;</span>,</span><br><span class="line">      <span class="attr">requireInteraction</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">actions</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">action</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&quot;傻狗&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">action</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&quot;laoto&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1></h1>

<h2 id="Sync后台同步"><a href="#Sync后台同步" class="headerlink" title="Sync后台同步"></a>Sync后台同步</h2><p>Sync Api可以在用户处理一些数据上传的操作时，无需关心网络环境，所有相关操作均会在合适的时机去完成数据同步</p>
<h3 id="SyncManager"><a href="#SyncManager" class="headerlink" title="SyncManager"></a>SyncManager</h3><ul>
<li><p>获取</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function"><span class="params">swReg</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">SyncManager</span> = swReg.<span class="property">sync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>register(tag)</p>
<p>注册一个Sync tag。tag值自定义，注册成功后，当网络成功时，会立即触发onsync事件</p>
</li>
<li><p>getTags()</p>
<p>获取已注册但未完成的Sync tag</p>
</li>
</ul>
<h1></h1>

<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Sync注册成功后，当前网络会立即触发onsync事件，可在该事件里处理Sync tag是否完成。此事件需要在ServiceWorkerGlobalScope中监听</p>
<h1></h1>

<h3 id="Sync流程"><a href="#Sync流程" class="headerlink" title="Sync流程"></a>Sync流程</h3><ul>
<li><p>Registered sync: 注册sync</p>
</li>
<li><p>Dispatched sync event：发出event事件</p>
</li>
<li><p>Sync completed： Sync完成</p>
</li>
</ul>
<p>Sync tag是否完成取决于SyncEvent.waitUntil中的Promise是否返回reject。如果不是reject则立即完成；如果是reject，目前chrome浏览器会最多尝试3此onsync事件的触发，每次周期间隔至少5min</p>
<h1></h1>

<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><ul>
<li><p>Cache Api与其他存储的主要区别</p>
<ul>
<li><p>Cache存储虽然也是键值对进行存储，主要存储流式数据，但键是Request，值为Response。</p>
</li>
<li><p>Cache存储是异步化的</p>
</li>
</ul>
</li>
</ul>
<p>Cache主要涉及CacheStorage接口和Cache接口</p>
<h1></h1>

<h3 id="CacheStorage"><a href="#CacheStorage" class="headerlink" title="CacheStorage"></a>CacheStorage</h3><ul>
<li><p>用于管理Cache接口对象</p>
</li>
<li><p>一个域名浏览器指挥创建一个CacheStorage，底层会创建相应的目录，相关的Cache会被存储在该目录下。</p>
<h1></h1></li>
</ul>
<h3 id="Cache-1"><a href="#Cache-1" class="headerlink" title="Cache"></a>Cache</h3><ul>
<li><p>键是Request，值为Response</p>
</li>
<li><p>Cache数据生成后，缓存数据会一直存在，修改删除操作需要api方法调用</p>
</li>
<li><p>Cache只能存储Get请求的Request，Cache的添加方法进行相同的请求时会覆盖之前的</p>
<h1></h1></li>
</ul>
<h3 id="opaque响应缓存问题"><a href="#opaque响应缓存问题" class="headerlink" title="opaque响应缓存问题"></a>opaque响应缓存问题</h3><p>不透明响应：采用mode:no-cors的不允许跨域的跨域请求，Response的类型为opaque</p>
<p>这类响应的status为0，body长度不可读，因此不能确认响应完整性及正确性，所以缓存下来无法查看其长度和内容</p>
<p>Chrome浏览器对这种响应做了一层数据填充，来保证不透明响应的数据安全性</p>
<h1></h1>

<h2 id="Push消息推送"><a href="#Push消息推送" class="headerlink" title="Push消息推送"></a>Push消息推送</h2><h3 id="涉及接口"><a href="#涉及接口" class="headerlink" title="涉及接口"></a>涉及接口</h3><ul>
<li><p>PushManager：推送服务器的订阅和订阅信息的获取等</p>
</li>
<li><p>PushSubscription：订阅成功后的对象，主要用于获取订阅信息</p>
</li>
<li><p>PushMessageData：push事件推送的消息对象</p>
</li>
</ul>
<h1></h1>

<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><h4 id="浏览器订阅"><a href="#浏览器订阅" class="headerlink" title="浏览器订阅"></a>浏览器订阅</h4><p>需要应用服务器的公钥，通过公钥和浏览器的用户通知得到授权，然后由浏览器向关联的消息推送服务器进行订阅，获取包含消息推送服务器的信息，最后将这些信息发送到应用服务器进行保存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nagigator.<span class="property">serviceWorker</span>.<span class="property">ready</span>.<span class="title function_">then</span>(<span class="function"><span class="params">swReg</span>=&gt;</span>&#123;</span><br><span class="line">    swReg.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">        <span class="attr">userVisibleOnly</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">applicationServerKey</span>: <span class="title function_">urlB64ToUint8Array</span>(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">pushSub</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">&quot;https://server-address&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">            <span class="attr">bdy</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pushSub.<span class="title function_">toJSON</span>())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1></h1>

<h4 id="应用服务器推送"><a href="#应用服务器推送" class="headerlink" title="应用服务器推送"></a>应用服务器推送</h4><p>应用服务器安装web push协议将消息发送到订阅信息中的消息推送服务器即可，无需关心浏览器端</p>
<h1></h1>

<h4 id="浏览器端接收"><a href="#浏览器端接收" class="headerlink" title="浏览器端接收"></a>浏览器端接收</h4><p>消息推送服务器接收到消息后会进行校验，通过后会向订阅的浏览器客户端进行消息推送。</p>
<p>此时将收到的消息通过Ntification Api进行展示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;push&quot;</span>, <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = e.<span class="property">data</span>.<span class="title function_">json</span>()</span><br><span class="line">    self.<span class="property">registration</span>.<span class="title function_">showNotification</span>(data.<span class="property">title</span>, &#123;</span><br><span class="line">        <span class="attr">body</span>: data.<span class="property">body</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/PWA/%E3%80%90pwa%E3%80%91pwa%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/" data-id="cmebduivs0016pwfmg5ywcv67" data-title="【pwa】pwa功能模块" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/小点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/JavaScript/%E5%B0%8F%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.336Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/JavaScript/%E5%B0%8F%E7%82%B9/">【js】小点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="检测一个数是否是整数"><a href="#检测一个数是否是整数" class="headerlink" title="检测一个数是否是整数"></a>检测一个数是否是整数</h3><p>将这个值转为十进制，如果是整数，那么十进制后的值和原本的值是相等的；如果不是，那么就不相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(num) === num</span><br></pre></td></tr></table></figure>

<h3 id="去除字符串空格"><a href="#去除字符串空格" class="headerlink" title="去除字符串空格"></a>去除字符串空格</h3><ul>
<li><p>利用正则</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除所有空格</span></span><br><span class="line"><span class="keyword">const</span> re=<span class="regexp">/\s+/g</span>;</span><br><span class="line"><span class="comment">// 去除开头空格</span></span><br><span class="line"><span class="keyword">const</span> re=<span class="regexp">/\s+/</span>;</span><br><span class="line"><span class="comment">// 去除结尾空格</span></span><br><span class="line"><span class="keyword">const</span> re=<span class="regexp">/\s+$/</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(re,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用trim()方法去除首尾空格</p>
</li>
</ul>
<h3 id="undefined和null异同"><a href="#undefined和null异同" class="headerlink" title="undefined和null异同"></a>undefined和null异同</h3><p>相同点</p>
<ul>
<li>都表示无数据</li>
<li>boolean后都是false</li>
</ul>
<p>不同点</p>
<ul>
<li>null表示一个对象变量已经初始化,但未装入对象; undefined则是未初始化变量</li>
<li>null表示”无”的对象,转为数值后是0; undefined表示”无”原始值,转为数值后是NaN</li>
<li>null<ul>
<li>作为函数参数,表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ul>
</li>
<li>undefined<ul>
<li>变量被声明了,但没有赋值</li>
<li>调用函数时,没有传的参数时</li>
<li>函数没有返回值,默认返回undefined</li>
<li>对象没有赋值的属性</li>
</ul>
</li>
</ul>
<h3 id="先执行冒泡事件还是捕获事件"><a href="#先执行冒泡事件还是捕获事件" class="headerlink" title="先执行冒泡事件还是捕获事件"></a>先执行冒泡事件还是捕获事件</h3><p>事件顺序: 其他元素捕获阶段-&gt;本元素代码顺序-&gt;其他元素冒泡阶段</p>
<p>先执行捕获.从上往下,如果有捕获,则执行,一直向下到目标元素后,从目标元素开始向上执行冒泡元素</p>
<h3 id="查找页面zindex最大的元素"><a href="#查找页面zindex最大的元素" class="headerlink" title="查找页面zindex最大的元素"></a>查找页面zindex最大的元素</h3><ul>
<li>获取所有元素</li>
<li>使用<code>window.getComputedStyle(_DOM).zIndex</code>获取实际的zindex</li>
<li>进行查找对比</li>
</ul>
<h3 id="引入js文件"><a href="#引入js文件" class="headerlink" title="引入js文件"></a>引入js文件</h3><ul>
<li><p>html的head, body中写script标签</p>
</li>
<li><p>script的src引入外部文件</p>
</li>
<li><p>元素事件中引入</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&#x27;alert(&quot;&quot;)&#x27;</span>&gt;btn&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="获取节点方法"><a href="#获取节点方法" class="headerlink" title="获取节点方法"></a>获取节点方法</h3><p>子节点</p>
<ul>
<li>getElementById&#x2F;getElementByTagName&#x2F;querySelector…</li>
<li>childNodes获取子节点,会把换行和空格也作为子节点</li>
<li>children</li>
<li>firstChild:获取第一个子节点,可能是换行或空格</li>
<li>firstElementChild: 获取第一个真正的子节点,不包括换行或空格</li>
<li>lastChild</li>
</ul>
<p>父节点</p>
<ul>
<li>parentNode: W3C标准</li>
<li>parentElement: IE标准</li>
<li>offsetParent: 获取所有父节点</li>
</ul>
<p>兄弟节点:</p>
<ul>
<li>previousSibling&#x2F;previousElementSibling: 前者包含换行和空格</li>
<li>nextSibling&#x2F;nextEmementSibling</li>
</ul>
<h3 id="DOM节点类型"><a href="#DOM节点类型" class="headerlink" title="DOM节点类型"></a>DOM节点类型</h3><p>12种</p>
<ul>
<li><p>元素节点:nodeType&#x3D;1</p>
<p>  对应HTML标签元素, nodeName是大写的标签名,nodeValue是null</p>
</li>
<li><p>特性节点: nodeType&#x3D;2</p>
<p>  对应HTML标签的属性,只存在于元素的attributes属性中,并不是DOM树的一部分, nodeName是属性名,nodeValue是属性值</p>
</li>
<li><p>文本节点: 3</p>
<p>  text代表网页的HTML标签内容, nodeName是’#text’,nodeValue是标签内容值</p>
</li>
<li><p>CDATA节点: 4</p>
<p>  只针对基于XML的文档, nodeName是’#cdata-section’,nodeValue是CDATA区域中的内容</p>
</li>
<li><p>实体引用名称节点</p>
<p>  实体是一个声明,指定了在XML中取代内容或标记而使用的名称, nodeName是实体引用的名称,nodeValue是null</p>
</li>
<li><p>实体名称节点</p>
<p>   nodeName是实体名称,nodeValue是null</p>
</li>
<li><p>处理指令节点</p>
<p>  , nodeName是target,nodeValue是entire content excluding the target</p>
</li>
<li><p>注释节点: 8</p>
<p>  nodeName是’#comment’,nodeValue是null</p>
</li>
<li><p>文档节点&#x2F;根节点: 9</p>
<p>  nodeName是’#document’,nodeValue是null</p>
</li>
<li><p>文档类型节点</p>
<p>  包含与文档的doctype有关的所有信息, nodeName是doctype的名称,nodeValue是null</p>
</li>
<li><p>文档片段节点</p>
<p>  在文档中没有对应的标记,是一种轻量级的文档,可以包含控制节点,但不会向完整的文档占用额外的资源, nodeName是’#document-fragment’,nodeValue是null</p>
</li>
<li><p>DTD声明节点:12</p>
<p>  nodeName是符号名称,nodeValue是null</p>
</li>
</ul>
<h3 id="宿主对象-原生对象"><a href="#宿主对象-原生对象" class="headerlink" title="宿主对象,原生对象"></a>宿主对象,原生对象</h3><p>原生对象:ECMA-262把本地对象定义为”独立于宿主环境的ECMAScript实现提供的对象”</p>
<p>本地对象包括:Object,Function,Array,String,Boolean,Number,Date,RegExp,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError</p>
<p>内置对象:定义为”由ES实现提供的,独立于宿主环境的所有对象,在ES程序开始执行时出现”,这意味着开发者不需要明确实例化内置对象,它已经被实例化了</p>
<p>内置对象包括:Global和Math</p>
<p>宿主对象:网页的运行环境,即DOM和BOM</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li><p>方法调用</p>
<p>  当函数被保存为一个对象属性时,该函数是该对象的方法,this指向该对象</p>
</li>
<li><p>函数调用</p>
<p>  this指向全局</p>
</li>
<li><p>构造器调用</p>
<p>  使用new调用的函数,this将会绑定到这个新创建的对象</p>
</li>
<li><p>apply&#x2F;call</p>
<p>  this指向传入的第一个参数</p>
</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>客户端定义一个函数,然后创建script标签,src为url+?jsonp&#x3D;函数名,之后服务器会生成一个和传递过来的和函数名一样名字的参数,并把需要传递的数据当作擦书传入,然后返回给客户端,此时客户端就指向了这个服务器端返回的函数回调</p>
<p>客户端定义一个函数,然后请求,服务器返回的js内容就是调用这个函数,需要的数据都作为参数传入这个函数</p>
<p>JSONP是一种非官方跨域数据交互协议,允许在服务器端集成script标签返回给客户端,通过js回调的形式实现跨域访问</p>
<p>由于同源策略的影响,跨域会报错,但是script可以访问外部资源,可以绕过同源协议</p>
<h3 id="如何实现页面的前进后退"><a href="#如何实现页面的前进后退" class="headerlink" title="如何实现页面的前进后退"></a>如何实现页面的前进后退</h3><p>监听路由的变化事件hashchange与路由的第一次加载事件load</p>
<ul>
<li>url存在于浏览记录即为后退,后退时,把当前路由后面的浏览记录删除</li>
<li>url不存在浏览记录是前进,前进时,push在当前路由的数组中</li>
<li>url在浏览器末端是在刷新页面,不需要对路由数据做任何操作</li>
</ul>
<p>注:数组可能存在多次相同的路由,应该用key来区分相同路由的不同实例</p>
<p>用两个栈实现浏览器的前进后退功能, 使用两个栈X和Y,把首次浏览的页面依次压入栈X,当单击”后退”时,再依次从栈X中出栈,并将其放入Y中.当点击”前进”按钮时,从Y中出栈,将其放入X中.当X中无数据时,说明页面无法继续后退;当Y中无数据时,说明页面无法前进</p>
<ul>
<li>进入了多个页面a,b,c:将abc压入X栈,此时在c页面</li>
<li>后退两步,将bc从X中弹出,放入Y栈,此时在a页面</li>
<li>前进一步,将b从Y中弹出,放入X栈,此时在b页面</li>
<li>打开新页面d,将d压入X栈,此时在d页面</li>
<li>清空Y,此时无法前面或后退到c页面</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/JavaScript/%E5%B0%8F%E7%82%B9/" data-id="cmebduivo000xpwfmcfz13oli" data-title="【js】小点" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/【JS】记录小点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.336Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/">【JS】记录小点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Object-is、-和"><a href="#Object-is、-和" class="headerlink" title="Object.is、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;"></a>Object.is、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</h3><p>判断两个值是否相等，满足其中一项条件则返回true</p>
<ul>
<li><p>&#x3D;&#x3D; </p>
<ul>
<li><p>相同类型的数据</p>
<ul>
<li>数组&#x2F;对象： 判断引用地址是否相同</li>
<li>字符串：判断相同的字符且顺序相同</li>
<li>数字：+0和-0相等；任何一个NaN不等（两个NaN不等）；值相同相等</li>
<li>Boolean： 相同时相等</li>
<li>BigInt：值相同相等</li>
<li>Simple：引用相同符号相等</li>
</ul>
</li>
<li><p>不相同的数据类型</p>
<ul>
<li>undefined&#x2F;null：undefined和null相等，其他任意类型都不相等</li>
<li>对象：非引用类型&#x2F;symbol比较时，会先把对象通过<code>valueOf()</code>转换一下，然后再进行比较</li>
<li>boolean：如果另一个是数字，那么把布尔值转为数字，true-&gt;1，false-&gt;0</li>
<li>number和string：number转为string，转换失败导致NaN，而导致结果为false</li>
<li>number与BigInt：按数值进行比较，如果数字是+∞或者NaN，返回false</li>
<li>string与BigInt：使用与BigInt()构造函数相同的算法将string转为BigInt，然后进行比较</li>
</ul>
</li>
<li><p>document.all<br>  在比较中被视为undefined，因此<code>document.all == null</code>&#x2F;<code>document.all == undefined</code>为true</p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;&#x3D;</p>
<p>  不会进行数据格式转换</p>
<ul>
<li>数据类型不同：返回false</li>
<li>都是对象时：比较引用地址是否相同</li>
<li>null !&#x3D;&#x3D; undefined</li>
<li>NaN与任意一个都不相等，包括NaN，即NaN !&#x3D;&#x3D; NaN为true</li>
<li>数字：+0与-0相等</li>
</ul>
</li>
<li><p>Object.is</p>
<ul>
<li>都是undefined</li>
<li>都是null</li>
<li>都是true或者false</li>
<li>都是长度相同、字符相同、顺序相同的字符串</li>
<li>数据&#x2F;对象引用的是同一个地址</li>
<li>BigInt：有相同的数值</li>
<li>Symbol：引用相同的symbol值</li>
<li>都是数字且<ul>
<li>都是+0</li>
<li>都是-0</li>
<li>都是NaN</li>
<li>有相同的值且非零且不是NaN</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Object.is()与&#x3D;&#x3D;&#x3D;区别：</p>
<ul>
<li>+0和-0：Object.is()把+0和-0判断为相等，&#x3D;&#x3D;&#x3D;把-0和+0判断为不相等</li>
<li>NaN： Object.is()把NaN判断为相等，&#x3D;&#x3D;&#x3D;把NaN判断为不相等</li>
</ul>
<p>Object.is()与&#x3D;&#x3D;区别：</p>
<p>不会进行数据类型转换</p>
<h3 id="WeakMap、Map"><a href="#WeakMap、Map" class="headerlink" title="WeakMap、Map"></a>WeakMap、Map</h3><p>Map和Object类似，object的键只能是字符串或者Sysmbol，而Map的键可以是任意类型，且顺序是按照插入顺序储存和迭代的。</p>
<p>而WeakMap和Map类似，只是WeakMap的键只能是object，且其对object的引用是弱引用(当键引用不存在时，对象会被垃圾回收)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">const</span> weakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = &#123; <span class="attr">foo</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> bar = &#123; <span class="attr">bar</span>: <span class="number">2</span>&#125;</span><br><span class="line">    map.<span class="title function_">set</span>(foo, <span class="number">1</span>)</span><br><span class="line">    weakmap.<span class="title function_">set</span>(bar, <span class="number">2</span>)</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakmap)</span><br></pre></td></tr></table></figure>

<p>这里的输出结果为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>(<span class="number">1</span>) &#123;&#123;…&#125; =&gt; <span class="number">1</span>&#125;[[<span class="title class_">Entries</span>]]<span class="number">0</span>: &#123;<span class="function"><span class="params">Object</span> =&gt;</span> <span class="number">1</span>&#125;<span class="attr">key</span>: &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;<span class="attr">value</span>: 1<span class="attr">size</span>: <span class="number">1</span>[[<span class="title class_">Prototype</span>]]: <span class="title class_">Map</span></span><br><span class="line"><span class="title class_">WeakMap</span> &#123; <span class="language-xml"><span class="tag">&lt;<span class="name">items</span> <span class="attr">unknown</span>&gt;</span> &#125; </span></span><br></pre></td></tr></table></figure>

<p>因为weakmap的键bar在函数执行后没有被引用的地方，因此会被回收掉，所以在后续输出的时候，weakmap是bar这个键了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%82%B9/" data-id="cmebduivr0013pwfmfn4283r4" data-title="【JS】记录小点" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript/【JS】修饰器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E4%BF%AE%E9%A5%B0%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.334Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E4%BF%AE%E9%A5%B0%E5%99%A8/">【js】修饰器（Decorator）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h2><p>修饰器是 ES7 的提案，是一种用于修改类、方法或属性的语法，它可以在不修改原始代码的情况下增强其功能。修饰器可以实现横切关注点（cross-cutting concerns）的功能，例如日志记录、性能分析、缓存等。通过将这些功能与原始代码分离，我们可以更好地组织和维护代码，并实现更高的可重用性和可扩展性。</p>
<p>它的出现可以解决其下两个问题:</p>
<ul>
<li><p>不同类之间共享方法</p>
</li>
<li><p>编译期对类和方法的行为进行改变</p>
</li>
</ul>
<h2 id="类修饰器"><a href="#类修饰器" class="headerlink" title="类修饰器"></a>类修饰器</h2><p>类修饰器用于修改类的行为和属性。它可以在类定义之前应用，以修改类的构造函数或原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> originCon = target;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;log&quot;</span>, target);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">newCon</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;newCon&quot;</span>, args);</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;234&quot;</span>; <span class="comment">//修改传给class的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">originCon</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newCon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classA&quot;</span>, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// log class&#123;...&#125;</span></span><br><span class="line"><span class="keyword">const</span> objA = <span class="keyword">new</span> <span class="title function_">classA</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// new Con [&#x27;123&#x27;]</span></span><br><span class="line"><span class="comment">// classA [&#x27;234&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>访问静态属性</p>
<p>定义了一个修饰器函数 log，然后将这个修饰器应用在 classA，在使用这个修饰器的时候，就会执行修饰器函数 log。</p>
<p>但是如果需要访问类的静态属性或者方法，会直接报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classA&quot;</span>, props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">staticFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;staticFn&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">classA.<span class="title function_">staticFn</span>();</span><br><span class="line"><span class="comment">//   报错：TypeError: classA.staticFn is not a function</span></span><br></pre></td></tr></table></figure>

<p>因为 log 返回的新实例，不是原始的类，所以没有 staticFn 方法，导致报错。所以需要在修饰器函数中，将静态属性和方法进行赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> originCon = target;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(target);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">newCon</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;newCon&quot;</span>, args);</span><br><span class="line">    args[<span class="number">0</span>] = <span class="string">&quot;234&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">originCon</span>(...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于复制静态方法</span></span><br><span class="line">+  <span class="keyword">function</span> <span class="title function_">copyStatic</span>(<span class="params">originalConstructor, newConstructor</span>) &#123;</span><br><span class="line">+    <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(originalConstructor).<span class="title function_">forEach</span>(<span class="function">(<span class="params">prop</span>) =&gt;</span> &#123;</span><br><span class="line">+      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prop&quot;</span>, prop);</span><br><span class="line">+      <span class="keyword">if</span> (prop !== <span class="string">&quot;prototype&quot;</span> &amp;&amp; prop !== <span class="string">&quot;length&quot;</span> &amp;&amp; prop !== <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">+        newConstructor[prop] = originalConstructor[prop];</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;);</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="title function_">copyStatic</span>(originCon, newCon);</span><br><span class="line"><span class="keyword">return</span> newCon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">classA.<span class="title function_">staticFn</span>();</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="comment">// staticFn</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应用场景</p>
<ul>
<li><strong>日志记录</strong>：在类的方法执行前后记录日志信息。</li>
<li><strong>验证和授权</strong>：对类的方法进行验证和授权操作。</li>
<li><strong>性能分析</strong>：测量类的方法执行时间，进行性能分析。</li>
<li><strong>依赖注入</strong>：为类的构造函数注入依赖项。</li>
</ul>
</li>
</ul>
<h2 id="方法修饰器"><a href="#方法修饰器" class="headerlink" title="方法修饰器"></a>方法修饰器</h2><p>方法修饰器用于修改类的方法行为。它可以在方法定义之前应用，以修改方法的特性和行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">target, name, descriptor</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(target);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(name);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(descriptor);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;初始化调用修饰器&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...descriptor,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修饰器函数的方法&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> res = descriptor.<span class="property">value</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="keyword">return</span> res * <span class="number">100</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classA</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classA&quot;</span>, props);</span><br><span class="line">  &#125;</span><br><span class="line">  @log</span><br><span class="line">  <span class="title function_">addFn</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;调用了原始函数&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> objA = <span class="keyword">new</span> <span class="title function_">classA</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> res = objA.<span class="title function_">addFn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>, res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Object &#123; addFn, constructor: class classA &#125;</span></span><br><span class="line"><span class="comment">// addFn</span></span><br><span class="line"><span class="comment">// &#123;value: f addFn(a, b), enumerable: false, configurable: true, writable: true&#125;</span></span><br><span class="line"><span class="comment">// 初始化调用修饰器</span></span><br><span class="line"><span class="comment">// classA 123</span></span><br><span class="line"><span class="comment">// 修饰器函数的方法</span></span><br><span class="line"><span class="comment">// 调用了原始函数</span></span><br><span class="line"><span class="comment">// res 300</span></span><br></pre></td></tr></table></figure>

<p>方法修饰器函数接收三个参数，分别是<code>target</code>（类的原型或构造函数）、<code>name</code>（方法名）和<code>descriptor</code>（方法的属性描述符）。修改<code>descriptor.value</code>可以替换原有的方法</p>
<ul>
<li><p>应用场景</p>
</li>
<li><p><strong>日志记录</strong>：在方法执行前后记录日志信息。</p>
</li>
<li><p><strong>验证和授权</strong>：对方法进行验证和授权操作。</p>
</li>
<li><p><strong>性能分析</strong>：测量方法执行时间，进行性能分析。</p>
</li>
<li><p><strong>缓存</strong>：为方法添加缓存功能，提高性能。</p>
</li>
</ul>
<h2 id="属性修饰器"><a href="#属性修饰器" class="headerlink" title="属性修饰器"></a>属性修饰器</h2><p>用于修改类的属性行为。它可以在属性定义之前应用，以修改属性的特性和行为</p>
<p>虽然有很多博客说可以直接用类属性修饰器，但是个人实际使用了一下，并未成功</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">protoDec</span>(<span class="params">initVal</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target, name</span>) &#123;</span><br><span class="line">    target[name] = initVal;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">dir</span>(target);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    <span class="keyword">let</span> val = target[name];</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取值：&quot;</span>, val);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> setter = <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newVal === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;设置值：&quot;</span>, newVal);</span><br><span class="line">        val = newVal + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;设置值必须为数字&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, name, &#123;</span><br><span class="line">      <span class="attr">get</span>: getter,</span><br><span class="line">      <span class="attr">set</span>: setter,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classA</span> &#123;</span><br><span class="line">  @<span class="title function_">protoDec</span>(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">  num;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classA&quot;</span>, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> objA = <span class="keyword">new</span> <span class="title function_">classA</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;objA&quot;</span>, objA.<span class="property">num</span>);</span><br><span class="line">objA.<span class="property">num</span> = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;objA&quot;</span>, objA.<span class="property">num</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前输出：</span></span><br><span class="line"><span class="comment">// Object &#123; num: &quot;0&quot; &#125;</span></span><br><span class="line"><span class="comment">// num</span></span><br><span class="line"><span class="comment">// classA 123</span></span><br><span class="line"><span class="comment">// objA undefined</span></span><br><span class="line"><span class="comment">// objA 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预期输出：</span></span><br><span class="line"><span class="comment">// Object &#123; num: &quot;0&quot; &#125;</span></span><br><span class="line"><span class="comment">// num</span></span><br><span class="line"><span class="comment">// classA 123</span></span><br><span class="line"><span class="comment">// 获取值：0</span></span><br><span class="line"><span class="comment">// objA &quot;0&quot;</span></span><br><span class="line"><span class="comment">// 设置值：100</span></span><br><span class="line"><span class="comment">// objA 101</span></span><br></pre></td></tr></table></figure>

<h2 id="参数修饰器"><a href="#参数修饰器" class="headerlink" title="参数修饰器"></a>参数修饰器</h2><p>参数修饰器用于修改方法的参数行为。它可以在方法参数声明之前应用，以修改参数的特性和行为</p>
<p>参数装饰器只能用来<strong>监视</strong>一个方法的参数是否被传入，无法修改函数执行结果</p>
<p>参数装饰器表达式会在运行时当作函数被调用，传入下列 3 个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ul>
<p>参数装饰器的返回值会被<strong>忽略</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paramsDec</span>(<span class="params">target, name, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(target)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(name)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">classA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fn</span>(<span class="params">@paramsDec num1, @paramsDec num2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行函数&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;classA&quot;</span>, props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> objA = <span class="keyword">new</span> <span class="title function_">classA</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">objA.<span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="keyword">class</span> <span class="title class_">classA</span>,</span><br><span class="line">    <span class="attr">fn</span>: ƒ <span class="title function_">fn</span>(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line">fn</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="keyword">class</span> <span class="title class_">classA</span>,</span><br><span class="line">    <span class="attr">fn</span>: ƒ <span class="title function_">fn</span>(num1, num2)</span><br><span class="line">&#125;</span><br><span class="line">fn</span><br><span class="line"><span class="number">0</span></span><br><span class="line">classA <span class="number">123</span></span><br><span class="line">执行函数</span><br></pre></td></tr></table></figure>

<h2 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a>装饰器执行顺序</h2><p>当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ul>
<li>由上至下依次对装饰器表达式求值。</li>
<li>求值的结果会被当作函数，由下至上依次调用。</li>
</ul>
<h2 id="参链"><a href="#参链" class="headerlink" title="参链"></a>参链</h2><p><a target="_blank" rel="noopener" href="https://www.coding-time.cn/js/advance/%E8%A3%85%E9%A5%B0%E5%99%A8.html#_8-%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E5%99%A8%E5%BA%93%E5%92%8C%E5%B7%A5%E5%85%B7">JavaScript修饰器：简化代码，增强功能</a></p>
<p><a target="_blank" rel="noopener" href="https://www.tslang.cn/docs/handbook/decorators.html">装饰器</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/JavaScript/%E3%80%90JS%E3%80%91%E4%BF%AE%E9%A5%B0%E5%99%A8/" data-id="cmebduivp000ypwfm9bjlcxg4" data-title="【js】修饰器（Decorator）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP/【Htpp】header" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/HTTP/%E3%80%90Htpp%E3%80%91header/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.271Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/HTTP/%E3%80%90Htpp%E3%80%91header/">【Htpp】header</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h2><h3 id="cache-control"><a href="#cache-control" class="headerlink" title="cache-control"></a>cache-control</h3><p>控制缓存，可以接收多个参数，参数之间以“，”隔空。</p>
<blockquote>
<p>请求和响应共用</p>
</blockquote>
<ul>
<li><p>no-cache：表示强制使用最新的值而不使用缓存。请求头部包含no-cache，表示客户端不接收缓存过的响应，缓存服务器必须把客户端请求转发给源服务器；响应请求里面包含，那么缓存服务器不能对响应资源进行缓存。（协商缓存</p>
</li>
<li><p>no-store：不应该缓存当前内容，表示对应的报文中包含机密信息，不缓存</p>
</li>
<li><p>no-transform：缓存不能改变主体的媒体类型，能防止缓存服务器压缩图片资源等。</p>
</li>
<li><p>max-age：缓存有效期（以秒为单位）。请求包含时，如果缓存资源的缓存时间比指定时间数值更小时则接受缓存资源，当值为0时，缓存服务器会把请求转发给源服务器；当响应包含时，缓存服务器不再确认资源的有效期，而以max-age数值作为缓存保存时长。</p>
</li>
<li><p>s-maxage: 用于配置<strong>代理服务器</strong>的缓存，以秒为单位，优先级高于max-age，但只在代理服务器中生效，客户端依然使用max-age</p>
</li>
</ul>
<h4 id="max-age-0和no-cache"><a href="#max-age-0和no-cache" class="headerlink" title="max-age&#x3D;0和no-cache"></a>max-age&#x3D;0和no-cache</h4><ul>
<li><p><code>no-cache</code>：浏览器可以进行缓存，未定性缓存是否已经过期，禁用未经验证的缓存。但是在每次请求时，需要像服务端发送一个请求判断这次的资源是否过期。如果服务端返回304，说明资源还在有效期内，浏览器可以直接使用缓存资源；但是如果内容已经过期了，服务器会返回新的内容。比max-age&#x3D;0更严格，确保每次都需要进行验证</p>
</li>
<li><p><code>max-age=0</code>: 将缓存已经视为过期了，但允许客户端复用缓存（通过验证），需要像服务器发起请求，如果服务端返回304，那么客户端依旧使用缓存，如果是200，那么就视为需要重新获取新数据。</p>
</li>
</ul>
<p>Cache-Control: no-cache, max-age&#x3D;0是冗余写法，但是可以确保浏览器的兼容性</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>max-age&#x3D;0</th>
<th>no-cache</th>
</tr>
</thead>
<tbody><tr>
<td>缓存是否保留</td>
<td>保留，但被视为过期</td>
<td>保留，但每次使用前需要验证</td>
</tr>
<tr>
<td>验证条件</td>
<td>可能被其他条件覆盖</td>
<td>强制无条件</td>
</tr>
<tr>
<td>优先级</td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td>场景</td>
<td>希望缓存快速更新，但允许复用</td>
<td>强制要求数据一致性（如实时数据）</td>
</tr>
</tbody></table>
<blockquote>
<p>请求头部</p>
</blockquote>
<ul>
<li><p>min-fresh：要求缓存服务器指定时间内返回响应（以秒为单位）</p>
</li>
<li><p>only-if-cached：客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回值，也就是说不会向源服务器转发请求。</p>
</li>
</ul>
<blockquote>
<p>响应头部</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mK0vouYv4BwgX190fSd/article/details/89880083">must-revalidate</a>：本地缓存过期前可以使用，否则必须进行有效性校验</p>
</li>
<li><p>public：响应可能会被任何对象缓存，没有限制</p>
</li>
<li><p>private： 响应只能被特定用户缓存，不能被其他用户使用</p>
</li>
<li><p>proxy-revalidate：仅适用于共享缓存，私有缓存时忽略</p>
</li>
</ul>
<h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h3><ul>
<li><p>close: 当一方的connection为close时，表示关闭此次连接</p>
</li>
<li><p>keep-live：持久化连接</p>
</li>
</ul>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>报文创建时间</p>
<h2 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h2><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>可以设置多个值，每个值通过“，”进行分割</p>
<p>常用值：text&#x2F;html，application&#x2F;xml；q&#x3D;0.9等</p>
<p>注：q&#x3D;x，是给当前类型赋予权重，范围为0～1，可精确到小数点后3位。和MIME子类型通过“，”分割，默认权重值为1。服务器会优先返回权重较大的类型，如果权重相等，则按照从左至右的顺序处理。</p>
<h3 id="accept-charset"><a href="#accept-charset" class="headerlink" title="accept-charset"></a>accept-charset</h3><p>客户端可以处理的字符集类型，通常不需要额外设置此项，每种文件类型都有默认的值。和accept一样可以设置权重</p>
<h3 id="accept-encoding"><a href="#accept-encoding" class="headerlink" title="accept-encoding"></a>accept-encoding</h3><p>客户端可以接收的编码方式，通常这个字段值会是某种压缩算法，比如gzip等。和accept一样可以设置权重</p>
<h3 id="accept-language"><a href="#accept-language" class="headerlink" title="accept-language"></a>accept-language</h3><p>客户端可以解析的自然语言，可以一次性指定多个语言并设置权重。</p>
<h3 id="authorization"><a href="#authorization" class="headerlink" title="authorization"></a>authorization</h3><p>告知服务端认证信息。通常在收到401后，在请求头里面加入authorization：type credentials</p>
<h3 id="host（必传）"><a href="#host（必传）" class="headerlink" title="host（必传）"></a>host（必传）</h3><p>告知服务器请求资源所处的互联网主机名和端口号（不指定将使用默认端口号）。</p>
<p>必传是因为服务器在接收到请求后将请求的主机号替换为ip地址，但是如果这个ip部署了多个域名，那么服务器无法转发到对应的请求</p>
<h3 id="if-modified-since"><a href="#if-modified-since" class="headerlink" title="if-modified-since"></a>if-modified-since</h3><p>确认代理或者客户端本地资源的有效性。服务端在接受到这个值后，会与资源最近更新时间做对比，如果在字段指定的日期之后资源发生了变化，那么服务器会返回最新的资源，否则返回304</p>
<h3 id="if-none-match"><a href="#if-none-match" class="headerlink" title="if-none-match"></a>if-none-match</h3><p>用于判断本地缓存是否失效。存储的是上个响应头部的etag值。当指定的值与资源的etag值不一致时，服务器端才会处理请求</p>
<h2 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h2><h3 id="age"><a href="#age" class="headerlink" title="age"></a>age</h3><p>告知客户端服务端在多久前创建了响应，若创建该响应的是缓存服务器，age指的是缓存后响应再次发起认证到认证完成的时间。代理创建响应必须加上age字段</p>
<h3 id="etag"><a href="#etag" class="headerlink" title="etag"></a>etag</h3><p>服务端在每次更新资源后生成一个唯一对应的标识，生成算法由服务器自行决定</p>
<p>分类：</p>
<ul>
<li><p>强etag：资源发生变化就会改变</p>
</li>
<li><p>弱etag：资源发生了较大变化时才会改变。以W&#x2F;来表示</p>
</li>
</ul>
<h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>使用头部字段location可以引导请求发起方至某个与请求url位置不同的资源，一般会配合3xx进行使用</p>
<h3 id="www-authenticate"><a href="#www-authenticate" class="headerlink" title="www-authenticate"></a>www-authenticate</h3><p>告知客户端当前服务器端可接收的认证方案，然后客户端可以在authentication字段中返回对应的值</p>
<h2 id="主体头部"><a href="#主体头部" class="headerlink" title="主体头部"></a>主体头部</h2><h3 id="allow"><a href="#allow" class="headerlink" title="allow"></a>allow</h3><p>通知客户端能够支持的http请求方法。当服务端接收到不支持http请求方法时，会响应状态信息405，同时把支持的方法写入allow字段</p>
<h3 id="content-encoding"><a href="#content-encoding" class="headerlink" title="content-encoding"></a>content-encoding</h3><p>告知客户端当前响应内容的编码方式</p>
<h3 id="content-length"><a href="#content-length" class="headerlink" title="content-length"></a>content-length</h3><p>表明主体部分的大小，单位为字节</p>
<h3 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h3><p>表明响应主体内容的MIME类型</p>
<h3 id="last-modified"><a href="#last-modified" class="headerlink" title="last-modified"></a>last-modified</h3><p>资源最后的修改时间，配合缓存使用</p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p>失效日期</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/HTTP/%E3%80%90Htpp%E3%80%91header/" data-id="cmebduiva0007pwfm9ahc24fa" data-title="【Htpp】header" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP/【http】队头阻塞" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/HTTP/%E3%80%90http%E3%80%91%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T03:18:06.271Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/HTTP/%E3%80%90http%E3%80%91%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/">【Htpp】队头阻塞</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="http1队头阻塞"><a href="#http1队头阻塞" class="headerlink" title="http1队头阻塞"></a>http1队头阻塞</h2><p>除了TCP的本身限制外，http1的先进先出（FIFO）的设计导致的。即浏览器在发送了请求后，必须按照发送顺序获取到相应的响应结果。例如请求A、请求B按顺序发送，请求A需要1s响应，请求B需要0.1s响应，即使B请求响应更加快速，但是浏览器依旧需要等待A的响应才能获取到B的响应。这就是http1的队头阻塞</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><h4 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h4><ul>
<li><p>简化协议实现</p>
<p>  http1设计在早期互联网，顺序处理模型更加简单，减少协议复杂性</p>
</li>
<li><p>避免资源竞争</p>
<p>  顺序处理可以避免服务器或客户端因并发处理多个请求导致数据混乱</p>
</li>
<li><p>兼容性</p>
<p>  早期浏览器和服务器对并发有限制，因此使用FIFO是权衡之后的结果</p>
</li>
</ul>
<h4 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h4><p>请求顺序化和相应顺序化</p>
<h4 id="导致问题"><a href="#导致问题" class="headerlink" title="导致问题"></a>导致问题</h4><ul>
<li><p>队头阻塞</p>
</li>
<li><p>性能问题</p>
<p>  高并发情况下，FIFO机制会导致连接利用率低下，无法充分利用带宽</p>
</li>
</ul>
<h4 id="改进尝试"><a href="#改进尝试" class="headerlink" title="改进尝试"></a>改进尝试</h4><p>管道化：允许客户端在未接受响应是连续发送多个请求</p>
<ul>
<li><p>缺点</p>
<ul>
<li>响应必须按顺序返回</li>
<li>服务器实现复杂，且易因队头阻塞导致性能问题</li>
<li>浏览器默认禁用管道话</li>
</ul>
</li>
</ul>
<p>因此管道化实际并未解决队头阻塞问题</p>
<h2 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h2><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p>二进制分帧</p>
<p>  http2中引入了二进制分帧的概念，即将请求的参数及数据全部分解为一个一个的二进制格式帧，这样可以提升传输和解析的效率。</p>
</li>
<li><p>多路复用</p>
<p>  流是一组双向的帧序列，每个流都有一个唯一的标识符，并且可以在同一个连接中并发传输多个流，可以最大程度实现多路复用</p>
<p>  一个流可以由多个帧组成，这些帧按顺序发送，接收方根据流标识符将其重新组合为完整的请求或响应</p>
</li>
</ul>
<p>因此多个http可以同时并发传输或者交错传输，从而减少队头阻塞</p>
<h3 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h3><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>每个帧有一个固定头部（9字节），包括：</p>
<ul>
<li><p>长度：Length</p>
<p>  帧负载长度，由24位3个字节大小表示</p>
</li>
<li><p>类型：Type</p>
<p>  帧类型，说明格式及其语义，用8位1个字节表示</p>
</li>
<li><p>标志：Flags</p>
<p>  指示帧的特定属性或状态，用8位1个字节表示</p>
</li>
<li><p>流标识符：Stream Identifier</p>
<p>  表示该帧关联的流，用31为表示，上限为2^31</p>
</li>
<li><p>帧数据</p>
<p>  传输的数据内容Payload由帧类型决定</p>
</li>
<li><p>R<br>  1位保留字段，未定义，以0x0结尾</p>
</li>
</ul>
<h4 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h4><p>Pad Length：填充字节长度<br>E：标识流是否为独占，设置PRIORITY时才有值<br>Stream Dependency：流的依赖流，设置PRIORITY时才有值<br>Weight：流优先级权重，设置PRIORITY时才有值<br>Header Block Fragment：Header块片段<br>Padding：填充字节长度</p>
<ul>
<li><p>DATA帧</p>
<p>  数据帧主要存储http2数据报文，包含8位填充字节+填充字节长度（PADDED）标记位true时说明由填充字节+Data具体传输的数据</p>
</li>
<li><p>HEADER帧</p>
<p>  包含Pad Length（填充字节长度）+E（标识流是否为独占，设置PRIORITY时才有值）+Stream Dependency（流的依赖流，设置PRIORITY时才有值）+ Weight（流优先级权重，设置PRIORITY时才有值）+ Header Block Fragment（Header块片段）+ Padding（填充字节长度）</p>
</li>
<li><p>PROIRITY帧</p>
<p>  发送流的优先级，包含E+Stream Dependency+Weight</p>
</li>
<li><p>RST_STREAM帧</p>
<p>  当发送错误或取消时，用于终止一个流，包含Error Code，32位错误代码，说明错误原因</p>
</li>
<li><p>SETTINGS帧</p>
<p>  用于传达连接端点之间的配置参数，标为ACK&#x3D;0表示被对等的SETTINGS帧使用，不为0时表示FRAME_SIZE_ERROR连接错误</p>
</li>
<li><p>PUSH_PROMISE帧</p>
<p>  服务端向客户端推送的帧，客户端可以返回RST_STREAM拒绝</p>
</li>
<li><p>PING帧</p>
<p>  心跳监测，测量发送往还时间，确定连接是否正常，ACK&#x3D;0表示PING帧响应，1表示PING帧</p>
</li>
<li><p>GOAWAY帧</p>
<p>  用于关闭连接或发出错误，允许停止接受新的流并完成前面的流处理</p>
<p>  包括R+Last Stream Id + Error Code + Addictional Debug Data</p>
</li>
<li><p>WINDOW_UPDATE帧</p>
<p>  用于连接和流的流量控制</p>
</li>
<li><p>CONTINUATION帧</p>
<p>  一种持续帧，用于继续传输Header头块片段。通常Header块比较大，在HEADERS、PUSH_PROMISE、CONTINUATION帧之后继续传输</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>http2只解决了应用层的问题，但是由于其还是基于tcp的，因此tcp硬伤的队头阻塞依旧存在</p>
<p>tcp由于“可靠传输”而包含的按序到达的机制，使得http2的队头阻塞问题仍然存在</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huansky/p/14420723.html">HTTP 1.x 学习笔记 —— Web 性能权威指南</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/330300133">关于队头阻塞（Head-of-Line blocking），看这一篇就足够了</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63951768/article/details/144917352">HTTP1.1 对头阻塞和 HTTP2 中对其的解决措施</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/14/HTTP/%E3%80%90http%E3%80%91%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/" data-id="cmebduivf000ipwfmfyt0bsmk" data-title="【Htpp】队头阻塞" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTML/">HTML</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWA/">PWA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Typescript/">Typescript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/VueTest/">VueTest</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web3/">Web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/axios-%E6%BA%90%E7%A0%81/">axios 源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuex-%E6%BA%90%E7%A0%81/">vuex 源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web3/">web3</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webAssembly/">webAssembly</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webwork/">webwork</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/">业务场景</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/">扩展阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/">额外内容</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typescript/" rel="tag">Typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueTest/" rel="tag">VueTest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web3/" rel="tag">Web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/axios-%E6%BA%90%E7%A0%81/" rel="tag">axios 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/" rel="tag">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/console/" rel="tag">console</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex-%E6%BA%90%E7%A0%81/" rel="tag">vuex 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web3/" rel="tag">web3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webAssembly/" rel="tag">webAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webRTC/" rel="tag">webRTC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webwork/" rel="tag">webwork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" rel="tag">业务场景</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" rel="tag">扩展阅读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8-Performance-Chrome/" rel="tag">浏览器 Performance Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/" rel="tag">额外内容</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Typescript/" style="font-size: 12px;">Typescript</a> <a href="/tags/VueTest/" style="font-size: 10px;">VueTest</a> <a href="/tags/Web3/" style="font-size: 20px;">Web3</a> <a href="/tags/axios-%E6%BA%90%E7%A0%81/" style="font-size: 14px;">axios 源码</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/console/" style="font-size: 10px;">console</a> <a href="/tags/css/" style="font-size: 18px;">css</a> <a href="/tags/http/" style="font-size: 12px;">http</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/react/" style="font-size: 12px;">react</a> <a href="/tags/vue/" style="font-size: 12px;">vue</a> <a href="/tags/vuex-%E6%BA%90%E7%A0%81/" style="font-size: 12px;">vuex 源码</a> <a href="/tags/web3/" style="font-size: 12px;">web3</a> <a href="/tags/webAssembly/" style="font-size: 10px;">webAssembly</a> <a href="/tags/webRTC/" style="font-size: 12px;">webRTC</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/webwork/" style="font-size: 10px;">webwork</a> <a href="/tags/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/" style="font-size: 10px;">业务场景</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 12px;">小程序</a> <a href="/tags/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/" style="font-size: 12px;">扩展阅读</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 16px;">浏览器</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8-Performance-Chrome/" style="font-size: 10px;">浏览器 Performance Chrome</a> <a href="/tags/%E9%A2%9D%E5%A4%96%E5%86%85%E5%AE%B9/" style="font-size: 10px;">额外内容</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">August 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/14/%E6%89%8B%E5%86%99%E9%A2%98/">手写题</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90%E6%89%8B%E5%86%99%E3%80%91call%E3%80%81apply%E3%80%81bind/">【手写】call、apply、bind</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90wasb%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">【wasb】环境搭建</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90RN%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">【RN】环境搭建</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E3%80%90AST%E3%80%91-%E8%A7%A3%E6%9E%90attrs/">解析 attrs</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 yangxin<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>