<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="vue-router不同传参模式了解 Vue Router 的不同传参方式很重要，它们各有特点，适用于不同的场景。下面我用一个表格汇总它们的核心区别，然后详细解释：    特性维度 动态路由传参 (Dynamic Routes) Params 传参 (不显示在 URL) Query 传参 (Query Parameters)    URL 中的表现 路径的一部分 (e.g., &#x2F;user&#x2F;123)">
<meta property="og:type" content="article">
<meta property="og:title" content="记录3">
<meta property="og:url" content="http://example.com/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="vue-router不同传参模式了解 Vue Router 的不同传参方式很重要，它们各有特点，适用于不同的场景。下面我用一个表格汇总它们的核心区别，然后详细解释：    特性维度 动态路由传参 (Dynamic Routes) Params 传参 (不显示在 URL) Query 传参 (Query Parameters)    URL 中的表现 路径的一部分 (e.g., &#x2F;user&#x2F;123)">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-25T02:42:18.061Z">
<meta property="article:modified_time" content="2025-09-08T04:18:18.907Z">
<meta property="article:author" content="yangxin">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/","path":"2025/08/25/面试/【面试】汇总2/","title":"记录3"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>记录3 | Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-router%E4%B8%8D%E5%90%8C%E4%BC%A0%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">vue-router不同传参模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">路由模式区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">工作原理与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">如何编写两种模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%EF%BC%88History-%E6%A8%A1%E5%BC%8F%E5%85%B3%E9%94%AE%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">服务器配置（History 模式关键）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.4.</span> <span class="nav-text">选择模式的建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.5.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E8%88%AA%E6%A0%8F"><span class="nav-number">3.</span> <span class="nav-text">导航栏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#uniapp%E8%87%AA%E5%AE%9A%E4%B9%89tabbar"><span class="nav-number">4.</span> <span class="nav-text">uniapp自定义tabbar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue3%E8%99%9A%E6%8B%9Fdom%E5%92%8Cvue2%E8%99%9A%E6%8B%9Fdom%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">vue3虚拟dom和vue2虚拟dom算法区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-number">6.</span> <span class="nav-text">如何防止小程序支付的攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9Fdom%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="nav-number">7.</span> <span class="nav-text">虚拟dom为什么可以优化性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git%E4%B8%AD%E9%97%B4%E6%9C%89%E4%B8%80%E7%AC%94commit%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86%E5%A6%82%E4%BD%95%E5%8F%AA%E5%9B%9E%E9%80%80%E8%BF%99%E4%B8%80%E7%AC%94"><span class="nav-number">8.</span> <span class="nav-text">git中间有一笔commit不需要了如何只回退这一笔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#git-merge%E5%92%8Ccherry-pick"><span class="nav-number">9.</span> <span class="nav-text">git merge和cherry pick</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="nav-number">9.1.</span> <span class="nav-text">核心概念一句话总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"><span class="nav-number">9.2.</span> <span class="nav-text">对比表格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A4%BA%E4%BE%8B%E4%B8%8E%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">9.3.</span> <span class="nav-text">可视化示例与场景分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-1-%E4%BD%BF%E7%94%A8-git-merge"><span class="nav-number">9.3.1.</span> <span class="nav-text">场景 1: 使用 git merge</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-2-%E4%BD%BF%E7%94%A8-git-rebase"><span class="nav-number">9.3.2.</span> <span class="nav-text">场景 2: 使用 git rebase</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-3-%E4%BD%BF%E7%94%A8-git-cherry-pick"><span class="nav-number">9.3.3.</span> <span class="nav-text">场景 3: 使用 git cherry-pick</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F%E5%86%B3%E7%AD%96%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">9.4.</span> <span class="nav-text">如何选择？决策流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">9.5.</span> <span class="nav-text">黄金法则与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%81%E5%BE%AEsdk%E7%99%BB%E5%BD%95%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">企微sdk登录授权流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket%E5%92%8Cwss%E5%8D%8F%E8%AE%AE"><span class="nav-number">11.</span> <span class="nav-text">websocket和wss协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSE%E3%80%81websocket"><span class="nav-number">12.</span> <span class="nav-text">SSE、websocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">13.</span> <span class="nav-text">微前端怎么用，有什么好处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="nav-number"></span> <span class="nav-text">详细分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%EF%BC%8C%E8%B4%AD%E7%89%A9%E8%BD%A6%E9%A1%B5%E9%9D%A2%E4%BC%9A%E6%9C%89%E5%BE%88%E5%A4%9A%E5%88%97%E8%A1%A8%E4%BB%A5%E5%8F%8A%E4%BB%98%E9%92%B1%E7%9A%84%E4%B8%80%E4%B8%AA%E5%80%92%E8%AE%A1%E6%97%B6%EF%BC%8C%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8C%89%E7%85%A7%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E5%8E%BB%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E5%80%92%E8%AE%A1%E6%97%B6"><span class="nav-number">1.</span> <span class="nav-text">小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yangxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="记录3 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          记录3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-25 10:42:18" itemprop="dateCreated datePublished" datetime="2025-08-25T10:42:18+08:00">2025-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-08 12:18:18" itemprop="dateModified" datetime="2025-09-08T12:18:18+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="vue-router不同传参模式"><a href="#vue-router不同传参模式" class="headerlink" title="vue-router不同传参模式"></a>vue-router不同传参模式</h3><p>了解 Vue Router 的不同传参方式很重要，它们各有特点，适用于不同的场景。下面我用一个表格汇总它们的核心区别，然后详细解释：</p>
<table>
<thead>
<tr>
<th>特性维度</th>
<th>动态路由传参 (Dynamic Routes)</th>
<th>Params 传参 (不显示在 URL)</th>
<th>Query 传参 (Query Parameters)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL 中的表现</strong></td>
<td>路径的一部分 (e.g., <code>/user/123</code>)</td>
<td><strong>不在 URL 中显示</strong></td>
<td>查询字符串 (e.g., <code>?id=123&amp;name=zhangsan</code>)</td>
</tr>
<tr>
<td><strong>路由配置</strong></td>
<td>需在 path 中定义参数 (<code>:id</code>)</td>
<td>无需在 path 中定义参数</td>
<td>无需在 path 中定义参数</td>
</tr>
<tr>
<td><strong>跳转方式</strong></td>
<td><code>path</code> 或 <code>name</code></td>
<td>必须使用 <code>name</code></td>
<td><code>path</code> 或 <code>name</code></td>
</tr>
<tr>
<td><strong>参数传递语法</strong></td>
<td><code>path: &#39;/user/&#39; + userId</code> 或 <code>params</code></td>
<td><code>params: &#123; id: 123 &#125;</code></td>
<td><code>query: &#123; id: 123 &#125;</code></td>
</tr>
<tr>
<td><strong>参数获取语法</strong></td>
<td><code>$route.params.id</code></td>
<td><code>$route.params.id</code></td>
<td><code>$route.query.id</code></td>
</tr>
<tr>
<td><strong>页面刷新后</strong></td>
<td><strong>参数保留</strong></td>
<td><strong>参数丢失</strong></td>
<td><strong>参数保留</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源ID、必要参数</td>
<td>敏感数据、临时参数</td>
<td>筛选条件、可选参数、分享链接</td>
</tr>
</tbody></table>
<p> <strong>其他传参方式</strong><br>除了上述三种主要方式，还有：</p>
<ul>
<li><strong>通过 <code>props</code> 解耦</strong>：在路由配置中设置 <code>props: true</code>，可以将 <code>$route.params</code> 作为组件的 <strong>props</strong> 接收，让组件更独立，不直接依赖 <code>$route</code> 对象。</li>
<li>**通过路由元信息 <code>meta</code>**：可以在路由配置的 <code>meta</code> 字段中添加一些静态信息（如页面标题、权限要求），常用于全局导航守卫中进行逻辑判断。</li>
</ul>
<p><strong>如何选择传参方式</strong></p>
<p>选择哪种方式，可以根据你的具体需求来定：</p>
<ul>
<li>需要参数在<strong>页面刷新后仍然保留</strong>，或者希望参数<strong>体现在 URL 中以便分享或收藏</strong>？优先考虑 <strong>动态路由传参</strong> 或 <strong>Query 传参</strong>。</li>
<li>传递的是<strong>敏感信息</strong>（如临时令牌）或<strong>不希望参数暴露在 URL 中</strong>？可以考虑 <strong>Params 传参（不显示）</strong>，但需注意刷新会丢失。</li>
<li>参数是<strong>可选的、非必需的</strong>，比如列表的<strong>筛选、排序条件</strong>？<strong>Query 传参</strong> 很合适。</li>
<li>参数是<strong>资源的唯一标识</strong>（如用户ID、文章ID）？<strong>动态路由传参</strong> 更语义化。</li>
<li>希望组件能<strong>更独立于路由</strong>，减少对 <code>$route</code> 的依赖？试试 <strong><code>props</code> 传参</strong>。</li>
</ul>
<p> <strong>简单的使用建议</strong></p>
<ul>
<li><strong>重要且必要的参数</strong>，尤其像对象ID这类，常用<strong>动态路由传参</strong>。</li>
<li><strong>可选参数</strong>或<strong>多个参数</strong>，常用 <strong>Query 传参</strong>。</li>
<li><strong>Params传参（不显示）</strong> 需谨慎使用，注意其刷新页面参数会丢失的特性。</li>
</ul>
<p>希望这些信息能帮助你更好地选择和使用 Vue Router 的传参方式。</p>
<h3 id="路由模式区别"><a href="#路由模式区别" class="headerlink" title="路由模式区别"></a>路由模式区别</h3><p>这两个模式的核心区别在于<strong>如何模拟和操作浏览器的历史记录</strong>，从而带来了一系列不同的特性。下面这个表格汇总了它们的主要区别。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">Hash 模式</th>
<th align="left">History 模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>URL 美观度</strong></td>
<td align="left">不美观 (含 <code>#</code>)</td>
<td align="left">美观 (与普通URL无异)</td>
</tr>
<tr>
<td align="left"><strong>SEO 友好性</strong></td>
<td align="left">不友好</td>
<td align="left">友好 (需服务器配合)</td>
</tr>
<tr>
<td align="left"><strong>服务器配置需求</strong></td>
<td align="left">无需特殊配置</td>
<td align="left">需要配置支持 (避免刷新404)</td>
</tr>
<tr>
<td align="left"><strong>浏览器兼容性</strong></td>
<td align="left">所有浏览器</td>
<td align="left">需要 HTML5 History API 支持 (现代浏览器均支持)</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">监听 <code>hashchange</code> 事件</td>
<td align="left">使用 History API (<code>pushState</code>, <code>replaceState</code>) 和监听 <code>popstate</code> 事件</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">内部工具、管理后台、兼容性要求高的场景</td>
<td align="left">面向公众的网站、对SEO和URL美观度有要求的场景</td>
</tr>
</tbody></table>
<h4 id="工作原理与特点"><a href="#工作原理与特点" class="headerlink" title="工作原理与特点"></a>工作原理与特点</h4><ol>
<li>Hash 模式</li>
</ol>
<ul>
<li>原理：</li>
</ul>
<p>通过 URL 中的 #（哈希值）管理路由。例如：<a href="http://example.com/#/user%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E4%BC%9A%E5%B0%86">http://example.com/#/user。浏览器不会将</a> # 后的内容发送到服务器（仅客户端处理）。</p>
<p>依赖 hashchange 事件监听变化，更新组件无页面重载。</p>
<ul>
<li>优点：</li>
</ul>
<p>零服务器配置：适用于 GitHub Pages、Netlify 等静态托管。</p>
<p>兼容性强：支持旧版浏览器（如 IE9）。</p>
<ul>
<li>缺点：<br>URL 不美观：# 影响可读性。</li>
</ul>
<p>SEO 受限：搜索引擎忽略 # 后内容，无法直接索引路由页面。<br>2. History 模式</p>
<ul>
<li>原理：</li>
</ul>
<p>使用 HTML5 History API（pushState() 和 replaceState()）模拟完整路径。例如：<a href="http://example.com/user%E3%80%82">http://example.com/user。</a><br>URL 无 #，路径由 Vue Router 在客户端管理。</p>
<ul>
<li><p>优点：<br>URL 简洁美观：更符合用户习惯，利于品牌形象。<br>SEO 优化：完整路径可被爬虫抓取（需配合 SSR 或预渲染）。</p>
</li>
<li><p>缺点：</p>
</li>
</ul>
<p>需服务器配置：必须将所有路径重定向到 index.html，否则刷新页面会触发 404 错误。</p>
<p>兼容性要求：不支持 IE9 及以下（需 Polyfill）。</p>
<h4 id="如何编写两种模式"><a href="#如何编写两种模式" class="headerlink" title="如何编写两种模式"></a>如何编写两种模式</h4><p>在 <strong>Vue Router</strong> 中，设置模式非常简单，主要在创建路由实例时进行配置。</p>
<ol>
<li><p><strong>Hash 模式</strong><br>使用 <code>createWebHashHistory</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(), <span class="comment">// 使用 hash 模式</span></span><br><span class="line">  <span class="attr">routes</span>: [...], <span class="comment">// 你的路由配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此后，你的 URL 会形如 <code>http://example.com/#/user/id</code>。</p>
</li>
<li><p><strong>History 模式</strong><br>使用 <code>createWebHistory</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(), <span class="comment">// 使用 history 模式</span></span><br><span class="line">  <span class="attr">routes</span>: [...], <span class="comment">// 你的路由配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此后，你的 URL 会形如 <code>http://example.com/user/id</code>。</p>
</li>
</ol>
<h4 id="服务器配置（History-模式关键）"><a href="#服务器配置（History-模式关键）" class="headerlink" title="服务器配置（History 模式关键）"></a>服务器配置（History 模式关键）</h4><p>选择 <strong>History 模式</strong>，必须在服务器端进行相应配置，以确保用户在浏览器中直接输入 URL 或刷新页面时不会收到 404 错误。这是因为这些 URL 在实际的文件系统中并不存在，需要由 SPA 的入口文件（通常是 <code>index.html</code>）来处理。</p>
<p>以下是常见服务器的配置示例：</p>
<ul>
<li><p><strong>Nginx</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 尝试按顺序寻找资源，最终均返回 index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Apache</strong> (在 <code>.htaccess</code> 文件中)</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;IfModule mod_rewrite.c&gt;</span></span><br><span class="line">  <span class="attribute">RewriteEngine</span> <span class="literal">On</span></span><br><span class="line">  <span class="attribute">RewriteBase</span> /</span><br><span class="line">  <span class="attribute">RewriteRule</span> ^index\.html$ -<span class="meta"> [L]</span></span><br><span class="line">  <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line">  <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line">  <span class="attribute">RewriteRule</span> . /index.html<span class="meta"> [L]</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Node.js (Express)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态资源服务</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 GET 请求均返回 index.html</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist/index.html&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="选择模式的建议"><a href="#选择模式的建议" class="headerlink" title="选择模式的建议"></a>选择模式的建议</h4><p>选择哪种模式取决于你的项目需求：</p>
<ul>
<li><p><strong>选择 Hash 模式，如果</strong>：</p>
<ul>
<li>你的应用是<strong>内部后台管理系统</strong>、工具类应用或原型demo。</li>
<li>你<strong>没有权限或不想配置</strong>服务器。</li>
<li>需要支持<strong>非常古老的浏览器</strong>。</li>
<li><strong>SEO 无关紧要</strong>。</li>
</ul>
</li>
<li><p><strong>选择 History 模式，如果</strong>：</p>
<ul>
<li>你的应用是<strong>面向公众的网站</strong>，如博客、电商平台、企业官网等。</li>
<li>你<strong>非常看重 URL 的美观性和专业性</strong>。</li>
<li><strong>SEO（搜索引擎优化）</strong> 对你的应用至关重要。</li>
<li>你可以<strong>控制并配置服务器</strong>。</li>
</ul>
</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>History 模式的 404 问题</strong>：这是最常见的问题。再次强调，<strong>务必确保你的服务器已正确配置</strong>，否则用户直接访问或刷新深度链接时会得到 404。</li>
<li><strong>Hash 模式与锚点</strong>：URL 中的 <code>#</code> 原本用于页面内锚点导航。在 Hash 模式下，<strong>避免使用与路由路径同名的 HTML 元素 ID</strong>，以免造成冲突和意外滚动。</li>
<li><strong>Abstract 模式</strong>：Vue Router 还支持第三种 <code>abstract</code> 模式（在 Vue Router 4 中通过 <code>createMemoryHistory</code> 实现）。它主要用于 <strong>非浏览器环境</strong>，如 <strong>Node.js（SSR）、Weex 或移动端原生应用</strong>测试，不会改变地址栏的 URL。</li>
</ol>
<ul>
<li>hash+mpa</li>
</ul>
<p>监听hashchange事件，然后加载对应的页面</p>
<p>通常情况下，hash模式用于单页应用，history模式用于多页面应用。</p>
<h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><ul>
<li><p>自定义导航栏 uni-nav-bar</p>
</li>
<li><p>navigation-bar： 指定导航栏的一些属性</p>
</li>
</ul>
<h3 id="uniapp自定义tabbar"><a href="#uniapp自定义tabbar" class="headerlink" title="uniapp自定义tabbar"></a>uniapp自定义tabbar</h3><ul>
<li><p>custom-tab-bar</p>
<p>  只能用于h5端，可以自定义排列顺序、icon等</p>
</li>
<li><p>自己写tabbar组件</p>
<p>  在pages.json中配置原生TabBar并设置custom: true</p>
<p>  创建自定义TabBar组件</p>
<p>  在每个页面中使用自定义TabBar组件</p>
<p>  使用Pinia管理TabBar状态</p>
<p>  处理页面跳转和选中状态</p>
</li>
</ul>
<h3 id="vue3虚拟dom和vue2虚拟dom算法区别"><a href="#vue3虚拟dom和vue2虚拟dom算法区别" class="headerlink" title="vue3虚拟dom和vue2虚拟dom算法区别"></a>vue3虚拟dom和vue2虚拟dom算法区别</h3><ul>
<li><p>Vue2虚拟DOM原理</p>
<ul>
<li>全树比较算法：每次更新时递归比较整个虚拟DOM树</li>
<li>简单VNode结构：使用基本的虚拟节点数据结构</li>
<li>组件级别渲染：以组件为单位进行重新渲染</li>
<li>静态节点处理：每次重新渲染都会重新创建所有节点</li>
<li>事件处理：每次更新都会重新创建事件处理函数</li>
</ul>
</li>
<li><p>Vue3虚拟DOM优化</p>
<ul>
<li><p>Block Tree机制：将动态节点组织为Block，只追踪动态节点</p>
</li>
<li><p>Patch Flags：为动态节点添加标志，指示需要更新的类型</p>
<p>  标记动态节点需要更新的类型，当元素有多个需要改变的部分时，可以通过位运算组合多个标志。</p>
<p>  每种Patch Flag对应一个二进制位，diff时使用按位与(&amp;)操作符检查需要更新的类型</p>
</li>
<li><p>静态提升：静态节点提升到渲染函数外部，避免重复创建</p>
</li>
<li><p>树结构扁平化：减少嵌套层级，提高diff效率</p>
<p>  Vue3在编译阶段会将模板中的嵌套结构转换为扁平化的Block树结构，从而提高diff效率。</p>
<p>  减少递归深度，提高diff效率； 更少的内存占用； 更快的初始渲染和更新</p>
</li>
<li><p>事件监听器缓存：缓存事件处理函数，避免不必要的更新</p>
</li>
</ul>
</li>
<li><p>核心区别详解</p>
</li>
</ul>
<ol>
<li><p>静态提升 (Static Hoisting)<br>Vue3能够检测和提升静态节点，在重新渲染时直接复用，避免不必要的创建和比较。</p>
</li>
<li><p>补丁标志 (Patch Flags)<br>Vue3为动态节点添加补丁标志，指示需要更新的类型，减少比较次数。</p>
</li>
<li><p>Block Tree机制<br>Vue3引入Block Tree概念，将动态节点组织在一起，只追踪动态节点。</p>
</li>
<li><p>树结构扁平化<br>Vue3将嵌套的区块结构扁平化，减少了递归深度，提高了diff效率。</p>
</li>
<li><p>事件监听器缓存<br>Vue3会缓存事件处理函数，避免不必要的更新。</p>
</li>
</ol>
<h3 id="如何防止小程序支付的攻击"><a href="#如何防止小程序支付的攻击" class="headerlink" title="如何防止小程序支付的攻击"></a>如何防止小程序支付的攻击</h3><ul>
<li><p>支付参数由后端返回</p>
</li>
<li><p>API 密钥与证书安全密钥管理：</p>
<p>  将微信支付的 API Key、商户证书存储在服务端环境变量或密钥管理系统（如 AWS KMS）。<br>  禁止硬编码在客户端或代码仓库。</p>
</li>
<li><p>启用微信支付安全模式</p>
<p>  登录微信商户平台 → 开启：<br>  API 证书：用于更高安全级别的接口（如退款）。<br>  IP 白名单：限制调用支付 API 的服务器 IP。<br>  转账收款姓名校验：防止资金被转移到陌生账户。</p>
</li>
<li><p>监控用户支付次数、频率</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>攻击类型</th>
<th>防护措施</th>
</tr>
</thead>
<tbody><tr>
<td>参数篡改</td>
<td>服务端签名 + 客户端禁用构造参数</td>
</tr>
<tr>
<td>重放攻击</td>
<td>Nonce 随机数 + 请求时效控制</td>
</tr>
<tr>
<td>中间人攻击</td>
<td>HTTPS + HSTS 强制加密</td>
</tr>
<tr>
<td>恶意刷单</td>
<td>订单状态机 + 支付频次限额</td>
</tr>
<tr>
<td>未授权支付</td>
<td>敏感操作二次验证</td>
</tr>
<tr>
<td>回调伪造</td>
<td>严格校验微信签名 + 金额匹配</td>
</tr>
</tbody></table>
<h3 id="虚拟dom为什么可以优化性能"><a href="#虚拟dom为什么可以优化性能" class="headerlink" title="虚拟dom为什么可以优化性能"></a>虚拟dom为什么可以优化性能</h3><p>createElement 是 虚拟 DOM 体系中的核心 API，用于创建描述 DOM 结构的 JavaScript 对象（虚拟节点&#x2F;VNode）。它与直接操作真实 DOM 的 document.createElement() 有本质区别</p>
<p>纯 JS 对象：不涉及任何浏览器 DOM 操作</p>
<p>轻量级：比真实 DOM 节点内存占用小 10-100 倍</p>
<p>平台无关：同一套逻辑可渲染到 Web、小程序、原生应用</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>createElement (虚拟 DOM)</th>
<th>document.createElement() (真实 DOM)</th>
</tr>
</thead>
<tbody><tr>
<td>所属体系</td>
<td>框架级虚拟 DOM 库（Vue&#x2F;React）</td>
<td>浏览器原生 DOM API</td>
</tr>
<tr>
<td>返回值</td>
<td>描述 DOM 的 JS 对象（VNode）</td>
<td>浏览器内存中的真实 DOM 元素</td>
</tr>
<tr>
<td>执行成本</td>
<td>极低（仅 JS 对象操作）</td>
<td>高（触发浏览器底层 C++ 对象创建）</td>
</tr>
<tr>
<td>是否触发重排&#x2F;重绘</td>
<td>否（内存操作）</td>
<td>是（立即影响渲染管线）</td>
</tr>
<tr>
<td>使用场景</td>
<td>构建虚拟 DOM 树（框架内部）</td>
<td>手动操作 DOM 时调用</td>
</tr>
<tr>
<td>跨平台能力</td>
<td>一套代码多端渲染</td>
<td>仅限浏览器环境</td>
</tr>
</tbody></table>
<ul>
<li><p>减少直接DOM操作<br>  直接操作DOM非常昂贵，因为每次DOM修改都可能触发浏览器的重排（reflow）和重绘（repaint）。虚拟DOM通过在内存中操作轻量级的JavaScript对象，减少了对真实DOM的直接操作次数。</p>
<p>  用js去处理此次需要的更新</p>
</li>
<li><p>批量更新<br> 虚拟DOM可以收集多次状态变化，然后一次性更新真实DOM,核心机制是通过「异步更新队列 + DocumentFragment 批处理 + 浏览器渲染优化」。这避免了频繁的布局计算和渲染，大幅提升性能。</p>
<p> Vue的虚拟DOM更新并不总是使用DocumentFragment，在初始渲染和移动节点时使用，而更新则通过patch进行最小化操作</p>
<p> 节点移动优化：先移除需要移动的节点到 Fragment-》再一次性插入新位置</p>
<blockquote>
<p>核心机制：异步更新队列（nextTick）将多个数据变更合并为一个更新任务。<br>在更新任务执行时，虚拟DOM的Diff算法会计算出所有需要更新的节点，形成一个更新列表。<br>对于需要新增的多个节点，Vue会使用DocumentFragment来批量插入。<br>对于已存在的节点的更新（如文本变化），Vue会直接修改这些节点，但由于是在同一个任务中，浏览器会将这些DOM操作收集起来，在微任务结束后统一进行重排重绘。</p>
</blockquote>
</li>
<li><p>高效的Diff算法<br>  虚拟DOM使用高效的算法比较新旧虚拟DOM树的差异，找出最小变更集，只更新需要变化的部分，而不是重新渲染整个界面。</p>
</li>
<li><p>跨平台能力<br>  虚拟DOM是抽象的UI描述，可以映射到不同平台（Web、Native、Server），使得代码复用和跨平台开发变得更加容易。</p>
</li>
<li><p>开发者体验提升<br>  虚拟DOM让开发者专注于状态管理，而不是繁琐的DOM操作，提高了开发效率和代码可维护性。</p>
</li>
</ul>
<h3 id="git中间有一笔commit不需要了如何只回退这一笔"><a href="#git中间有一笔commit不需要了如何只回退这一笔" class="headerlink" title="git中间有一笔commit不需要了如何只回退这一笔"></a>git中间有一笔commit不需要了如何只回退这一笔</h3><p>要回退 Git 中的某笔特定提交（且不保留历史记录），可通过<strong>交互式变基（Interactive Rebase）</strong> 实现。以下是步骤：</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>
<p>记录需要删除的提交的哈希值（例如 <code>abc123d</code>），并确定它<strong>之前一个提交</strong>的哈希值（假设为 <code>def456e</code>）。</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i def456e</span><br></pre></td></tr></table></figure>
<p>（这里用 <code>def456e</code> 表示目标提交的前一个提交）</p>
<hr>
<p>文本编辑器会打开一个提交列表，找到需要删除的提交行（如 <code>pick abc123d 提交消息</code>），将其前的 <code>pick</code> 改为 **<code>drop</code>**（或直接删除该行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop abc123d 不需要的提交</span><br><span class="line">pick 28fcdd2 其他提交</span><br><span class="line">pick a1b2c3d 另一笔提交</span><br></pre></td></tr></table></figure>
<p>保存并关闭编辑器。</p>
<hr>
<p>若变基过程中发生冲突：</p>
<ul>
<li>手动解决冲突文件；</li>
<li>执行 <code>git add &lt;文件&gt;</code> 标记已解决；</li>
<li>继续变基：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>如果分支已推送到远程仓库，需强制推送：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt; --force</span><br><span class="line"><span class="comment"># 或使用更安全的 --force-with-lease</span></span><br><span class="line">git push origin &lt;分支名&gt; --force-with-lease</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>风险提示</strong>：修改历史记录会影响协作分支，确保其他开发者知晓此次变更。</li>
<li><strong>备份分支</strong>：操作前建议备份当前分支（<code>git branch backup-branch</code>）。</li>
<li>若只想撤销更改但保留历史，可用 <code>git revert</code>（生成反向提交）。</li>
</ul>
<hr>
<p>如果希望保留历史记录仅撤销更改，使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert abc123d</span><br></pre></td></tr></table></figure>
<p>这会生成一个新的提交来抵消目标提交的更改，无需变基或强制推送。</p>
<h3 id="git-merge和cherry-pick"><a href="#git-merge和cherry-pick" class="headerlink" title="git merge和cherry pick"></a>git merge和cherry pick</h3><p>好的，<code>git merge</code>、<code>git rebase</code> 和 <code>git cherry-pick</code> 是 Git 中三个用于整合更改的核心命令，但它们的工作方式和目的截然不同。</p>
<p>理解它们的区别是掌握 Git 工作流的关键。下面我将对它们进行全面的对比和解释。</p>
<hr>
<h4 id="核心概念一句话总结"><a href="#核心概念一句话总结" class="headerlink" title="核心概念一句话总结"></a>核心概念一句话总结</h4><ol>
<li><strong><code>git merge</code><strong>：</strong>整合分支</strong>。将两个分支的历史记录合并在一起，创建一个新的提交（合并提交）来记录这个汇合点。</li>
<li><strong><code>git rebase</code><strong>：</strong>重整历史</strong>。将一个分支上的所有提交“移动”到另一个分支的最新提交之后，从而创造出更线性的项目历史。</li>
<li><strong><code>git cherry-pick</code><strong>：</strong>复制提交</strong>。选择某个分支上的一个或多个特定提交，将其更改“重新应用”到当前分支，就像它们是在当前分支上编写的一样。</li>
</ol>
<hr>
<h4 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>git merge</code></th>
<th align="left"><code>git rebase</code></th>
<th align="left"><code>git cherry-pick</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">一个<strong>分支</strong>（的所有更改）</td>
<td align="left">一个<strong>分支</strong>（的所有提交）</td>
<td align="left">一个或多个<strong>特定提交</strong></td>
</tr>
<tr>
<td align="left"><strong>结果</strong></td>
<td align="left">创建一个新的<strong>合并提交</strong></td>
<td align="left"><strong>重新书写</strong>提交历史，将提交序列置于新基址</td>
<td align="left">将指定提交的更改作为<strong>新提交</strong>应用到当前分支</td>
</tr>
<tr>
<td align="left"><strong>历史记录</strong></td>
<td align="left"><strong>非线性</strong>，保留完整分支结构</td>
<td align="left"><strong>线性、整洁</strong>，仿佛所有开发都是顺序进行的</td>
<td align="left"><strong>线性</strong>，但可能导致<strong>重复的提交</strong>（相同更改有不同哈希值）</td>
</tr>
<tr>
<td align="left"><strong>主要目的</strong></td>
<td align="left"><strong>集成</strong>完整的功能或分支</td>
<td align="left"><strong>清理</strong>本地分支历史 before merging</td>
<td align="left"><strong>移植</strong>特定的修复或功能</td>
</tr>
<tr>
<td align="left"><strong>风险</strong></td>
<td align="left">低风险，安全操作</td>
<td align="left"><strong>高风险</strong>，会重写历史（<strong>不要对公共分支使用</strong>）</td>
<td align="left">中等风险，可能产生冲突，造成历史重复</td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left"><strong>合影</strong>：把两拨人叫到一起拍张新照片</td>
<td align="left"><strong>重新排队</strong>：让你和你的朋友排到另一队的最前面</td>
<td align="left"><strong>复制粘贴</strong>：把别人文章里写得好的一段话，抄到你的文章里</td>
</tr>
</tbody></table>
<hr>
<h4 id="可视化示例与场景分析"><a href="#可视化示例与场景分析" class="headerlink" title="可视化示例与场景分析"></a>可视化示例与场景分析</h4><p>假设我们从一个共同的基础提交 <code>C2</code> 开始，之后有了不同的开发线：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4 (feature)</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>

<h5 id="场景-1-使用-git-merge"><a href="#场景-1-使用-git-merge" class="headerlink" title="场景 1: 使用 git merge"></a>场景 1: 使用 <code>git merge</code></h5><p><strong>目标：将 <code>hotfix</code> 分支的更改合并到 <code>main</code> 分支。</strong></p>
<ol>
<li><code>git checkout main</code></li>
<li><code>git merge hotfix</code></li>
</ol>
<p><strong>结果：</strong> 创建一个新的合并提交 <code>M1</code>，它有两个父提交 (<code>C2</code> 和 <code>C5</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4 (feature)</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2---M1 (main)</span><br><span class="line">               \ /</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p><strong>何时使用：</strong> 这是标准操作，用于将任何完整的分支（如功能、修复、发布分支）合并回主分支。</p>
<hr>
<h5 id="场景-2-使用-git-rebase"><a href="#场景-2-使用-git-rebase" class="headerlink" title="场景 2: 使用 git rebase"></a>场景 2: 使用 <code>git rebase</code></h5><p><strong>目标：在将 <code>feature</code> 分支合并到 <code>main</code> 之前，先整理其历史，使其包含 <code>main</code> 的最新更新。</strong></p>
<ol>
<li><code>git checkout feature</code></li>
<li><code>git rebase main</code> （这会将 <code>C3</code> 和 <code>C4</code> 的更改“重新播放”在 <code>main</code> 的 <code>C2</code> 之后）</li>
</ol>
<p><strong>结果：</strong> 创建了两个新的提交 <code>C3&#39;</code> 和 <code>C4&#39;</code>，它们有新的哈希值。<code>feature</code> 分支的历史变基到了 <code>main</code> 分支的顶端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                      C3&#x27;---C4&#x27; (feature)</span><br><span class="line">                     /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p>现在，再合并 <code>feature</code> 到 <code>main</code> 会是一次快进合并，历史是线性的。<br><strong>何时使用：</strong> 在本地整理个人特性分支的历史，使其更清晰后再合并。</p>
<hr>
<h5 id="场景-3-使用-git-cherry-pick"><a href="#场景-3-使用-git-cherry-pick" class="headerlink" title="场景 3: 使用 git cherry-pick"></a>场景 3: 使用 <code>git cherry-pick</code></h5><p><strong>目标：只需要将 <code>hotfix</code> 分支上的修复 <code>C5</code> 应用到 <code>feature</code> 分支上，而不需要合并整个 <code>hotfix</code> 分支。</strong></p>
<ol>
<li><code>git checkout feature</code></li>
<li><code>git cherry-pick &lt;C5的哈希值&gt;</code></li>
</ol>
<p><strong>结果：</strong> 将 <code>C5</code> 的更改应用到 <code>feature</code> 分支，生成一个内容相同但哈希值不同的新提交 <code>C5&#39;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4---C5&#x27; (feature) // C5&#x27; 包含了 C5 的更改</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p><strong>何时使用：</strong> 将一个紧急修复从一个分支（如 <code>production</code>）移植到另一个分支（如 <code>development</code>），而不需要执行全部分支合并。</p>
<hr>
<h4 id="如何选择？决策流程图"><a href="#如何选择？决策流程图" class="headerlink" title="如何选择？决策流程图"></a>如何选择？决策流程图</h4><p>面对整合代码的需求时，你可以遵循以下决策流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始：需要整合更改] --&gt; B&#123;操作对象是什么？&#125;</span><br><span class="line">    B -- 整个分支 --&gt; C&#123;目标是公共分支吗？&#125;</span><br><span class="line">    B -- 特定提交 --&gt; D[使用 git cherry-pick&lt;br&gt;移植单个修复或功能]</span><br><span class="line"></span><br><span class="line">    C -- 是 --&gt; E[使用 git merge&lt;br&gt;安全地集成，保留历史]</span><br><span class="line">    C -- 否（个人特性分支） --&gt; F&#123;想要线性历史吗？&#125;</span><br><span class="line"></span><br><span class="line">    F -- 是 --&gt; G[使用 git rebase&lt;br&gt;整理历史后再合并]</span><br><span class="line">    F -- 否 --&gt; E</span><br></pre></td></tr></table></figure>

<h4 id="黄金法则与最佳实践"><a href="#黄金法则与最佳实践" class="headerlink" title="黄金法则与最佳实践"></a>黄金法则与最佳实践</h4><ol>
<li><p>**<code>git merge</code>**：</p>
<ul>
<li><strong>用于</strong>：集成公共分支、发布版本、合并长期运行的功能分支。</li>
<li><strong>优点</strong>：安全，保留历史真相。</li>
</ul>
</li>
<li><p>**<code>git rebase</code>**：</p>
<ul>
<li><strong>黄金法则</strong>：<strong>只对你尚未推送到远程仓库的本地分支进行变基。永远不要对公共分支变基。</strong></li>
<li><strong>用于</strong>：清理本地提交历史（如压缩、修改提交信息），在合并前使历史更清晰。</li>
<li><strong>优点</strong>：创造更干净的历史。</li>
</ul>
</li>
<li><p>**<code>git cherry-pick</code>**：</p>
<ul>
<li><strong>用于</strong>：将特定的提交（如热修复）从一个分支应用到另一个分支，而不需要合并无关的更改。</li>
<li><strong>谨慎使用</strong>：过度使用会导致历史中出现重复的提交，使跟踪代码变更来源变得困难。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> 没有哪个命令是绝对最好的，每个命令都有其特定的用途。根据你的目标（是整合、整理还是移植）和分支的公共性来做出正确选择，是高效使用 Git 的关键。</p>
<h3 id="企微sdk登录授权流程"><a href="#企微sdk登录授权流程" class="headerlink" title="企微sdk登录授权流程"></a>企微sdk登录授权流程</h3><h3 id="websocket和wss协议"><a href="#websocket和wss协议" class="headerlink" title="websocket和wss协议"></a>websocket和wss协议</h3><p>简单来说：<strong>WSS 就是 WS 的安全版本</strong>。</p>
<p>下面我们来详细解析它们的异同。</p>
<hr>
<ul>
<li>核心关系</li>
</ul>
<ul>
<li><strong>WS</strong>： <code>ws://</code> 是 WebSocket 协议的标准、<strong>非加密</strong>模式。</li>
<li><strong>WSS</strong>： <code>wss://</code> 是 WebSocket 协议的<strong>加密</strong>模式，即在 WebSocket 之上添加了一层 TLS (Transport Layer Security) 加密，也就是 SSL。</li>
</ul>
<p>它们的协议栈对比如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WS:  [WebSocket] ← 应用层</span><br><span class="line">     [   TCP    ] ← 传输层</span><br><span class="line"></span><br><span class="line">WSS: [WebSocket] ← 应用层</span><br><span class="line">     [   TLS    ] ← 安全层</span><br><span class="line">     [   TCP    ] ← 传输层</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>相同点</li>
</ul>
<ol>
<li><strong>核心协议相同</strong>： WS 和 WSS 都使用<strong>完全相同的 WebSocket 协议</strong>。一旦连接建立，数据传输的格式、数据帧结构、心跳机制（ping&#x2F;pong）、关闭握手等行为没有任何区别。</li>
<li><strong>功能特性一致</strong>： 两者都提供全双工、低延迟、持久性的通信能力。无论是 WS 还是 WSS，对开发者提供的 API（如 JavaScript 中的 <code>WebSocket</code> API）和使用方式是完全一样的。</li>
<li><strong>握手过程类似</strong>： 连接建立初期都需要一个 HTTP Upgrade 握手过程来将协议从 HTTP 升级到 WebSocket。</li>
</ol>
<hr>
<ul>
<li>不同点</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">WebSocket (WS)</th>
<th align="left">WebSocket Secure (WSS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议方案</strong></td>
<td align="left"><code>ws://</code></td>
<td align="left"><code>wss://</code></td>
</tr>
<tr>
<td align="left"><strong>默认端口</strong></td>
<td align="left">80</td>
<td align="left"><strong>443</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>不加密</strong>。所有数据（包括握手请求和所有数据帧）以<strong>明文</strong>形式在网络上传输。</td>
<td align="left"><strong>加密</strong>。在 WebSocket 协议之下增加了 <strong>TLS&#x2F;SSL</strong> 加密层。所有数据都被加密传输，防止窃听和篡改。</td>
</tr>
<tr>
<td align="left"><strong>握手过程</strong></td>
<td align="left">发送一个普通的 HTTP Upgrade 请求。</td>
<td align="left">发送一个 <strong>HTTPS</strong> Upgrade 请求。首先完成 <strong>TLS 握手</strong>，建立安全通道，然后在此安全通道内进行 WebSocket 的握手。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left"><strong>本地开发</strong>、内部网络（Intranet）或对安全性要求不高的临时环境。</td>
<td align="left"><strong>所有生产环境（Production）</strong> 和任何涉及用户隐私数据的场景（如登录态、个人消息、金融数据等）。</td>
</tr>
<tr>
<td align="left"><strong>浏览器限制</strong></td>
<td align="left">现代浏览器对混合内容（HTTPS 页面中请求 WS 资源）有<strong>严格限制</strong>，通常会<strong>阻止连接</strong>。</td>
<td align="left">是 HTTPS 页面中建立 WebSocket 连接的<strong>唯一可行方式</strong>，不会被浏览器阻止。</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>为什么必须使用 WSS？</li>
</ul>
<ol>
<li><strong>数据安全</strong>：这是最主要的原因。明文传输意味着黑客可以轻易地窃听到你聊天应用里的每一条消息、你游戏中的每一个操作、你股票应用的实时交易数据。</li>
<li><strong>避免中间人攻击</strong>：没有加密，攻击者不仅可以窃听，还可以在中间篡改你发送或接收的数据。</li>
<li><strong>符合浏览器安全策略</strong>：这是<strong>至关重要</strong>的一点。如果一个页面是通过 <strong>HTTPS</strong> 协议加载的，那么浏览器会认为它是一个安全页面。此时，如果该页面中的 JavaScript 尝试去连接一个 <code>ws://</code> 的地址，浏览器会将其视为 <strong>“混合内容”</strong> 并<strong>通常直接阻止此连接</strong>，因为非加密的连接会降低整个页面的安全性。要解决这个问题，**必须使用 <code>wss://</code>**。</li>
</ol>
<p>在前端代码中，除了连接的 URL 字符串不同，API 的使用完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insecureSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secureSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://example.com/ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line">secureSocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;安全连接已建立&#x27;</span>);</span><br><span class="line">  secureSocket.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server over WSS!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">secureSocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息: &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SSE、websocket"><a href="#SSE、websocket" class="headerlink" title="SSE、websocket"></a>SSE、websocket</h3><ul>
<li><p>Socket： 是通信的基础工具（底层 API）。</p>
<ul>
<li>提供了一个“端点”，应用程序通过创建 Socket、绑定地址和端口、监听、连接、发送&#x2F;接收数据等步骤来建立网络连接。</li>
</ul>
<p>  特点：</p>
<ul>
<li><p>非常灵活和强大： 你可以基于 Socket 实现任何自定义的应用层协议（如 FTP、SMTP，也包括 WebSocket 和 HTTP）。</p>
</li>
<li><p>底层和复杂： 开发者需要自己处理诸如数据包重组、心跳保持、协议格式等细节。</p>
</li>
<li><p>与协议无关： Socket 既可以用于 TCP（可靠连接），也可以用于 UDP（无连接）。</p>
</li>
</ul>
</li>
<li><p>WebSocket： 是一个建立在 Socket 之上的高级协议，用于 Web 上的双向通信。</p>
<ul>
<li><p>握手： 客户端首先发送一个特殊的 HTTP 请求（带有 Upgrade: websocket 头），请求“升级”协议。</p>
</li>
<li><p>切换协议： 服务器同意后（HTTP 101响应），双方就不再使用 HTTP，而是转而使用 WebSocket 协议规定的二进制数据帧进行通信。</p>
</li>
<li><p>全双工通信： 连接持久化，服务器和客户端可以随时、独立地向对方发送数据。</p>
</li>
</ul>
</li>
<li><p>SSE： 也是一个建立在 Socket 之上的协议&#x2F;标准，用于 Web 上高效的服务器到客户端单向通信。</p>
<ul>
<li><p>客户端使用标准的 EventSource API 向服务器发起一个普通的 HTTP 请求。</p>
</li>
<li><p>服务器保持这个连接打开，并按照简单的文本格式（data: …\n\n）持续地发送数据块。</p>
</li>
<li><p>连接如果中断，EventSource API 会自动尝试重连。</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">SSE (Server-Sent Events)</th>
<th align="left">WebSocket</th>
<th align="left">Socket (Raw TCP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>通信方向</strong></td>
<td align="left"><strong>单向</strong> (Server → Client)</td>
<td align="left"><strong>全双工</strong> (Server ↔ Client)</td>
<td align="left">双向 (可自定义)</td>
</tr>
<tr>
<td align="left"><strong>协议基础</strong></td>
<td align="left"><strong>HTTP</strong> (长连接)</td>
<td align="left"><strong>独立的 WebSocket 协议</strong> (基于 TCP)</td>
<td align="left"><strong>TCP 或 UDP</strong></td>
</tr>
<tr>
<td align="left"><strong>复杂度</strong></td>
<td align="left">非常简单 (使用方便)</td>
<td align="left">中等 (有协议概念)</td>
<td align="left"><strong>非常复杂</strong> (需自定义所有细节)</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left"><strong>文本</strong> (通常 UTF-8)</td>
<td align="left"><strong>文本和二进制</strong></td>
<td align="left">任意格式 (自定义)</td>
</tr>
<tr>
<td align="left"><strong>浏览器支持</strong></td>
<td align="left"><code>EventSource</code> API</td>
<td align="left"><code>WebSocket</code> API</td>
<td align="left">原生不支持，需通过其他方式（如 Node.js <code>net</code> 模块）</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">实时新闻推送、股票行情、状态更新、日志流</td>
<td align="left">聊天应用、在线游戏、实时协作编辑、高频数据交易</td>
<td align="left">自定义客户端&#x2F;服务器应用、数据库、邮件服务器等底层服务</td>
</tr>
</tbody></table>
<h3 id="微前端怎么用，有什么好处"><a href="#微前端怎么用，有什么好处" class="headerlink" title="微前端怎么用，有什么好处"></a>微前端怎么用，有什么好处</h3><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><ul>
<li>iFrame 的优势</li>
</ul>
<ol>
<li><strong>天然隔离性</strong>：iFrame 提供完全的沙箱环境，样式和JavaScript不会与主应用冲突</li>
<li><strong>简单易用</strong>：只需一个HTML标签即可嵌入完整应用，无需复杂配置</li>
<li><strong>安全性高</strong>：提供内容安全策略(CSP)支持，隔离潜在恶意代码</li>
<li><strong>零技术栈要求</strong>：可以嵌入任何类型的网页，无论其使用什么技术开发</li>
</ol>
<ul>
<li>iFrame 的劣势</li>
</ul>
<ol>
<li><p><strong>用户体验差</strong>：</p>
<ul>
<li>双重滚动条问题</li>
<li>加载状态明显，白屏时间长</li>
<li>弹窗只能限制在iFrame范围内</li>
</ul>
</li>
<li><p><strong>通信困难</strong>：</p>
<ul>
<li>只能通过<code>postMessage</code>进行通信，API简陋</li>
<li>需要自行设计复杂的通信协议</li>
</ul>
</li>
<li><p><strong>性能问题</strong>：</p>
<ul>
<li>每个iFrame需要加载完整的运行时环境(如React&#x2F;Vue)</li>
<li>资源无法在不同iFrame间共享</li>
<li>内存占用高，每个iFrame都是独立的浏览器上下文</li>
</ul>
</li>
<li><p><strong>SEO不友好</strong>：搜索引擎难以抓取iFrame中的内容</p>
</li>
<li><p><strong>路由管理复杂</strong>：iFrame内部路由变化不会反映到浏览器URL中，刷新页面可能导致状态丢失</p>
</li>
</ol>
<ul>
<li>微前端的优势</li>
</ul>
<ol>
<li><p><strong>无缝用户体验</strong>：</p>
<ul>
<li>应用切换流畅，无刷新感</li>
<li>统一的加载状态和错误处理</li>
<li>全局弹窗和通知</li>
</ul>
</li>
<li><p><strong>高效的资源利用</strong>：</p>
<ul>
<li>共享公共依赖(如React, Vue, 工具库)</li>
<li>按需加载子应用，减少初始加载时间</li>
</ul>
</li>
<li><p><strong>灵活的通信机制</strong>：</p>
<ul>
<li>可以使用任何前端状态管理方案</li>
<li>自定义事件系统，通信更直观</li>
</ul>
</li>
<li><p><strong>更好的SEO</strong>：所有内容都在同一DOM树上，易于搜索引擎索引</p>
</li>
<li><p><strong>统一的路由管理</strong>：主应用可以管理全局路由，保持URL与状态同步</p>
</li>
</ol>
<ul>
<li>微前端的劣势</li>
</ul>
<ol>
<li><strong>复杂度高</strong>：需要引入额外框架(如qiankun)，配置和维护成本高</li>
<li><strong>隔离性需要手动处理</strong>：需要解决CSS冲突和JS全局变量污染问题</li>
<li><strong>安全性依赖实现</strong>：不如iFrame的天然沙箱安全</li>
<li><strong>兼容性问题</strong>：不同技术栈间的兼容性需要额外处理</li>
</ol>
<p>使用 iFrame 更适合：</p>
<ol>
<li>嵌入完全独立的第三方应用(如地图、视频播放器)</li>
<li>需要完全隔离样式和脚本的简单嵌入需求</li>
<li>快速原型开发或对用户体验要求不高的内部工具</li>
<li>嵌入安全性未知或不可信的内容</li>
</ol>
<p> 使用微前端更适合：</p>
<ol>
<li>大型企业级应用，需要拆分多个团队独立开发</li>
<li>对用户体验和性能有较高要求的生产环境</li>
<li>需要深度融合和通信的多应用场景</li>
<li>渐进式重构遗留系统，逐步替换老模块</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>微前端 (如 qiankun&#x2F;Single-SPA)</th>
<th>iFrame</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户体验</strong></td>
<td><strong>无缝集成</strong>，保持统一的用户体验</td>
<td><strong>有明显的边界感</strong>，滚动条、加载状态独立</td>
</tr>
<tr>
<td><strong>SEO 支持</strong></td>
<td><strong>友好</strong>，内容在同一个DOM中</td>
<td><strong>不友好</strong>，搜索引擎难以索引iFrame内容</td>
</tr>
<tr>
<td><strong>通信机制</strong></td>
<td><strong>灵活多样</strong> (CustomEvent, 状态管理库等)</td>
<td><strong>受限</strong> (主要依赖 postMessage)</td>
</tr>
<tr>
<td><strong>样式控制</strong></td>
<td><strong>可统一管理</strong> (虽有隔离需求但可协调)</td>
<td><strong>天然隔离</strong>，完全独立不干扰</td>
</tr>
<tr>
<td><strong>性能表现</strong></td>
<td><strong>更优</strong>，资源可共享，切换更流畅</td>
<td><strong>较差</strong>，每个iFrame独立加载全部资源</td>
</tr>
<tr>
<td><strong>开发体验</strong></td>
<td><strong>一体化</strong>，调试、热更新更便捷</td>
<td><strong>割裂</strong>，需要单独调试每个iFrame</td>
</tr>
<tr>
<td><strong>路由管理</strong></td>
<td><strong>统一路由</strong>，保持浏览器历史记录一致</td>
<td><strong>独立路由</strong>，浏览器历史记录管理复杂</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>需要额外处理</strong> JS沙箱、CSS隔离</td>
<td><strong>天然安全沙箱</strong>，完全隔离</td>
</tr>
<tr>
<td><strong>技术栈限制</strong></td>
<td><strong>无限制</strong>，可集成任何前端框架</td>
<td><strong>无限制</strong>，可嵌入任何网页</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td><strong>较高</strong>，需要框架支持和配置</td>
<td><strong>极低</strong>，简单易用</td>
</tr>
</tbody></table>
<h3 id="小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时"><a href="#小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时" class="headerlink" title="小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时"></a>小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时</h3><ul>
<li><p>长列表</p>
<p>  使用虚拟列表：recycle-view </p>
</li>
<li><p>定时器：</p>
<p>  使用一个定时器+一个map去进行页面的显示</p>
</li>
<li><p>使用Worker处理复杂计算</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Worker处理倒计时逻辑</span></span><br><span class="line"><span class="keyword">const</span> timerWorker = wx.<span class="title function_">createWorker</span>(<span class="string">&#x27;workers/timer.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程与Worker通信</span></span><br><span class="line">timerWorker.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line"><span class="attr">action</span>: <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>: countdownData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">timerWorker.<span class="title function_">onMessage</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 接收Worker传来的倒计时数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">countdowns</span>: res.<span class="property">countdowns</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/08/22/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB1/" rel="prev" title="记录2">
                  <i class="fa fa-angle-left"></i> 记录2
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/05/Vue/%E3%80%90vue%E3%80%91%E8%AF%A6%E8%A7%A3computed/" rel="next" title="详解computed">
                  详解computed <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yangxin</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
