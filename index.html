<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yangxin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yangxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/05/Vue/%E3%80%90vue%E3%80%91%E8%AF%A6%E8%A7%A3computed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/05/Vue/%E3%80%90vue%E3%80%91%E8%AF%A6%E8%A7%A3computed/" class="post-title-link" itemprop="url">详解computed</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-09-05 08:15:42 / Modified: 10:16:53" itemprop="dateCreated datePublished" datetime="2025-09-05T08:15:42+08:00">2025-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>computed 基于其内部依赖的响应式数据进行缓存的计算值。只有当其依赖的数据发生变化时，它才会重新计算。</p>
<p>当你创建一个 computed 时，它不会立即执行计算函数。它返回的是一个 class ComputedImp 对象，其 .value 属性在第一次被读取时才会进行首次计算。</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>这个是我们在项目中调用的 computed 函数，那么它在内部还会调用一次 computed</p>
<p>这个实际调用的 computed 参数，会把我们传入的依赖函数和参数传入进去，vue3 会判断当前是否是 ssr</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">computed$1</span> = (<span class="params">getterOrOptions, debugOptions</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">computed</span>(getterOrOptions, debugOptions, isInSSRComponentSetup);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里会把我们传入的回调判断是否有<code>getter</code>和<code>setter</code>，如果我们只传入了一个回调，那么把这个回调作为<code>getter</code>，<code>setter</code>会输出一个 warning；如果是我们自己传入的，那么就把我们传入的作为对应的回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getterOrOptions, debugOptions, isSSR = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter;</span><br><span class="line">  <span class="keyword">let</span> setter;</span><br><span class="line">  <span class="comment">//   判断传入的是一个回调还是带有getter和setter的对象</span></span><br><span class="line">  <span class="keyword">const</span> onlyGetter = <span class="title function_">isFunction</span>(getterOrOptions);</span><br><span class="line">  <span class="comment">//   如果只传入了一个回调，那么就自己内部定义一个setter</span></span><br><span class="line">  <span class="keyword">if</span> (onlyGetter) &#123;</span><br><span class="line">    getter = getterOrOptions;</span><br><span class="line">    setter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;Write operation failed: computed value is readonly&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//   如果我们传入的是对象，那么就获取到对应的getter和setter函数</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = getterOrOptions.<span class="property">get</span>;</span><br><span class="line">    setter = getterOrOptions.<span class="property">set</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cRef = <span class="keyword">new</span> <span class="title class_">ComputedRefImpl</span>(</span><br><span class="line">    getter,</span><br><span class="line">    setter,</span><br><span class="line">    onlyGetter || !setter,</span><br><span class="line">    isSSR</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (debugOptions &amp;&amp; !isSSR) &#123;</span><br><span class="line">    cRef.<span class="property">effect</span>.<span class="property">onTrack</span> = debugOptions.<span class="property">onTrack</span>;</span><br><span class="line">    cRef.<span class="property">effect</span>.<span class="property">onTrigger</span> = debugOptions.<span class="property">onTrigger</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cRef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ComputedRefImpl"><a href="#ComputedRefImpl" class="headerlink" title="ComputedRefImpl"></a>ComputedRefImpl</h4><p>这个是我们实际的 computed 对象，那么这个和基础数据类型拦截器一样，用的 class+属性作为一个返回</p>
<p>在这里面可以看到为什么说 computed 可以缓存数据，利用<strong>_dirty</strong>来去标识是否需要重新计算</p>
<p>我们在新建一个副作用的时候，ReactiveEffect 第二个参数是一个调度器，那么如果传入了这个调度器，在依赖变化时就不会直接执行对应的回调，而是执行这个调度器</p>
<p>因为 computed 在加了 ReactiveEffect 中的调度器是会把<strong>_dirty</strong>来标志如果下次触发了 getter，那么需要重新执行对应的回调函数，所以这就是为什么 computed 可以缓存数据的原因</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ComputedRefImpl</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">getter, _setter, isReadonly, isSSR</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_setter</span> = _setter;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__v_isRef</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//   用于标志在getter是否需要重新执行回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//   副作用，即依赖变化时会触发的，类似于vue2里面的Watcher</span></span><br><span class="line">    <span class="comment">// 传入的第二个参数是调度器，那么在依赖变化时不会直接执行回调，而是执行对应的调度器，在这里就是执行第二个参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span> = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(getter, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_dirty</span>) &#123;</span><br><span class="line">        <span class="comment">// 标识下次执行getter需要重新执行函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_dirty</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//   触发其他依赖到这个computed的地方，通知他们数据修改了</span></span><br><span class="line">        <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">computed</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effect</span>.<span class="property">active</span> = <span class="variable language_">this</span>.<span class="property">_cacheable</span> = !isSSR;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="string">&quot;__v_isReadonly&quot;</span> <span class="comment">/* IS_READONLY */</span>] = isReadonly;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="comment">// the computed ref may get wrapped by other proxies e.g. readonly() #3376</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">//   收集用到这个computed的依赖地方</span></span><br><span class="line">    <span class="title function_">trackRefValue</span>(self);</span><br><span class="line">    <span class="comment">//   ！！！这里就表明只有_dirty为true时或者在ssr情况下才会执行对应的computed回调</span></span><br><span class="line">    <span class="keyword">if</span> (self.<span class="property">_dirty</span> || !self.<span class="property">_cacheable</span>) &#123;</span><br><span class="line">      <span class="comment">// 把标志位置为false，下次就不需要再次执行回调</span></span><br><span class="line">      self.<span class="property">_dirty</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">//   执行对应的回调，这里是执行ReactiveEffect的run函数，run里面会执行fn即getter</span></span><br><span class="line">      self.<span class="property">_value</span> = self.<span class="property">effect</span>.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//   返回回调的返回值</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个将值作为参数传递给我们定义的setter</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_setter</span>(newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><ul>
<li>主要功能</li>
</ul>
<ol>
<li><p><strong>执行副作用函数</strong></p>
<ul>
<li>当 <code>active</code> 为 <code>false</code> 时，直接执行 <code>fn</code> 并返回结果</li>
<li>当 <code>active</code> 为 <code>true</code> 时，进行完整的依赖追踪和执行流程</li>
</ul>
</li>
<li><p><strong>依赖追踪管理</strong></p>
<ul>
<li>设置 <code>activeEffect</code> 为当前的 <code>ReactiveEffect</code> 实例</li>
<li>维护 effect 栈结构，通过 <code>parent</code> 属性处理嵌套的 effect</li>
<li>控制 <code>shouldTrack</code> 状态来决定是否应该追踪依赖</li>
</ul>
</li>
<li><p><strong>执行前准备</strong></p>
<ul>
<li>保存当前的 <code>activeEffect</code> 和 <code>shouldTrack</code> 状态</li>
<li>检查是否存在循环依赖（通过遍历 parent 链）</li>
<li>初始化依赖标记和清理工作</li>
</ul>
</li>
<li><p><strong>执行后清理</strong></p>
<ul>
<li>恢复之前的 <code>activeEffect</code> 和 <code>shouldTrack</code> 状态</li>
<li>处理依赖标记的最终化</li>
<li>如果在执行过程中被要求停止，则进行清理</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReactiveEffect</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn, scheduler = <span class="literal">null</span>, scope</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = fn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">scheduler</span> = scheduler;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="title function_">recordEffectScope</span>(<span class="variable language_">this</span>, scope);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> parent = activeEffect;</span><br><span class="line">    <span class="keyword">let</span> lastShouldTrack = shouldTrack;</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent === <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      parent = parent.<span class="property">parent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心执行逻辑</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = activeEffect;</span><br><span class="line">      <span class="comment">// 设置当前活跃的 effect</span></span><br><span class="line">      activeEffect = <span class="variable language_">this</span>;</span><br><span class="line">      shouldTrack = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//   effectTrackDepth: 表示当前嵌套的 effect 深度层级</span></span><br><span class="line">      <span class="comment">// maxMarkerBits: 最大标记位数，通常是 30（因为 JavaScript 中位运算使用 32 位整数，需要保留一些位用于其他用途）</span></span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; ++effectTrackDepth;</span><br><span class="line">      <span class="comment">//   当嵌套层级未超过最大限制时，使用高效的位运算标记机制</span></span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="comment">// 初始化依赖标记，通过位运算来追踪依赖关系</span></span><br><span class="line">        <span class="title function_">initDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清除之前这个的副作用（依赖项</span></span><br><span class="line">        <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行用户定义的副作用函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 执行后恢复状态</span></span><br><span class="line">      <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="title function_">finalizeDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      trackOpBit = <span class="number">1</span> &lt;&lt; --effectTrackDepth;</span><br><span class="line">      activeEffect = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line">      shouldTrack = lastShouldTrack;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deferStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">stop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// stopped while running itself - defer the cleanup</span></span><br><span class="line">    <span class="keyword">if</span> (activeEffect === <span class="variable language_">this</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deferStop</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h4><p>当执行<code>this.fn();</code>会触发 track 收集器</p>
<p>activeEffect 是个全局变量，在 ReactiveEffec t 执行<code>this.fn</code>之前，就会执行<code>activeEffect = this;</code>，因此这里的 activeEffect 指向的是 ReactiveEffect</p>
<p>这里主要是把对应的依赖收集到 targetMap ，再把这个依赖的具体 key 收集到 dep 中，而 dep 就是 targetMap 中具体依赖的 key 值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, type, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 只有在有活跃的副作用函数时才需要收集</span></span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="comment">// 1. 从 targetMap 中获取 target 对应的 depsMap</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      <span class="comment">// 如果不存在，则为 target 创建一个新的 depsMap 并存入 targetMap</span></span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 从 depsMap 中获取 key 对应的 dep Set</span></span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      <span class="comment">// 如果不存在，则为 key 创建一个新的 dep Set 并存入 depsMap</span></span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="title function_">createDep</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventInfo = &#123; <span class="attr">effect</span>: activeEffect, target, type, key &#125;;</span><br><span class="line">    <span class="title function_">trackEffects</span>(dep, eventInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查 activeEffect 是否存在，确保是在一个副作用函数中读取数据。</p>
<p>从 targetMap 中获取当前 target 对象对应的 depsMap。没有则创建。</p>
<p>从 depsMap 中获取当前 key 对应的 dep Set（即依赖集合）。没有则创建。</p>
<p>将当前活跃的副作用函数 (activeEffect) 添加到这个 dep Set 中。</p>
<p>反向记录：同时将这个 dep 集合也添加到 activeEffect.deps 数组中，方便后续清理。</p>
<h4 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h4><p>当响应式数据的属性被修改（Set） 时，会触发 setter 拦截器中的 trigger 函数。</p>
<p>这里就包含了调度器函数的使用（即 ReactiveEffect 的第二个参数</p>
<p>这里也表明了，vue3 是依据具体的属性 key 去进行依赖更新的，而不是把所有用到对象（不管是不是用到了此次修改的 key 值）全部更新</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 通过 target 从 targetMap 中获取 depsMap</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span>; <span class="comment">// 如果 target 没有收集过任何依赖，直接返回</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 通过 key 从 depsMap 中获取 dep Set</span></span><br><span class="line">  <span class="keyword">const</span> dep = depsMap.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (dep) &#123;</span><br><span class="line">    <span class="comment">// 3. 如果 dep 存在，遍历并执行其中的所有副作用函数</span></span><br><span class="line">    <span class="keyword">const</span> effects = [...dep]; <span class="comment">// 创建一个副本以避免无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> effect <span class="keyword">of</span> effects) &#123;</span><br><span class="line">      <span class="comment">// ！！这里就是computed可以在依赖更新后不会立马执行回调的原因</span></span><br><span class="line">      <span class="keyword">if</span> (effect.<span class="property">scheduler</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有调度器（如 computed, watch），则执行调度器</span></span><br><span class="line">        effect.<span class="title function_">scheduler</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则直接运行副作用函数</span></span><br><span class="line">        effect.<span class="title function_">run</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 target 从 targetMap 中获取对应的 depsMap。</p>
<p>通过 key 从 depsMap 中获取对应的 dep Set（依赖集合）。</p>
<p>如果 dep 存在，遍历这个 Set 中的所有副作用函数，并执行它们（或它们的调度器）</p>
<h3 id="依赖清理"><a href="#依赖清理" class="headerlink" title="依赖清理"></a>依赖清理</h3><p>在 ReactiveEffect 的 run 函数中，会有清理依赖，一个是在执行前的 cleanupEffect，一个是在 fn 执行后的 finalizeDepMarkers</p>
<ul>
<li><p>vue3会在之前遍历所有的旧依赖，标记上w，表明执行之前的依赖</p>
</li>
<li><p>然后在函数执行触发的track中，会触发设置dep的n标记为新依赖表明这个 effect 在本次执行中又用到了这个 dep。</p>
</li>
<li><p>在fn执行后，会比较n和w，然后清理这次没有用到的这些依赖</p>
</li>
</ul>
<h4 id="ReactiveEffect"><a href="#ReactiveEffect" class="headerlink" title="ReactiveEffect"></a>ReactiveEffect</h4><ol>
<li>++effectTrackDepth</li>
</ol>
<p>effectTrackDepth 是一个计数器，记录当前正在执行的 effect 嵌套层级</p>
<p>++effectTrackDepth 先将该计数器加 1，然后返回新值</p>
<ol start="2">
<li>1 &lt;&lt; n (左移运算)</li>
</ol>
<p>这是位运算中的左移操作</p>
<p>将数字 1 的二进制表示向左移动 n 位</p>
<p>相当于 1 乘以 2 的 n 次方 (1 * 2^n)</p>
<p>作用：用于标记不同层级的 effect 追踪状态：</p>
<p>唯一标识：每个嵌套层级的 effect 都有唯一的 trackOpBit 值</p>
<p>状态标记：在依赖收集过程中，使用这些位来标记依赖是否被追踪过</p>
<p>优化清理：通过位运算快速判断依赖的追踪状态，避免重复追踪或遗漏清理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 这里是用于依赖收集的</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = activeEffect;</span><br><span class="line">  activeEffect = <span class="variable language_">this</span>;</span><br><span class="line">  shouldTrack = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设 effectTrackDepth 初始为 0</span></span><br><span class="line">  trackOpBit = <span class="number">1</span> &lt;&lt; ++effectTrackDepth;</span><br><span class="line">  <span class="comment">// 步骤：</span></span><br><span class="line">  <span class="comment">// 1. ++effectTrackDepth → effectTrackDepth = 1</span></span><br><span class="line">  <span class="comment">// 2. 1 &lt;&lt; 1 → 将二进制 1 (01) 左移 1 位 → 二进制 10 → 十进制 2</span></span><br><span class="line">  <span class="comment">// 结果：trackOpBit = 2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一次执行：</span></span><br><span class="line">  trackOpBit = <span class="number">1</span> &lt;&lt; ++effectTrackDepth;</span><br><span class="line">  <span class="comment">// 步骤：</span></span><br><span class="line">  <span class="comment">// 1. ++effectTrackDepth → effectTrackDepth = 2</span></span><br><span class="line">  <span class="comment">// 2. 1 &lt;&lt; 2 → 将二进制 1 (01) 左移 2 位 → 二进制 100 → 十进制 4</span></span><br><span class="line">  <span class="comment">// 结果：trackOpBit = 4</span></span><br><span class="line">  <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">    <span class="comment">// 用于标记旧依赖</span></span><br><span class="line">    <span class="title function_">initDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果已经超出限制了，那就把之前的依赖删除，反正后面执行fn也会重新收集依赖</span></span><br><span class="line">    <span class="title function_">cleanupEffect</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">    <span class="comment">// 只有没有清理依赖（没执行cleanupEffect）的时候才需要把旧依赖清除掉</span></span><br><span class="line">    <span class="title function_">finalizeDepMarkers</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  trackOpBit = <span class="number">1</span> &lt;&lt; --effectTrackDepth;</span><br><span class="line">  activeEffect = <span class="variable language_">this</span>.<span class="property">parent</span>;</span><br><span class="line">  shouldTrack = lastShouldTrack;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deferStop</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标志位修改"><a href="#标志位修改" class="headerlink" title="标志位修改"></a>标志位修改</h4><p>这里会在每个 dep 上做一个“was tracked”（曾被跟踪）的标记，标记这个 effect 在上一次执行时属于这个 dep</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initDepMarkers</span> = (<span class="params">&#123; deps &#125;</span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (deps.<span class="property">length</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">             deps[i].<span class="property">w</span> |= trackOpBit; <span class="comment">// set was tracked</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>这里是track在最后调用的函数，这里会在每个dep上加上n标识，表面这次最新的一个追踪</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trackEffects</span>(<span class="params">dep, debuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> shouldTrack = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (effectTrackDepth &lt;= maxMarkerBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">newTracked</span>(dep)) &#123;</span><br><span class="line">            dep.<span class="property">n</span> |= trackOpBit; <span class="comment">// set newly tracked</span></span><br><span class="line">            shouldTrack = !<span class="title function_">wasTracked</span>(dep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Full cleanup mode.</span></span><br><span class="line">        shouldTrack = !dep.<span class="title function_">has</span>(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrack) &#123;</span><br><span class="line">        dep.<span class="title function_">add</span>(activeEffect);</span><br><span class="line">        activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep);</span><br><span class="line">        <span class="keyword">if</span> (activeEffect.<span class="property">onTrack</span>) &#123;</span><br><span class="line">            activeEffect.<span class="title function_">onTrack</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">effect</span>: activeEffect &#125;, debuggerEventExtraInfo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是在fn执行后，会清除之前没有用到的依赖</p>
<p>通过对比每个 dep 上的 “was tracked” 和 “new tracked” 标记，它可以判断出：</p>
<p>  如果一个 dep 只有“was”标记，没有“new”标记：说明这个依赖在本次执行中已经不再需要了。于是，将 effect 从这个 dep 中删除。</p>
<p>  如果一个 dep 有“new”标记：说明这个依赖在本次执行中仍然被需要或者是新添加的。那就保留它，并清除标记以备下次使用。</p>
<p>这样就实现了一种增量更新，只删除了失效的依赖，而保留仍然有效的依赖，避免了全量清理的开销。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">finalizeDepMarkers</span> = (<span class="params">effect</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; deps &#125; = effect;</span><br><span class="line">    <span class="keyword">if</span> (deps.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; deps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> dep = deps[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">wasTracked</span>(dep) &amp;&amp; !<span class="title function_">newTracked</span>(dep)) &#123;</span><br><span class="line">                dep.<span class="title function_">delete</span>(effect);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                deps[ptr++] = dep;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// clear bits</span></span><br><span class="line">            dep.<span class="property">w</span> &amp;= ~trackOpBit;</span><br><span class="line">            dep.<span class="property">n</span> &amp;= ~trackOpBit;</span><br><span class="line">        &#125;</span><br><span class="line">        deps.<span class="property">length</span> = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>computed缓存实现原理</p>
<p> computed中有个<code>dirty</code>标志位，结合调度器使用，只有当<code>dirty</code>为true时才会重新执行函数，并重新计算，得到值；调度器保证依赖变化时不会触发函数的回调</p>
</li>
<li><p>依赖清理</p>
<p>在执行回调前，会如果嵌套深度大于了最大深度，那么会把之前的依赖清除，但是由于在执行函数时会触发getter的track，会重新收集依赖，因此不用担心依赖没了的问题</p>
<p>如果嵌套深度没有大于最大深度，那么会执行函数前，对每个dep打上旧的trackd标志位，在执行track时会对dep加上新的trackd标志位。当函数执行结束后，会判断新旧的trackd标志位，只有旧的没有新的旧会被剔除</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/25/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB2/" class="post-title-link" itemprop="url">记录3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-25 10:42:18" itemprop="dateCreated datePublished" datetime="2025-08-25T10:42:18+08:00">2025-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-08 12:18:18" itemprop="dateModified" datetime="2025-09-08T12:18:18+08:00">2025-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="vue-router不同传参模式"><a href="#vue-router不同传参模式" class="headerlink" title="vue-router不同传参模式"></a>vue-router不同传参模式</h3><p>了解 Vue Router 的不同传参方式很重要，它们各有特点，适用于不同的场景。下面我用一个表格汇总它们的核心区别，然后详细解释：</p>
<table>
<thead>
<tr>
<th>特性维度</th>
<th>动态路由传参 (Dynamic Routes)</th>
<th>Params 传参 (不显示在 URL)</th>
<th>Query 传参 (Query Parameters)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL 中的表现</strong></td>
<td>路径的一部分 (e.g., <code>/user/123</code>)</td>
<td><strong>不在 URL 中显示</strong></td>
<td>查询字符串 (e.g., <code>?id=123&amp;name=zhangsan</code>)</td>
</tr>
<tr>
<td><strong>路由配置</strong></td>
<td>需在 path 中定义参数 (<code>:id</code>)</td>
<td>无需在 path 中定义参数</td>
<td>无需在 path 中定义参数</td>
</tr>
<tr>
<td><strong>跳转方式</strong></td>
<td><code>path</code> 或 <code>name</code></td>
<td>必须使用 <code>name</code></td>
<td><code>path</code> 或 <code>name</code></td>
</tr>
<tr>
<td><strong>参数传递语法</strong></td>
<td><code>path: &#39;/user/&#39; + userId</code> 或 <code>params</code></td>
<td><code>params: &#123; id: 123 &#125;</code></td>
<td><code>query: &#123; id: 123 &#125;</code></td>
</tr>
<tr>
<td><strong>参数获取语法</strong></td>
<td><code>$route.params.id</code></td>
<td><code>$route.params.id</code></td>
<td><code>$route.query.id</code></td>
</tr>
<tr>
<td><strong>页面刷新后</strong></td>
<td><strong>参数保留</strong></td>
<td><strong>参数丢失</strong></td>
<td><strong>参数保留</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>资源ID、必要参数</td>
<td>敏感数据、临时参数</td>
<td>筛选条件、可选参数、分享链接</td>
</tr>
</tbody></table>
<p> <strong>其他传参方式</strong><br>除了上述三种主要方式，还有：</p>
<ul>
<li><strong>通过 <code>props</code> 解耦</strong>：在路由配置中设置 <code>props: true</code>，可以将 <code>$route.params</code> 作为组件的 <strong>props</strong> 接收，让组件更独立，不直接依赖 <code>$route</code> 对象。</li>
<li>**通过路由元信息 <code>meta</code>**：可以在路由配置的 <code>meta</code> 字段中添加一些静态信息（如页面标题、权限要求），常用于全局导航守卫中进行逻辑判断。</li>
</ul>
<p><strong>如何选择传参方式</strong></p>
<p>选择哪种方式，可以根据你的具体需求来定：</p>
<ul>
<li>需要参数在<strong>页面刷新后仍然保留</strong>，或者希望参数<strong>体现在 URL 中以便分享或收藏</strong>？优先考虑 <strong>动态路由传参</strong> 或 <strong>Query 传参</strong>。</li>
<li>传递的是<strong>敏感信息</strong>（如临时令牌）或<strong>不希望参数暴露在 URL 中</strong>？可以考虑 <strong>Params 传参（不显示）</strong>，但需注意刷新会丢失。</li>
<li>参数是<strong>可选的、非必需的</strong>，比如列表的<strong>筛选、排序条件</strong>？<strong>Query 传参</strong> 很合适。</li>
<li>参数是<strong>资源的唯一标识</strong>（如用户ID、文章ID）？<strong>动态路由传参</strong> 更语义化。</li>
<li>希望组件能<strong>更独立于路由</strong>，减少对 <code>$route</code> 的依赖？试试 <strong><code>props</code> 传参</strong>。</li>
</ul>
<p> <strong>简单的使用建议</strong></p>
<ul>
<li><strong>重要且必要的参数</strong>，尤其像对象ID这类，常用<strong>动态路由传参</strong>。</li>
<li><strong>可选参数</strong>或<strong>多个参数</strong>，常用 <strong>Query 传参</strong>。</li>
<li><strong>Params传参（不显示）</strong> 需谨慎使用，注意其刷新页面参数会丢失的特性。</li>
</ul>
<p>希望这些信息能帮助你更好地选择和使用 Vue Router 的传参方式。</p>
<h3 id="路由模式区别"><a href="#路由模式区别" class="headerlink" title="路由模式区别"></a>路由模式区别</h3><p>这两个模式的核心区别在于<strong>如何模拟和操作浏览器的历史记录</strong>，从而带来了一系列不同的特性。下面这个表格汇总了它们的主要区别。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">Hash 模式</th>
<th align="left">History 模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>URL 美观度</strong></td>
<td align="left">不美观 (含 <code>#</code>)</td>
<td align="left">美观 (与普通URL无异)</td>
</tr>
<tr>
<td align="left"><strong>SEO 友好性</strong></td>
<td align="left">不友好</td>
<td align="left">友好 (需服务器配合)</td>
</tr>
<tr>
<td align="left"><strong>服务器配置需求</strong></td>
<td align="left">无需特殊配置</td>
<td align="left">需要配置支持 (避免刷新404)</td>
</tr>
<tr>
<td align="left"><strong>浏览器兼容性</strong></td>
<td align="left">所有浏览器</td>
<td align="left">需要 HTML5 History API 支持 (现代浏览器均支持)</td>
</tr>
<tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">监听 <code>hashchange</code> 事件</td>
<td align="left">使用 History API (<code>pushState</code>, <code>replaceState</code>) 和监听 <code>popstate</code> 事件</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">内部工具、管理后台、兼容性要求高的场景</td>
<td align="left">面向公众的网站、对SEO和URL美观度有要求的场景</td>
</tr>
</tbody></table>
<h4 id="工作原理与特点"><a href="#工作原理与特点" class="headerlink" title="工作原理与特点"></a>工作原理与特点</h4><ol>
<li>Hash 模式</li>
</ol>
<ul>
<li>原理：</li>
</ul>
<p>通过 URL 中的 #（哈希值）管理路由。例如：<a href="http://example.com/#/user%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8D%E4%BC%9A%E5%B0%86">http://example.com/#/user。浏览器不会将</a> # 后的内容发送到服务器（仅客户端处理）。</p>
<p>依赖 hashchange 事件监听变化，更新组件无页面重载。</p>
<ul>
<li>优点：</li>
</ul>
<p>零服务器配置：适用于 GitHub Pages、Netlify 等静态托管。</p>
<p>兼容性强：支持旧版浏览器（如 IE9）。</p>
<ul>
<li>缺点：<br>URL 不美观：# 影响可读性。</li>
</ul>
<p>SEO 受限：搜索引擎忽略 # 后内容，无法直接索引路由页面。<br>2. History 模式</p>
<ul>
<li>原理：</li>
</ul>
<p>使用 HTML5 History API（pushState() 和 replaceState()）模拟完整路径。例如：<a href="http://example.com/user%E3%80%82">http://example.com/user。</a><br>URL 无 #，路径由 Vue Router 在客户端管理。</p>
<ul>
<li><p>优点：<br>URL 简洁美观：更符合用户习惯，利于品牌形象。<br>SEO 优化：完整路径可被爬虫抓取（需配合 SSR 或预渲染）。</p>
</li>
<li><p>缺点：</p>
</li>
</ul>
<p>需服务器配置：必须将所有路径重定向到 index.html，否则刷新页面会触发 404 错误。</p>
<p>兼容性要求：不支持 IE9 及以下（需 Polyfill）。</p>
<h4 id="如何编写两种模式"><a href="#如何编写两种模式" class="headerlink" title="如何编写两种模式"></a>如何编写两种模式</h4><p>在 <strong>Vue Router</strong> 中，设置模式非常简单，主要在创建路由实例时进行配置。</p>
<ol>
<li><p><strong>Hash 模式</strong><br>使用 <code>createWebHashHistory</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(), <span class="comment">// 使用 hash 模式</span></span><br><span class="line">  <span class="attr">routes</span>: [...], <span class="comment">// 你的路由配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此后，你的 URL 会形如 <code>http://example.com/#/user/id</code>。</p>
</li>
<li><p><strong>History 模式</strong><br>使用 <code>createWebHistory</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHistory</span>(), <span class="comment">// 使用 history 模式</span></span><br><span class="line">  <span class="attr">routes</span>: [...], <span class="comment">// 你的路由配置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此后，你的 URL 会形如 <code>http://example.com/user/id</code>。</p>
</li>
</ol>
<h4 id="服务器配置（History-模式关键）"><a href="#服务器配置（History-模式关键）" class="headerlink" title="服务器配置（History 模式关键）"></a>服务器配置（History 模式关键）</h4><p>选择 <strong>History 模式</strong>，必须在服务器端进行相应配置，以确保用户在浏览器中直接输入 URL 或刷新页面时不会收到 404 错误。这是因为这些 URL 在实际的文件系统中并不存在，需要由 SPA 的入口文件（通常是 <code>index.html</code>）来处理。</p>
<p>以下是常见服务器的配置示例：</p>
<ul>
<li><p><strong>Nginx</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 尝试按顺序寻找资源，最终均返回 index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Apache</strong> (在 <code>.htaccess</code> 文件中)</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;IfModule mod_rewrite.c&gt;</span></span><br><span class="line">  <span class="attribute">RewriteEngine</span> <span class="literal">On</span></span><br><span class="line">  <span class="attribute">RewriteBase</span> /</span><br><span class="line">  <span class="attribute">RewriteRule</span> ^index\.html$ -<span class="meta"> [L]</span></span><br><span class="line">  <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line">  <span class="attribute">RewriteCond</span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line">  <span class="attribute">RewriteRule</span> . /index.html<span class="meta"> [L]</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Node.js (Express)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态资源服务</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 GET 请求均返回 index.html</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist/index.html&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="选择模式的建议"><a href="#选择模式的建议" class="headerlink" title="选择模式的建议"></a>选择模式的建议</h4><p>选择哪种模式取决于你的项目需求：</p>
<ul>
<li><p><strong>选择 Hash 模式，如果</strong>：</p>
<ul>
<li>你的应用是<strong>内部后台管理系统</strong>、工具类应用或原型demo。</li>
<li>你<strong>没有权限或不想配置</strong>服务器。</li>
<li>需要支持<strong>非常古老的浏览器</strong>。</li>
<li><strong>SEO 无关紧要</strong>。</li>
</ul>
</li>
<li><p><strong>选择 History 模式，如果</strong>：</p>
<ul>
<li>你的应用是<strong>面向公众的网站</strong>，如博客、电商平台、企业官网等。</li>
<li>你<strong>非常看重 URL 的美观性和专业性</strong>。</li>
<li><strong>SEO（搜索引擎优化）</strong> 对你的应用至关重要。</li>
<li>你可以<strong>控制并配置服务器</strong>。</li>
</ul>
</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>History 模式的 404 问题</strong>：这是最常见的问题。再次强调，<strong>务必确保你的服务器已正确配置</strong>，否则用户直接访问或刷新深度链接时会得到 404。</li>
<li><strong>Hash 模式与锚点</strong>：URL 中的 <code>#</code> 原本用于页面内锚点导航。在 Hash 模式下，<strong>避免使用与路由路径同名的 HTML 元素 ID</strong>，以免造成冲突和意外滚动。</li>
<li><strong>Abstract 模式</strong>：Vue Router 还支持第三种 <code>abstract</code> 模式（在 Vue Router 4 中通过 <code>createMemoryHistory</code> 实现）。它主要用于 <strong>非浏览器环境</strong>，如 <strong>Node.js（SSR）、Weex 或移动端原生应用</strong>测试，不会改变地址栏的 URL。</li>
</ol>
<ul>
<li>hash+mpa</li>
</ul>
<p>监听hashchange事件，然后加载对应的页面</p>
<p>通常情况下，hash模式用于单页应用，history模式用于多页面应用。</p>
<h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><ul>
<li><p>自定义导航栏 uni-nav-bar</p>
</li>
<li><p>navigation-bar： 指定导航栏的一些属性</p>
</li>
</ul>
<h3 id="uniapp自定义tabbar"><a href="#uniapp自定义tabbar" class="headerlink" title="uniapp自定义tabbar"></a>uniapp自定义tabbar</h3><ul>
<li><p>custom-tab-bar</p>
<p>  只能用于h5端，可以自定义排列顺序、icon等</p>
</li>
<li><p>自己写tabbar组件</p>
<p>  在pages.json中配置原生TabBar并设置custom: true</p>
<p>  创建自定义TabBar组件</p>
<p>  在每个页面中使用自定义TabBar组件</p>
<p>  使用Pinia管理TabBar状态</p>
<p>  处理页面跳转和选中状态</p>
</li>
</ul>
<h3 id="vue3虚拟dom和vue2虚拟dom算法区别"><a href="#vue3虚拟dom和vue2虚拟dom算法区别" class="headerlink" title="vue3虚拟dom和vue2虚拟dom算法区别"></a>vue3虚拟dom和vue2虚拟dom算法区别</h3><ul>
<li><p>Vue2虚拟DOM原理</p>
<ul>
<li>全树比较算法：每次更新时递归比较整个虚拟DOM树</li>
<li>简单VNode结构：使用基本的虚拟节点数据结构</li>
<li>组件级别渲染：以组件为单位进行重新渲染</li>
<li>静态节点处理：每次重新渲染都会重新创建所有节点</li>
<li>事件处理：每次更新都会重新创建事件处理函数</li>
</ul>
</li>
<li><p>Vue3虚拟DOM优化</p>
<ul>
<li><p>Block Tree机制：将动态节点组织为Block，只追踪动态节点</p>
</li>
<li><p>Patch Flags：为动态节点添加标志，指示需要更新的类型</p>
<p>  标记动态节点需要更新的类型，当元素有多个需要改变的部分时，可以通过位运算组合多个标志。</p>
<p>  每种Patch Flag对应一个二进制位，diff时使用按位与(&amp;)操作符检查需要更新的类型</p>
</li>
<li><p>静态提升：静态节点提升到渲染函数外部，避免重复创建</p>
</li>
<li><p>树结构扁平化：减少嵌套层级，提高diff效率</p>
<p>  Vue3在编译阶段会将模板中的嵌套结构转换为扁平化的Block树结构，从而提高diff效率。</p>
<p>  减少递归深度，提高diff效率； 更少的内存占用； 更快的初始渲染和更新</p>
</li>
<li><p>事件监听器缓存：缓存事件处理函数，避免不必要的更新</p>
</li>
</ul>
</li>
<li><p>核心区别详解</p>
</li>
</ul>
<ol>
<li><p>静态提升 (Static Hoisting)<br>Vue3能够检测和提升静态节点，在重新渲染时直接复用，避免不必要的创建和比较。</p>
</li>
<li><p>补丁标志 (Patch Flags)<br>Vue3为动态节点添加补丁标志，指示需要更新的类型，减少比较次数。</p>
</li>
<li><p>Block Tree机制<br>Vue3引入Block Tree概念，将动态节点组织在一起，只追踪动态节点。</p>
</li>
<li><p>树结构扁平化<br>Vue3将嵌套的区块结构扁平化，减少了递归深度，提高了diff效率。</p>
</li>
<li><p>事件监听器缓存<br>Vue3会缓存事件处理函数，避免不必要的更新。</p>
</li>
</ol>
<h3 id="如何防止小程序支付的攻击"><a href="#如何防止小程序支付的攻击" class="headerlink" title="如何防止小程序支付的攻击"></a>如何防止小程序支付的攻击</h3><ul>
<li><p>支付参数由后端返回</p>
</li>
<li><p>API 密钥与证书安全密钥管理：</p>
<p>  将微信支付的 API Key、商户证书存储在服务端环境变量或密钥管理系统（如 AWS KMS）。<br>  禁止硬编码在客户端或代码仓库。</p>
</li>
<li><p>启用微信支付安全模式</p>
<p>  登录微信商户平台 → 开启：<br>  API 证书：用于更高安全级别的接口（如退款）。<br>  IP 白名单：限制调用支付 API 的服务器 IP。<br>  转账收款姓名校验：防止资金被转移到陌生账户。</p>
</li>
<li><p>监控用户支付次数、频率</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>攻击类型</th>
<th>防护措施</th>
</tr>
</thead>
<tbody><tr>
<td>参数篡改</td>
<td>服务端签名 + 客户端禁用构造参数</td>
</tr>
<tr>
<td>重放攻击</td>
<td>Nonce 随机数 + 请求时效控制</td>
</tr>
<tr>
<td>中间人攻击</td>
<td>HTTPS + HSTS 强制加密</td>
</tr>
<tr>
<td>恶意刷单</td>
<td>订单状态机 + 支付频次限额</td>
</tr>
<tr>
<td>未授权支付</td>
<td>敏感操作二次验证</td>
</tr>
<tr>
<td>回调伪造</td>
<td>严格校验微信签名 + 金额匹配</td>
</tr>
</tbody></table>
<h3 id="虚拟dom为什么可以优化性能"><a href="#虚拟dom为什么可以优化性能" class="headerlink" title="虚拟dom为什么可以优化性能"></a>虚拟dom为什么可以优化性能</h3><p>createElement 是 虚拟 DOM 体系中的核心 API，用于创建描述 DOM 结构的 JavaScript 对象（虚拟节点&#x2F;VNode）。它与直接操作真实 DOM 的 document.createElement() 有本质区别</p>
<p>纯 JS 对象：不涉及任何浏览器 DOM 操作</p>
<p>轻量级：比真实 DOM 节点内存占用小 10-100 倍</p>
<p>平台无关：同一套逻辑可渲染到 Web、小程序、原生应用</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>createElement (虚拟 DOM)</th>
<th>document.createElement() (真实 DOM)</th>
</tr>
</thead>
<tbody><tr>
<td>所属体系</td>
<td>框架级虚拟 DOM 库（Vue&#x2F;React）</td>
<td>浏览器原生 DOM API</td>
</tr>
<tr>
<td>返回值</td>
<td>描述 DOM 的 JS 对象（VNode）</td>
<td>浏览器内存中的真实 DOM 元素</td>
</tr>
<tr>
<td>执行成本</td>
<td>极低（仅 JS 对象操作）</td>
<td>高（触发浏览器底层 C++ 对象创建）</td>
</tr>
<tr>
<td>是否触发重排&#x2F;重绘</td>
<td>否（内存操作）</td>
<td>是（立即影响渲染管线）</td>
</tr>
<tr>
<td>使用场景</td>
<td>构建虚拟 DOM 树（框架内部）</td>
<td>手动操作 DOM 时调用</td>
</tr>
<tr>
<td>跨平台能力</td>
<td>一套代码多端渲染</td>
<td>仅限浏览器环境</td>
</tr>
</tbody></table>
<ul>
<li><p>减少直接DOM操作<br>  直接操作DOM非常昂贵，因为每次DOM修改都可能触发浏览器的重排（reflow）和重绘（repaint）。虚拟DOM通过在内存中操作轻量级的JavaScript对象，减少了对真实DOM的直接操作次数。</p>
<p>  用js去处理此次需要的更新</p>
</li>
<li><p>批量更新<br> 虚拟DOM可以收集多次状态变化，然后一次性更新真实DOM,核心机制是通过「异步更新队列 + DocumentFragment 批处理 + 浏览器渲染优化」。这避免了频繁的布局计算和渲染，大幅提升性能。</p>
<p> Vue的虚拟DOM更新并不总是使用DocumentFragment，在初始渲染和移动节点时使用，而更新则通过patch进行最小化操作</p>
<p> 节点移动优化：先移除需要移动的节点到 Fragment-》再一次性插入新位置</p>
<blockquote>
<p>核心机制：异步更新队列（nextTick）将多个数据变更合并为一个更新任务。<br>在更新任务执行时，虚拟DOM的Diff算法会计算出所有需要更新的节点，形成一个更新列表。<br>对于需要新增的多个节点，Vue会使用DocumentFragment来批量插入。<br>对于已存在的节点的更新（如文本变化），Vue会直接修改这些节点，但由于是在同一个任务中，浏览器会将这些DOM操作收集起来，在微任务结束后统一进行重排重绘。</p>
</blockquote>
</li>
<li><p>高效的Diff算法<br>  虚拟DOM使用高效的算法比较新旧虚拟DOM树的差异，找出最小变更集，只更新需要变化的部分，而不是重新渲染整个界面。</p>
</li>
<li><p>跨平台能力<br>  虚拟DOM是抽象的UI描述，可以映射到不同平台（Web、Native、Server），使得代码复用和跨平台开发变得更加容易。</p>
</li>
<li><p>开发者体验提升<br>  虚拟DOM让开发者专注于状态管理，而不是繁琐的DOM操作，提高了开发效率和代码可维护性。</p>
</li>
</ul>
<h3 id="git中间有一笔commit不需要了如何只回退这一笔"><a href="#git中间有一笔commit不需要了如何只回退这一笔" class="headerlink" title="git中间有一笔commit不需要了如何只回退这一笔"></a>git中间有一笔commit不需要了如何只回退这一笔</h3><p>要回退 Git 中的某笔特定提交（且不保留历史记录），可通过<strong>交互式变基（Interactive Rebase）</strong> 实现。以下是步骤：</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>
<p>记录需要删除的提交的哈希值（例如 <code>abc123d</code>），并确定它<strong>之前一个提交</strong>的哈希值（假设为 <code>def456e</code>）。</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i def456e</span><br></pre></td></tr></table></figure>
<p>（这里用 <code>def456e</code> 表示目标提交的前一个提交）</p>
<hr>
<p>文本编辑器会打开一个提交列表，找到需要删除的提交行（如 <code>pick abc123d 提交消息</code>），将其前的 <code>pick</code> 改为 **<code>drop</code>**（或直接删除该行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop abc123d 不需要的提交</span><br><span class="line">pick 28fcdd2 其他提交</span><br><span class="line">pick a1b2c3d 另一笔提交</span><br></pre></td></tr></table></figure>
<p>保存并关闭编辑器。</p>
<hr>
<p>若变基过程中发生冲突：</p>
<ul>
<li>手动解决冲突文件；</li>
<li>执行 <code>git add &lt;文件&gt;</code> 标记已解决；</li>
<li>继续变基：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>如果分支已推送到远程仓库，需强制推送：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt; --force</span><br><span class="line"><span class="comment"># 或使用更安全的 --force-with-lease</span></span><br><span class="line">git push origin &lt;分支名&gt; --force-with-lease</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><strong>风险提示</strong>：修改历史记录会影响协作分支，确保其他开发者知晓此次变更。</li>
<li><strong>备份分支</strong>：操作前建议备份当前分支（<code>git branch backup-branch</code>）。</li>
<li>若只想撤销更改但保留历史，可用 <code>git revert</code>（生成反向提交）。</li>
</ul>
<hr>
<p>如果希望保留历史记录仅撤销更改，使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert abc123d</span><br></pre></td></tr></table></figure>
<p>这会生成一个新的提交来抵消目标提交的更改，无需变基或强制推送。</p>
<h3 id="git-merge和cherry-pick"><a href="#git-merge和cherry-pick" class="headerlink" title="git merge和cherry pick"></a>git merge和cherry pick</h3><p>好的，<code>git merge</code>、<code>git rebase</code> 和 <code>git cherry-pick</code> 是 Git 中三个用于整合更改的核心命令，但它们的工作方式和目的截然不同。</p>
<p>理解它们的区别是掌握 Git 工作流的关键。下面我将对它们进行全面的对比和解释。</p>
<hr>
<h4 id="核心概念一句话总结"><a href="#核心概念一句话总结" class="headerlink" title="核心概念一句话总结"></a>核心概念一句话总结</h4><ol>
<li><strong><code>git merge</code><strong>：</strong>整合分支</strong>。将两个分支的历史记录合并在一起，创建一个新的提交（合并提交）来记录这个汇合点。</li>
<li><strong><code>git rebase</code><strong>：</strong>重整历史</strong>。将一个分支上的所有提交“移动”到另一个分支的最新提交之后，从而创造出更线性的项目历史。</li>
<li><strong><code>git cherry-pick</code><strong>：</strong>复制提交</strong>。选择某个分支上的一个或多个特定提交，将其更改“重新应用”到当前分支，就像它们是在当前分支上编写的一样。</li>
</ol>
<hr>
<h4 id="对比表格"><a href="#对比表格" class="headerlink" title="对比表格"></a>对比表格</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>git merge</code></th>
<th align="left"><code>git rebase</code></th>
<th align="left"><code>git cherry-pick</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left">一个<strong>分支</strong>（的所有更改）</td>
<td align="left">一个<strong>分支</strong>（的所有提交）</td>
<td align="left">一个或多个<strong>特定提交</strong></td>
</tr>
<tr>
<td align="left"><strong>结果</strong></td>
<td align="left">创建一个新的<strong>合并提交</strong></td>
<td align="left"><strong>重新书写</strong>提交历史，将提交序列置于新基址</td>
<td align="left">将指定提交的更改作为<strong>新提交</strong>应用到当前分支</td>
</tr>
<tr>
<td align="left"><strong>历史记录</strong></td>
<td align="left"><strong>非线性</strong>，保留完整分支结构</td>
<td align="left"><strong>线性、整洁</strong>，仿佛所有开发都是顺序进行的</td>
<td align="left"><strong>线性</strong>，但可能导致<strong>重复的提交</strong>（相同更改有不同哈希值）</td>
</tr>
<tr>
<td align="left"><strong>主要目的</strong></td>
<td align="left"><strong>集成</strong>完整的功能或分支</td>
<td align="left"><strong>清理</strong>本地分支历史 before merging</td>
<td align="left"><strong>移植</strong>特定的修复或功能</td>
</tr>
<tr>
<td align="left"><strong>风险</strong></td>
<td align="left">低风险，安全操作</td>
<td align="left"><strong>高风险</strong>，会重写历史（<strong>不要对公共分支使用</strong>）</td>
<td align="left">中等风险，可能产生冲突，造成历史重复</td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left"><strong>合影</strong>：把两拨人叫到一起拍张新照片</td>
<td align="left"><strong>重新排队</strong>：让你和你的朋友排到另一队的最前面</td>
<td align="left"><strong>复制粘贴</strong>：把别人文章里写得好的一段话，抄到你的文章里</td>
</tr>
</tbody></table>
<hr>
<h4 id="可视化示例与场景分析"><a href="#可视化示例与场景分析" class="headerlink" title="可视化示例与场景分析"></a>可视化示例与场景分析</h4><p>假设我们从一个共同的基础提交 <code>C2</code> 开始，之后有了不同的开发线：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4 (feature)</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>

<h5 id="场景-1-使用-git-merge"><a href="#场景-1-使用-git-merge" class="headerlink" title="场景 1: 使用 git merge"></a>场景 1: 使用 <code>git merge</code></h5><p><strong>目标：将 <code>hotfix</code> 分支的更改合并到 <code>main</code> 分支。</strong></p>
<ol>
<li><code>git checkout main</code></li>
<li><code>git merge hotfix</code></li>
</ol>
<p><strong>结果：</strong> 创建一个新的合并提交 <code>M1</code>，它有两个父提交 (<code>C2</code> 和 <code>C5</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4 (feature)</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2---M1 (main)</span><br><span class="line">               \ /</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p><strong>何时使用：</strong> 这是标准操作，用于将任何完整的分支（如功能、修复、发布分支）合并回主分支。</p>
<hr>
<h5 id="场景-2-使用-git-rebase"><a href="#场景-2-使用-git-rebase" class="headerlink" title="场景 2: 使用 git rebase"></a>场景 2: 使用 <code>git rebase</code></h5><p><strong>目标：在将 <code>feature</code> 分支合并到 <code>main</code> 之前，先整理其历史，使其包含 <code>main</code> 的最新更新。</strong></p>
<ol>
<li><code>git checkout feature</code></li>
<li><code>git rebase main</code> （这会将 <code>C3</code> 和 <code>C4</code> 的更改“重新播放”在 <code>main</code> 的 <code>C2</code> 之后）</li>
</ol>
<p><strong>结果：</strong> 创建了两个新的提交 <code>C3&#39;</code> 和 <code>C4&#39;</code>，它们有新的哈希值。<code>feature</code> 分支的历史变基到了 <code>main</code> 分支的顶端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                      C3&#x27;---C4&#x27; (feature)</span><br><span class="line">                     /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p>现在，再合并 <code>feature</code> 到 <code>main</code> 会是一次快进合并，历史是线性的。<br><strong>何时使用：</strong> 在本地整理个人特性分支的历史，使其更清晰后再合并。</p>
<hr>
<h5 id="场景-3-使用-git-cherry-pick"><a href="#场景-3-使用-git-cherry-pick" class="headerlink" title="场景 3: 使用 git cherry-pick"></a>场景 3: 使用 <code>git cherry-pick</code></h5><p><strong>目标：只需要将 <code>hotfix</code> 分支上的修复 <code>C5</code> 应用到 <code>feature</code> 分支上，而不需要合并整个 <code>hotfix</code> 分支。</strong></p>
<ol>
<li><code>git checkout feature</code></li>
<li><code>git cherry-pick &lt;C5的哈希值&gt;</code></li>
</ol>
<p><strong>结果：</strong> 将 <code>C5</code> 的更改应用到 <code>feature</code> 分支，生成一个内容相同但哈希值不同的新提交 <code>C5&#39;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          C3---C4---C5&#x27; (feature) // C5&#x27; 包含了 C5 的更改</span><br><span class="line">         /</span><br><span class="line">C0---C1---C2 (main)</span><br><span class="line">               \</span><br><span class="line">                C5 (hotfix)</span><br></pre></td></tr></table></figure>
<p><strong>何时使用：</strong> 将一个紧急修复从一个分支（如 <code>production</code>）移植到另一个分支（如 <code>development</code>），而不需要执行全部分支合并。</p>
<hr>
<h4 id="如何选择？决策流程图"><a href="#如何选择？决策流程图" class="headerlink" title="如何选择？决策流程图"></a>如何选择？决策流程图</h4><p>面对整合代码的需求时，你可以遵循以下决策流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[开始：需要整合更改] --&gt; B&#123;操作对象是什么？&#125;</span><br><span class="line">    B -- 整个分支 --&gt; C&#123;目标是公共分支吗？&#125;</span><br><span class="line">    B -- 特定提交 --&gt; D[使用 git cherry-pick&lt;br&gt;移植单个修复或功能]</span><br><span class="line"></span><br><span class="line">    C -- 是 --&gt; E[使用 git merge&lt;br&gt;安全地集成，保留历史]</span><br><span class="line">    C -- 否（个人特性分支） --&gt; F&#123;想要线性历史吗？&#125;</span><br><span class="line"></span><br><span class="line">    F -- 是 --&gt; G[使用 git rebase&lt;br&gt;整理历史后再合并]</span><br><span class="line">    F -- 否 --&gt; E</span><br></pre></td></tr></table></figure>

<h4 id="黄金法则与最佳实践"><a href="#黄金法则与最佳实践" class="headerlink" title="黄金法则与最佳实践"></a>黄金法则与最佳实践</h4><ol>
<li><p>**<code>git merge</code>**：</p>
<ul>
<li><strong>用于</strong>：集成公共分支、发布版本、合并长期运行的功能分支。</li>
<li><strong>优点</strong>：安全，保留历史真相。</li>
</ul>
</li>
<li><p>**<code>git rebase</code>**：</p>
<ul>
<li><strong>黄金法则</strong>：<strong>只对你尚未推送到远程仓库的本地分支进行变基。永远不要对公共分支变基。</strong></li>
<li><strong>用于</strong>：清理本地提交历史（如压缩、修改提交信息），在合并前使历史更清晰。</li>
<li><strong>优点</strong>：创造更干净的历史。</li>
</ul>
</li>
<li><p>**<code>git cherry-pick</code>**：</p>
<ul>
<li><strong>用于</strong>：将特定的提交（如热修复）从一个分支应用到另一个分支，而不需要合并无关的更改。</li>
<li><strong>谨慎使用</strong>：过度使用会导致历史中出现重复的提交，使跟踪代码变更来源变得困难。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong> 没有哪个命令是绝对最好的，每个命令都有其特定的用途。根据你的目标（是整合、整理还是移植）和分支的公共性来做出正确选择，是高效使用 Git 的关键。</p>
<h3 id="企微sdk登录授权流程"><a href="#企微sdk登录授权流程" class="headerlink" title="企微sdk登录授权流程"></a>企微sdk登录授权流程</h3><h3 id="websocket和wss协议"><a href="#websocket和wss协议" class="headerlink" title="websocket和wss协议"></a>websocket和wss协议</h3><p>简单来说：<strong>WSS 就是 WS 的安全版本</strong>。</p>
<p>下面我们来详细解析它们的异同。</p>
<hr>
<ul>
<li>核心关系</li>
</ul>
<ul>
<li><strong>WS</strong>： <code>ws://</code> 是 WebSocket 协议的标准、<strong>非加密</strong>模式。</li>
<li><strong>WSS</strong>： <code>wss://</code> 是 WebSocket 协议的<strong>加密</strong>模式，即在 WebSocket 之上添加了一层 TLS (Transport Layer Security) 加密，也就是 SSL。</li>
</ul>
<p>它们的协议栈对比如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WS:  [WebSocket] ← 应用层</span><br><span class="line">     [   TCP    ] ← 传输层</span><br><span class="line"></span><br><span class="line">WSS: [WebSocket] ← 应用层</span><br><span class="line">     [   TLS    ] ← 安全层</span><br><span class="line">     [   TCP    ] ← 传输层</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>相同点</li>
</ul>
<ol>
<li><strong>核心协议相同</strong>： WS 和 WSS 都使用<strong>完全相同的 WebSocket 协议</strong>。一旦连接建立，数据传输的格式、数据帧结构、心跳机制（ping&#x2F;pong）、关闭握手等行为没有任何区别。</li>
<li><strong>功能特性一致</strong>： 两者都提供全双工、低延迟、持久性的通信能力。无论是 WS 还是 WSS，对开发者提供的 API（如 JavaScript 中的 <code>WebSocket</code> API）和使用方式是完全一样的。</li>
<li><strong>握手过程类似</strong>： 连接建立初期都需要一个 HTTP Upgrade 握手过程来将协议从 HTTP 升级到 WebSocket。</li>
</ol>
<hr>
<ul>
<li>不同点</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">WebSocket (WS)</th>
<th align="left">WebSocket Secure (WSS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议方案</strong></td>
<td align="left"><code>ws://</code></td>
<td align="left"><code>wss://</code></td>
</tr>
<tr>
<td align="left"><strong>默认端口</strong></td>
<td align="left">80</td>
<td align="left"><strong>443</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>不加密</strong>。所有数据（包括握手请求和所有数据帧）以<strong>明文</strong>形式在网络上传输。</td>
<td align="left"><strong>加密</strong>。在 WebSocket 协议之下增加了 <strong>TLS&#x2F;SSL</strong> 加密层。所有数据都被加密传输，防止窃听和篡改。</td>
</tr>
<tr>
<td align="left"><strong>握手过程</strong></td>
<td align="left">发送一个普通的 HTTP Upgrade 请求。</td>
<td align="left">发送一个 <strong>HTTPS</strong> Upgrade 请求。首先完成 <strong>TLS 握手</strong>，建立安全通道，然后在此安全通道内进行 WebSocket 的握手。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left"><strong>本地开发</strong>、内部网络（Intranet）或对安全性要求不高的临时环境。</td>
<td align="left"><strong>所有生产环境（Production）</strong> 和任何涉及用户隐私数据的场景（如登录态、个人消息、金融数据等）。</td>
</tr>
<tr>
<td align="left"><strong>浏览器限制</strong></td>
<td align="left">现代浏览器对混合内容（HTTPS 页面中请求 WS 资源）有<strong>严格限制</strong>，通常会<strong>阻止连接</strong>。</td>
<td align="left">是 HTTPS 页面中建立 WebSocket 连接的<strong>唯一可行方式</strong>，不会被浏览器阻止。</td>
</tr>
</tbody></table>
<hr>
<ul>
<li>为什么必须使用 WSS？</li>
</ul>
<ol>
<li><strong>数据安全</strong>：这是最主要的原因。明文传输意味着黑客可以轻易地窃听到你聊天应用里的每一条消息、你游戏中的每一个操作、你股票应用的实时交易数据。</li>
<li><strong>避免中间人攻击</strong>：没有加密，攻击者不仅可以窃听，还可以在中间篡改你发送或接收的数据。</li>
<li><strong>符合浏览器安全策略</strong>：这是<strong>至关重要</strong>的一点。如果一个页面是通过 <strong>HTTPS</strong> 协议加载的，那么浏览器会认为它是一个安全页面。此时，如果该页面中的 JavaScript 尝试去连接一个 <code>ws://</code> 的地址，浏览器会将其视为 <strong>“混合内容”</strong> 并<strong>通常直接阻止此连接</strong>，因为非加密的连接会降低整个页面的安全性。要解决这个问题，**必须使用 <code>wss://</code>**。</li>
</ol>
<p>在前端代码中，除了连接的 URL 字符串不同，API 的使用完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insecureSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://example.com/ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secureSocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://example.com/ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line">secureSocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;安全连接已建立&#x27;</span>);</span><br><span class="line">  secureSocket.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server over WSS!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">secureSocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到服务器消息: &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="SSE、websocket"><a href="#SSE、websocket" class="headerlink" title="SSE、websocket"></a>SSE、websocket</h3><ul>
<li><p>Socket： 是通信的基础工具（底层 API）。</p>
<ul>
<li>提供了一个“端点”，应用程序通过创建 Socket、绑定地址和端口、监听、连接、发送&#x2F;接收数据等步骤来建立网络连接。</li>
</ul>
<p>  特点：</p>
<ul>
<li><p>非常灵活和强大： 你可以基于 Socket 实现任何自定义的应用层协议（如 FTP、SMTP，也包括 WebSocket 和 HTTP）。</p>
</li>
<li><p>底层和复杂： 开发者需要自己处理诸如数据包重组、心跳保持、协议格式等细节。</p>
</li>
<li><p>与协议无关： Socket 既可以用于 TCP（可靠连接），也可以用于 UDP（无连接）。</p>
</li>
</ul>
</li>
<li><p>WebSocket： 是一个建立在 Socket 之上的高级协议，用于 Web 上的双向通信。</p>
<ul>
<li><p>握手： 客户端首先发送一个特殊的 HTTP 请求（带有 Upgrade: websocket 头），请求“升级”协议。</p>
</li>
<li><p>切换协议： 服务器同意后（HTTP 101响应），双方就不再使用 HTTP，而是转而使用 WebSocket 协议规定的二进制数据帧进行通信。</p>
</li>
<li><p>全双工通信： 连接持久化，服务器和客户端可以随时、独立地向对方发送数据。</p>
</li>
</ul>
</li>
<li><p>SSE： 也是一个建立在 Socket 之上的协议&#x2F;标准，用于 Web 上高效的服务器到客户端单向通信。</p>
<ul>
<li><p>客户端使用标准的 EventSource API 向服务器发起一个普通的 HTTP 请求。</p>
</li>
<li><p>服务器保持这个连接打开，并按照简单的文本格式（data: …\n\n）持续地发送数据块。</p>
</li>
<li><p>连接如果中断，EventSource API 会自动尝试重连。</p>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">SSE (Server-Sent Events)</th>
<th align="left">WebSocket</th>
<th align="left">Socket (Raw TCP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>通信方向</strong></td>
<td align="left"><strong>单向</strong> (Server → Client)</td>
<td align="left"><strong>全双工</strong> (Server ↔ Client)</td>
<td align="left">双向 (可自定义)</td>
</tr>
<tr>
<td align="left"><strong>协议基础</strong></td>
<td align="left"><strong>HTTP</strong> (长连接)</td>
<td align="left"><strong>独立的 WebSocket 协议</strong> (基于 TCP)</td>
<td align="left"><strong>TCP 或 UDP</strong></td>
</tr>
<tr>
<td align="left"><strong>复杂度</strong></td>
<td align="left">非常简单 (使用方便)</td>
<td align="left">中等 (有协议概念)</td>
<td align="left"><strong>非常复杂</strong> (需自定义所有细节)</td>
</tr>
<tr>
<td align="left"><strong>数据格式</strong></td>
<td align="left"><strong>文本</strong> (通常 UTF-8)</td>
<td align="left"><strong>文本和二进制</strong></td>
<td align="left">任意格式 (自定义)</td>
</tr>
<tr>
<td align="left"><strong>浏览器支持</strong></td>
<td align="left"><code>EventSource</code> API</td>
<td align="left"><code>WebSocket</code> API</td>
<td align="left">原生不支持，需通过其他方式（如 Node.js <code>net</code> 模块）</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">实时新闻推送、股票行情、状态更新、日志流</td>
<td align="left">聊天应用、在线游戏、实时协作编辑、高频数据交易</td>
<td align="left">自定义客户端&#x2F;服务器应用、数据库、邮件服务器等底层服务</td>
</tr>
</tbody></table>
<h3 id="微前端怎么用，有什么好处"><a href="#微前端怎么用，有什么好处" class="headerlink" title="微前端怎么用，有什么好处"></a>微前端怎么用，有什么好处</h3><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><ul>
<li>iFrame 的优势</li>
</ul>
<ol>
<li><strong>天然隔离性</strong>：iFrame 提供完全的沙箱环境，样式和JavaScript不会与主应用冲突</li>
<li><strong>简单易用</strong>：只需一个HTML标签即可嵌入完整应用，无需复杂配置</li>
<li><strong>安全性高</strong>：提供内容安全策略(CSP)支持，隔离潜在恶意代码</li>
<li><strong>零技术栈要求</strong>：可以嵌入任何类型的网页，无论其使用什么技术开发</li>
</ol>
<ul>
<li>iFrame 的劣势</li>
</ul>
<ol>
<li><p><strong>用户体验差</strong>：</p>
<ul>
<li>双重滚动条问题</li>
<li>加载状态明显，白屏时间长</li>
<li>弹窗只能限制在iFrame范围内</li>
</ul>
</li>
<li><p><strong>通信困难</strong>：</p>
<ul>
<li>只能通过<code>postMessage</code>进行通信，API简陋</li>
<li>需要自行设计复杂的通信协议</li>
</ul>
</li>
<li><p><strong>性能问题</strong>：</p>
<ul>
<li>每个iFrame需要加载完整的运行时环境(如React&#x2F;Vue)</li>
<li>资源无法在不同iFrame间共享</li>
<li>内存占用高，每个iFrame都是独立的浏览器上下文</li>
</ul>
</li>
<li><p><strong>SEO不友好</strong>：搜索引擎难以抓取iFrame中的内容</p>
</li>
<li><p><strong>路由管理复杂</strong>：iFrame内部路由变化不会反映到浏览器URL中，刷新页面可能导致状态丢失</p>
</li>
</ol>
<ul>
<li>微前端的优势</li>
</ul>
<ol>
<li><p><strong>无缝用户体验</strong>：</p>
<ul>
<li>应用切换流畅，无刷新感</li>
<li>统一的加载状态和错误处理</li>
<li>全局弹窗和通知</li>
</ul>
</li>
<li><p><strong>高效的资源利用</strong>：</p>
<ul>
<li>共享公共依赖(如React, Vue, 工具库)</li>
<li>按需加载子应用，减少初始加载时间</li>
</ul>
</li>
<li><p><strong>灵活的通信机制</strong>：</p>
<ul>
<li>可以使用任何前端状态管理方案</li>
<li>自定义事件系统，通信更直观</li>
</ul>
</li>
<li><p><strong>更好的SEO</strong>：所有内容都在同一DOM树上，易于搜索引擎索引</p>
</li>
<li><p><strong>统一的路由管理</strong>：主应用可以管理全局路由，保持URL与状态同步</p>
</li>
</ol>
<ul>
<li>微前端的劣势</li>
</ul>
<ol>
<li><strong>复杂度高</strong>：需要引入额外框架(如qiankun)，配置和维护成本高</li>
<li><strong>隔离性需要手动处理</strong>：需要解决CSS冲突和JS全局变量污染问题</li>
<li><strong>安全性依赖实现</strong>：不如iFrame的天然沙箱安全</li>
<li><strong>兼容性问题</strong>：不同技术栈间的兼容性需要额外处理</li>
</ol>
<p>使用 iFrame 更适合：</p>
<ol>
<li>嵌入完全独立的第三方应用(如地图、视频播放器)</li>
<li>需要完全隔离样式和脚本的简单嵌入需求</li>
<li>快速原型开发或对用户体验要求不高的内部工具</li>
<li>嵌入安全性未知或不可信的内容</li>
</ol>
<p> 使用微前端更适合：</p>
<ol>
<li>大型企业级应用，需要拆分多个团队独立开发</li>
<li>对用户体验和性能有较高要求的生产环境</li>
<li>需要深度融合和通信的多应用场景</li>
<li>渐进式重构遗留系统，逐步替换老模块</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>微前端 (如 qiankun&#x2F;Single-SPA)</th>
<th>iFrame</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户体验</strong></td>
<td><strong>无缝集成</strong>，保持统一的用户体验</td>
<td><strong>有明显的边界感</strong>，滚动条、加载状态独立</td>
</tr>
<tr>
<td><strong>SEO 支持</strong></td>
<td><strong>友好</strong>，内容在同一个DOM中</td>
<td><strong>不友好</strong>，搜索引擎难以索引iFrame内容</td>
</tr>
<tr>
<td><strong>通信机制</strong></td>
<td><strong>灵活多样</strong> (CustomEvent, 状态管理库等)</td>
<td><strong>受限</strong> (主要依赖 postMessage)</td>
</tr>
<tr>
<td><strong>样式控制</strong></td>
<td><strong>可统一管理</strong> (虽有隔离需求但可协调)</td>
<td><strong>天然隔离</strong>，完全独立不干扰</td>
</tr>
<tr>
<td><strong>性能表现</strong></td>
<td><strong>更优</strong>，资源可共享，切换更流畅</td>
<td><strong>较差</strong>，每个iFrame独立加载全部资源</td>
</tr>
<tr>
<td><strong>开发体验</strong></td>
<td><strong>一体化</strong>，调试、热更新更便捷</td>
<td><strong>割裂</strong>，需要单独调试每个iFrame</td>
</tr>
<tr>
<td><strong>路由管理</strong></td>
<td><strong>统一路由</strong>，保持浏览器历史记录一致</td>
<td><strong>独立路由</strong>，浏览器历史记录管理复杂</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>需要额外处理</strong> JS沙箱、CSS隔离</td>
<td><strong>天然安全沙箱</strong>，完全隔离</td>
</tr>
<tr>
<td><strong>技术栈限制</strong></td>
<td><strong>无限制</strong>，可集成任何前端框架</td>
<td><strong>无限制</strong>，可嵌入任何网页</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td><strong>较高</strong>，需要框架支持和配置</td>
<td><strong>极低</strong>，简单易用</td>
</tr>
</tbody></table>
<h3 id="小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时"><a href="#小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时" class="headerlink" title="小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时"></a>小程序中，购物车页面会有很多列表以及付钱的一个倒计时，那么应该如何按照小程序双线程的原理去进行优化倒计时</h3><ul>
<li><p>长列表</p>
<p>  使用虚拟列表：recycle-view </p>
</li>
<li><p>定时器：</p>
<p>  使用一个定时器+一个map去进行页面的显示</p>
</li>
<li><p>使用Worker处理复杂计算</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Worker处理倒计时逻辑</span></span><br><span class="line"><span class="keyword">const</span> timerWorker = wx.<span class="title function_">createWorker</span>(<span class="string">&#x27;workers/timer.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程与Worker通信</span></span><br><span class="line">timerWorker.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line"><span class="attr">action</span>: <span class="string">&#x27;init&#x27;</span>,</span><br><span class="line"><span class="attr">data</span>: countdownData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">timerWorker.<span class="title function_">onMessage</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 接收Worker传来的倒计时数据</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">countdowns</span>: res.<span class="property">countdowns</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/22/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/22/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E6%B1%87%E6%80%BB1/" class="post-title-link" itemprop="url">记录2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-22 19:01:43" itemprop="dateCreated datePublished" datetime="2025-08-22T19:01:43+08:00">2025-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-09-06 16:41:20" itemprop="dateModified" datetime="2025-09-06T16:41:20+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="a-1-a-2-a-3-为-true"><a href="#a-1-a-2-a-3-为-true" class="headerlink" title="(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 为 true"></a>(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 为 true</h3><p>当时第一想法是使用 proxy 去进行 get 时的代理，但是缺陷是使用时需要使用时需要通过<code>.value</code>获取值</p>
<p>那么可以用&#x3D;&#x3D;时，会有数据转换的特性，去重写 a 的 valueOf 即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line">a.<span class="property">valueOf</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> ++a.<span class="property">value</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="寻找缺失的最小正整数"><a href="#寻找缺失的最小正整数" class="headerlink" title="寻找缺失的最小正整数"></a>寻找缺失的最小正整数</h3><p>一开始的想法是过滤掉负数和0，然后排序再进行查找，但是这个复杂度最坏情况是nlogn + n</p>
<p>那么可以用set，然后从1开始在set中查找，如果找到就继续查找，如果没有找到就返回这个数，时间复杂度最慢是n</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组中未出现的最小正整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span> - 输入的数字数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125; - 未出现的最小正整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findSmallestMissingPositive</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> numSet = <span class="keyword">new</span> <span class="title class_">Set</span>(nums); <span class="comment">// 使用 Set 去重并快速查找</span></span><br><span class="line">    <span class="keyword">let</span> smallestMissing = <span class="number">1</span>; <span class="comment">// 初始化为最小正整数 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 1 开始递增，找到第一个未出现在 Set 中的数字</span></span><br><span class="line">    <span class="keyword">while</span> (numSet.<span class="title function_">has</span>(smallestMissing)) &#123;</span><br><span class="line">        smallestMissing++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> smallestMissing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>大O表示</th>
<th>名称</th>
<th>典型场景</th>
<th>n&#x3D;1000时操作次数</th>
<th>数据量×2时耗时变化</th>
</tr>
</thead>
<tbody><tr>
<td>O(1)</td>
<td>常数时间</td>
<td>数组随机访问、哈希表查询</td>
<td>1</td>
<td>不变</td>
</tr>
<tr>
<td>O(log n)</td>
<td>对数时间</td>
<td>二分查找、平衡树操作</td>
<td>≈10</td>
<td>增加极少 ✨</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性时间	遍历数组、链表</td>
<td>1000</td>
<td></td>
<td>×2</td>
</tr>
<tr>
<td>O(n log n)</td>
<td>线性对数时间</td>
<td>快速排序、归并排序</td>
<td>≈10,000</td>
<td>略多于×2</td>
</tr>
<tr>
<td>O(n²)</td>
<td>平方时间</td>
<td>冒泡排序、双层嵌套循环</td>
<td>1,000,000</td>
<td>×4</td>
</tr>
<tr>
<td>O(2ⁿ)</td>
<td>指数时间</td>
<td>穷举算法（如子集生成）</td>
<td>2¹⁰⁰⁰ ≈ 10³⁰⁰</td>
<td>平方级爆炸</td>
</tr>
</tbody></table>
<h3 id="员工-id-是-6-位数字，每个数字从-0-9-选一个，那么-id-开头不为-0，且相邻两个数字不相同的数据有多少"><a href="#员工-id-是-6-位数字，每个数字从-0-9-选一个，那么-id-开头不为-0，且相邻两个数字不相同的数据有多少" class="headerlink" title="员工 id 是 6 位数字，每个数字从 0-9 选一个，那么 id 开头不为 0，且相邻两个数字不相同的数据有多少"></a>员工 id 是 6 位数字，每个数字从 0-9 选一个，那么 id 开头不为 0，且相邻两个数字不相同的数据有多少</h3><p>第一位数字：不能为 0，因此有 9 种选择（1 到 9）。<br>后续每一位数字：从第二位到第六位，每个位置都不能与前一位数字相同（例如，第二位不能与第一位相同，第三位不能与第二位相同，依此类推）。由于每位有 10 个可能数字（0-9），排除前一位后，每个位置都有 9 种选择。</p>
<p>9（第一位） × 9（第二位） × 9（第三位） × 9（第四位） × 9（第五位） × 9（第六位） &#x3D; 9^6 &#x3D; 531,441</p>
<h3 id="泛型组件"><a href="#泛型组件" class="headerlink" title="泛型组件"></a>泛型组件</h3><p>泛型组件是一种不预先指定具体类型，而在使用时才指定类型的组件。</p>
<p>你可以把它理解为一个 “组件模板” 。它定义了组件的结构和逻辑，但其中涉及的数据类型可以作为参数，由使用该组件的父组件来动态决定。</p>
<ul>
<li>vue</li>
</ul>
<p>Vue 中的泛型组件允许你创建可处理多种数据类型的组件，同时保持类型安全。这在创建可复用的列表、表格或表单组件时特别有用。</p>
<p>组件参数的泛型，依据不同的参数显示不同的内容</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span> generic=<span class="string">&quot;T&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 props 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericListProps</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">items</span>: T[]</span><br><span class="line">  <span class="attr">itemRenderer</span>: <span class="function">(<span class="params"><span class="attr">item</span>: T</span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型参数</span></span><br><span class="line"><span class="keyword">const</span> props = defineProps&lt;<span class="title class_">GenericListProps</span>&lt;T&gt;&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in props.items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; itemRenderer(item) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>react</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个泛型组件 List</span></span><br><span class="line"><span class="comment">// &lt;T,&gt; 这里的逗号是为了避免与 JSX 标签混淆，告诉编译器这是泛型参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title class_">List</span>&lt;T&gt;(&#123; </span><br><span class="line">  items, </span><br><span class="line">  renderItem </span><br><span class="line">&#125;: &#123; </span><br><span class="line">  <span class="attr">items</span>: T[];</span><br><span class="line">  <span class="attr">renderItem</span>: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;items.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;renderItem(item)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">interface <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="attr">sku</span>: string;</span><br><span class="line">  <span class="attr">price</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyApp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">users</span>: <span class="title class_">User</span>[] = [ &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125; ];</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">products</span>: <span class="title class_">Product</span>[] = [ &#123; <span class="attr">sku</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">price</span>: <span class="number">9.99</span> &#125;, &#123; <span class="attr">sku</span>: <span class="string">&#x27;456&#x27;</span>, <span class="attr">price</span>: <span class="number">20.99</span> &#125; ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;/* 渲染用户列表 */&#125;</span><br><span class="line">      &lt;List&lt;User&gt; // 显式传入类型 T = User</span><br><span class="line">        items=&#123;users&#125;</span><br><span class="line">        renderItem=&#123;(user) =&gt; ( // 这里的 `user` 自动被推断为 User 类型</span><br><span class="line">          &lt;span&gt;&#123;user.name&#125; (ID: &#123;user.id&#125;)&lt;/span&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      </span><br><span class="line">      &#123;/* 渲染产品列表 */&#125;</span><br><span class="line">      &lt;List&lt;Product&gt; // 显式传入类型 T = Product</span><br><span class="line">        items=&#123;products&#125;</span><br><span class="line">        renderItem=&#123;(product) =&gt; ( // 这里的 `product` 自动被推断为 Product 类型</span><br><span class="line">          &lt;span&gt;&#123;product.sku&#125;: $&#123;product.price&#125;&lt;/span&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="vue3生命周期"><a href="#vue3生命周期" class="headerlink" title="vue3生命周期"></a>vue3生命周期</h3><table>
<thead>
<tr>
<th align="left">Vue 2 生命周期钩子</th>
<th align="left">Vue 3 生命周期钩子 (Options API)</th>
<th align="left">Vue 3 组合式 API (Composition API)</th>
<th align="left">触发时机与常见用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>beforeCreate</strong></td>
<td align="left">beforeCreate</td>
<td align="left">无</td>
<td align="left">实例初始化后，数据观测和事件&#x2F;侦听器配置之前被调用。 使用组合式 API 时，<code>setup()</code> 函数本身围绕 beforeCreate 和 created 生命周期钩子运行。</td>
</tr>
<tr>
<td align="left"><strong>created</strong></td>
<td align="left">created</td>
<td align="left">无直接对应，使用 <code>setup()</code></td>
<td align="left">实例创建完成，已完成数据观测、属性和方法的运算，watch&#x2F;event 事件回调。 此时可调用 methods 中的方法，修改 data 的数据。 使用组合式 API 时，<code>setup()</code> 函数本身围绕 beforeCreate 和 created 生命周期钩子运行。</td>
</tr>
<tr>
<td align="left"><strong>beforeMount</strong></td>
<td align="left">beforeMount</td>
<td align="left"><strong>onBeforeMount</strong></td>
<td align="left">在挂载开始之前被调用，此时模板编译完成，但尚未挂载到 DOM 上。</td>
</tr>
<tr>
<td align="left"><strong>mounted</strong></td>
<td align="left">mounted</td>
<td align="left"><strong>onMounted</strong></td>
<td align="left">实例挂载到 DOM 后调用。 适合进行<strong>DOM 操作</strong>、初始化第三方库。</td>
</tr>
<tr>
<td align="left"><strong>beforeUpdate</strong></td>
<td align="left">beforeUpdate</td>
<td align="left"><strong>onBeforeUpdate</strong></td>
<td align="left">数据变化导致虚拟 DOM 重新渲染和打补丁之前调用。 <strong>应避免在此钩子中修改状态</strong>，以免可能引发无限循环的更新。</td>
</tr>
<tr>
<td align="left"><strong>updated</strong></td>
<td align="left">updated</td>
<td align="left"><strong>onUpdated</strong></td>
<td align="left">数据变化导致虚拟 DOM 重新渲染和打补丁之后调用。 组件 DOM 已更新，可执行依赖 DOM 的操作。 <strong>同样应避免在此修改状态</strong>。</td>
</tr>
<tr>
<td align="left"><strong>beforeDestroy</strong></td>
<td align="left"><strong>beforeUnmount</strong> (Vue3 改名)</td>
<td align="left"><strong>onBeforeUnmount</strong></td>
<td align="left">实例销毁之前调用。 实例仍然完全可用。 常用于<strong>清理副作用</strong>，如定时器、事件监听器。</td>
</tr>
<tr>
<td align="left"><strong>destroyed</strong></td>
<td align="left"><strong>unmounted</strong> (Vue3 改名)</td>
<td align="left"><strong>onUnmounted</strong></td>
<td align="left">实例销毁后调用。 所有指令解绑，事件监听器移除，子实例销毁。</td>
</tr>
<tr>
<td align="left"><strong>errorCaptured</strong></td>
<td align="left">errorCaptured</td>
<td align="left"><strong>onErrorCaptured</strong></td>
<td align="left">捕获子孙组件的错误时被调用。</td>
</tr>
</tbody></table>
<h3 id="pc和h5开发不同"><a href="#pc和h5开发不同" class="headerlink" title="pc和h5开发不同"></a>pc和h5开发不同</h3><p>PC端是“功能优先”的复杂桌面体验，而H5端是“内容优先”的轻量移动体验。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">PC端 Web开发</th>
<th align="left">H5端 Web开发</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>➊ 适配与布局</strong></td>
<td align="left"><strong>复杂布局</strong>：常采用定宽、栅格化、浮动布局。可展示多列复杂内容。</td>
<td align="left"><strong>响应式&#x2F;自适应布局</strong>：必须使用<strong>响应式设计（Responsive Design）</strong>，主要采用<strong>弹性布局（Flexbox）</strong>、<strong>网格布局（Grid）</strong> 和<strong>媒体查询（Media Queries）</strong>。单位常用<code>rem</code>、<code>vw/vh</code>。</td>
</tr>
<tr>
<td align="left"><strong>➋ 交互方式</strong></td>
<td align="left"><strong>键鼠交互</strong>：支持<code>hover</code>（悬停）、<code>right-click</code>（右键）、精确点击、滚轮、键盘快捷键。</td>
<td align="left"><strong>触屏交互</strong>：主要依赖<strong>触摸事件（touch）</strong>。需考虑<strong>手势</strong>（滑动、缩放、长按）、<strong>热区大小</strong>（按钮不能小于44px）。<strong>没有hover效果</strong>。</td>
</tr>
<tr>
<td align="left"><strong>➌ 网络与性能</strong></td>
<td align="left">网络环境相对稳定（Wi-Fi、有线），带宽大。可加载更大体积的资源和脚本。</td>
<td align="left"><strong>网络不稳定</strong>（4G&#x2F;5G），<strong>带宽敏感</strong>。极度强调<strong>性能优化</strong>：资源懒加载、代码分割、图片压缩、减少HTTP请求、利用缓存（PWA）。</td>
</tr>
<tr>
<td align="left"><strong>➍ 开发技术</strong></td>
<td align="left">技术栈选择更自由，可以使用更重量的框架和库（如适用于复杂后台的ExtJS等）。</td>
<td align="left">更倾向于选择轻量、高性能的框架或方案（如Vue的运行时版本）。<strong>微信小程序&#x2F;浏览器兼容性</strong>是必须考虑的坎。</td>
</tr>
<tr>
<td align="left"><strong>➎ 功能与API</strong></td>
<td align="left">可调用一些PC特有的能力，如更大的本地存储（IndexedDB）。</td>
<td align="left">可调用丰富的<strong>设备原生API</strong>，如<strong>地理位置</strong>、<strong>摄像头</strong>、<strong>陀螺仪</strong>、<strong>振动反馈</strong>等，通过<code>HTML5</code>或JS Bridge（在WebView中）。</td>
</tr>
<tr>
<td align="left"><strong>➏ 设计理念</strong></td>
<td align="left"><strong>信息密度高</strong>：充分利用大屏幕空间，展示更多功能和信息。<strong>功能优先</strong>。</td>
<td align="left"><strong>内容优先</strong>：界面简洁，聚焦核心内容和功能，减少干扰。遵循<strong>iOS&#x2F;Android设计规范</strong>（如底部导航栏）。</td>
</tr>
<tr>
<td align="left"><strong>➐ 典型场景</strong></td>
<td align="left">后台管理系统、数据可视化大屏、复杂的SaaS应用、企业级办公系统。</td>
<td align="left">移动官网、营销活动页（H5）、新闻资讯、电商商品页、社交媒体、PWA应用。</td>
</tr>
</tbody></table>
<h4 id="1-布局与适配-最核心的区别"><a href="#1-布局与适配-最核心的区别" class="headerlink" title="1. 布局与适配 (最核心的区别)"></a>1. 布局与适配 (最核心的区别)</h4><ul>
<li><p><strong>PC端</strong>：</p>
<ul>
<li>设计师可能会给出一个<code>1200px</code>或<code>1400px</code>宽的设计稿。</li>
<li>开发时可能会让容器居中，两侧留白，或者使用多列栅格系统（如Bootstrap）进行布局。</li>
<li>示例：一个后台管理页面，左侧是固定宽度的导航菜单，右侧是主要内容区。</li>
</ul>
</li>
<li><p><strong>H5端</strong>：</p>
<ul>
<li>设计师给出的设计稿宽度通常是<code>375px</code>（iPhone 6&#x2F;7&#x2F;8标准）。</li>
<li>开发时必须使用<strong>响应式布局</strong>，确保页面从<code>375px</code>到<code>414px</code>（Plus机型）甚至更大屏手机上都能正常显示。</li>
<li>需要使用<code>&lt;meta name=&quot;viewport&quot;&gt;</code>标签控制视口，防止页面被缩放。</li>
<li>单位常用<code>rem</code>（根据根元素的<code>font-size</code>动态变化）或<code>vw/vh</code>（视窗宽度&#x2F;高度的百分比），来实现元素的自适应。</li>
<li>示例：一个新闻App的文章页，单列布局，文字大小和间距会随着屏幕宽度调整，图片宽度为100%。</li>
</ul>
</li>
</ul>
<h4 id="2-交互方式"><a href="#2-交互方式" class="headerlink" title="2. 交互方式"></a>2. 交互方式</h4><ul>
<li><p><strong>PC端</strong>：</p>
<ul>
<li><code>:hover</code>伪类被大量使用，用于菜单下拉、按钮高亮、图片放大等效果。</li>
<li>右键可以触发上下文菜单（Context Menu）。</li>
<li>可以使用复杂的键盘快捷键操作。</li>
</ul>
</li>
<li><p><strong>H5端</strong>：</p>
<ul>
<li><strong>没有hover概念</strong>，只有<code>touch</code>（触摸）和<code>click</code>（点击，有300ms延迟问题，常用<code>fastclick</code>库解决）。</li>
<li>交互依赖<strong>手势</strong>，如：<ul>
<li><strong>swipe</strong>：左右滑动切换轮播图或页面。</li>
<li><strong>pull-to-refresh</strong>：下拉刷新。</li>
<li><strong>pinch</strong>：双指缩放图片。</li>
</ul>
</li>
<li>所有可点击元素（按钮、链接）必须有足够大的尺寸（推荐不小于44x44px），防止误触。</li>
</ul>
</li>
</ul>
<h4 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h4><ul>
<li><strong>H5端对性能的要求极为苛刻</strong>。<ul>
<li><strong>加载性能</strong>：用户可能在网络很差的电梯里访问你的页面。因此要尽量减少文件体积（代码压缩、图片转WebP、Tree Shaking）、利用缓存（Service Worker）、按需加载（懒加载）。</li>
<li><strong>渲染性能</strong>：要保证页面滚动、动画的流畅度。需要避免重绘和回流，优先使用CSS3动画而非JavaScript动画，合理使用<code>will-change</code>属性等。</li>
<li><strong>PC端虽然也讲究性能，但容忍度更高</strong>，可以承受更大的初始加载时间。</li>
</ul>
</li>
</ul>
<h4 id="总结与如何选择"><a href="#总结与如何选择" class="headerlink" title="总结与如何选择"></a>总结与如何选择</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">PC端 Web</th>
<th align="left">H5端 Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思路</strong></td>
<td align="left"><strong>功能强大，体验丰富</strong></td>
<td align="left"><strong>聚焦核心，极致流畅</strong></td>
</tr>
<tr>
<td align="left"><strong>开发心态</strong></td>
<td align="left">思考如何利用好广阔的空间展示复杂功能。</td>
<td align="left">思考如何在最小的空间内，用最少的资源，提供最核心的体验。</td>
</tr>
</tbody></table>
<p><strong>现代开发实践：</strong><br>如今，纯粹的“PC站”或“H5站”越来越少。更常见的做法是：</p>
<ol>
<li><strong>响应式网站（RWD）</strong>：<strong>一套代码</strong>，通过CSS媒体查询等技术自动适配PC、平板、手机等各种屏幕尺寸。这是目前最主流的方式，成本较低，维护方便。</li>
<li><strong>独立移动站（m.site.com）</strong>：<strong>两套代码</strong>，PC端和移动端完全独立。开发成本高，但可以针对各自平台做极致的体验优化。通常通过服务器端重定向来判断设备并跳转。</li>
<li><strong>PWA（渐进式Web应用）</strong>：给H5网站赋予类似原生App的体验（如离线可用、主屏幕图标、消息推送），是H5开发的一个重要方向。</li>
</ol>
<h3 id="h5和小程序"><a href="#h5和小程序" class="headerlink" title="h5和小程序"></a>h5和小程序</h3><p>小程序前端开发和网页端开发虽然都涉及前端技术，但它们在一些关键方面有显著差异。下面是一个表格汇总了它们的核心区别，并附上了一些独特的 API 例子，希望能帮你快速了解：</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">网页 (Web) 开发</th>
<th align="left">小程序开发</th>
<th align="left">核心差异解读</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>运行环境</strong></td>
<td align="left">浏览器（多种内核）</td>
<td align="left">微信等特定 App 内部（依赖其 JavaScript 引擎和原生组件）</td>
<td align="left">小程序运行在封装好的应用环境内，<strong>无法直接操作 DOM 和 BOM</strong>，因而 jQuery、Zepto 等库通常无法使用。</td>
</tr>
<tr>
<td align="left"><strong>技术栈与文件结构</strong></td>
<td align="left">HTML + CSS + JavaScript</td>
<td align="left"><strong>WXML</strong> + <strong>WXSS</strong> + JS + JSON</td>
<td align="left">小程序使用<strong>自定义的标签</strong>（如 <code>view</code>, <code>text</code>, <code>image</code>）和<strong>特定的样式语法</strong>（如尺寸单位 <code>rpx</code>），并且有<strong>严格的文件结构要求</strong>（如每个页面通常由四个同名不同后缀的文件组成）。</td>
</tr>
<tr>
<td align="left"><strong>开发模式与数据流</strong></td>
<td align="left">可<strong>直接操作 DOM</strong>（命令式），或使用框架的声明式数据绑定</td>
<td align="left"><strong>数据驱动</strong>，通过 <code>setData</code> 方法更新视图，<strong>严禁直接操作 DOM</strong></td>
<td align="left">小程序采用 <strong>逻辑层与渲染层分离</strong> 的双线程模型，通信需通过 <code>setData</code> 和一些特定方法。</td>
</tr>
<tr>
<td align="left"><strong>API 与能力</strong></td>
<td align="left">使用标准的 <strong>Web API</strong>（如 <code>fetch</code>, <code>localStorage</code>）</td>
<td align="left">使用微信等平台封装的 <strong><code>wx.</code> 对象 API</strong>（如 <code>wx.request</code>, <code>wx.setStorage</code>），并能调用许多<strong>原生能力</strong></td>
<td align="left">小程序 API <strong>深度集成平台生态</strong>（如微信支付、分享、登录、订阅消息等），并能便捷地使用<strong>设备功能</strong>（如扫码、蓝牙、NFC等），但这些 API 的使用通常<strong>需要用户授权</strong>。</td>
</tr>
<tr>
<td align="left"><strong>开发与调试工具</strong></td>
<td align="left">编辑器（如 VSCode） + 浏览器<strong>开发者工具</strong>（功能强大）</td>
<td align="left"><strong>官方开发者工具</strong>（如微信开发者工具），集成了编辑、调试、预览、上传等功能</td>
<td align="left">小程序开发<strong>必须使用官方指定工具</strong>，其调试器的功能可能不如浏览器开发者工具全面和强大。</td>
</tr>
<tr>
<td align="left"><strong>发布与更新机制</strong></td>
<td align="left">部署到服务器即可，<strong>无需审核</strong>（自由，但也需注意合规）</td>
<td align="left">需<strong>提交到平台审核</strong>（如微信审核），通过后方可发布上线</td>
<td align="left">小程序的发布<strong>受平台规则约束</strong>，版本更新需平台审核，用户侧更新机制由平台控制。</td>
</tr>
<tr>
<td align="left"><strong>性能与限制</strong></td>
<td align="left">性能依赖浏览器优化和设备性能，<strong>资源体积无硬性限制</strong>（但过大影响体验）</td>
<td align="left"><strong>代码包有体积限制</strong>（如微信小程序主包不大于 2MB），整体包大小也有限制（如普通小程序总包不超过 20MB）。<strong>双线程通信有一定开销</strong>，但原生组件性能较好。</td>
<td align="left">小程序严格的包大小限制要求开发者<strong>精心规划资源</strong>和考虑<strong>分包加载</strong>。</td>
</tr>
</tbody></table>
<p> <strong>小程序中独特或差异较大的 API 示例</strong></p>
<p>小程序提供了一些网页开发中没有的，或者用法与 Web API 存在差异的 API，它们通常以 <code>wx.</code> 开头：</p>
<ol>
<li><p><strong>网络请求</strong>：</p>
<ul>
<li><strong>小程序</strong>：使用 <code>wx.request(Object object)</code>。</li>
<li><strong>网页</strong>：常用 <code>fetch</code> 或 <code>XMLHttpRequest</code>。</li>
<li><strong>提示</strong>：小程序网络请求的域名需要在后台配置白名单。</li>
</ul>
</li>
<li><p><strong>路由导航</strong>：</p>
<ul>
<li><strong>小程序</strong>：使用 <code>wx.navigateTo</code>（保留当前页面，跳转到应用内的某个页面）、<code>wx.redirectTo</code>（关闭当前页面，跳转到应用内的某个页面）、<code>wx.switchTab</code>（跳转到 tabBar 页面）等 API 进行页面跳转。</li>
<li><strong>网页</strong>：使用 <code>window.location</code> 或框架的路由（如 Vue Router, React Router）。</li>
</ul>
</li>
<li><p><strong>数据存储</strong>：</p>
<ul>
<li><strong>小程序</strong>：使用 <code>wx.setStorage</code>、<code>wx.getStorage</code> 等异步 API 或其 Sync 同步版本（如 <code>wx.setStorageSync</code>）。</li>
<li><strong>网页</strong>：常用 <code>localStorage</code>（同步）或 <code>indexedDB</code>（异步）。</li>
<li><strong>注意</strong>：小程序<strong>没有 Cookie 和 Session 的概念</strong>。</li>
</ul>
</li>
<li><p><strong>设备与系统能力</strong>（这些在小程序中通常更易调用）：</p>
<ul>
<li><strong>获取用户信息</strong>：<code>wx.getUserProfile</code>（注意：微信调整了相关接口的使用方式，需关注最新文档）。</li>
<li><strong>支付</strong>：<code>wx.requestPayment</code>（集成微信支付）。</li>
<li><strong>扫码</strong>：<code>wx.scanCode</code>。</li>
<li><strong>地理位置</strong>：<code>wx.getLocation</code>。</li>
<li><strong>数据缓存</strong>：如前面提到的 <code>wx.setStorage</code>。</li>
</ul>
</li>
<li><p><strong>界面交互</strong>：</p>
<ul>
<li><strong>小程序</strong>：提供了 <code>wx.showToast</code>（显示消息提示框）、<code>wx.showModal</code>（显示模态对话框）、<code>wx.showLoading</code>（显示加载提示框）等丰富的界面反馈 API。</li>
<li><strong>网页</strong>：通常使用 <code>alert</code>, <code>confirm</code>，或自己用 CSS 实现类似效果。</li>
</ul>
</li>
<li><p><strong>文件操作</strong>：</p>
<ul>
<li><strong>小程序</strong>：拥有自己的一套文件系统 API，如 <code>wx.downloadFile</code>（下载文件）、<code>wx.saveFile</code>（保存文件到本地）、<code>wx.getFileSystemManager</code>（获取全局唯一的文件管理器）等。<strong>网页</strong>中对文件系统的直接访问限制较多。</li>
</ul>
</li>
<li><p><strong>媒体操作</strong>：</p>
<ul>
<li><strong>小程序</strong>：提供了丰富的媒体 API，如 <code>wx.chooseImage</code>（从本地相册选择图片或使用相机拍照）、<code>wx.previewImage</code>（预览图片）、<code>wx.chooseVideo</code>（拍摄视频或从手机相册中选视频），以及直接操作相机和录音的 API。</li>
</ul>
</li>
<li><p><strong>获取 DOM 节点信息</strong>：</p>
<ul>
<li>由于无法直接操作 DOM，小程序提供了 <code>wx.createSelectorQuery()</code> 等方法来获取节点信息（如位置、尺寸）。</li>
</ul>
</li>
</ol>
<p> <strong>选择开发方式的一点建议</strong></p>
<ul>
<li><strong>选择小程序开发当</strong>：你的应用需要<strong>深度集成微信生态</strong>（如支付、分享、快速授权登录），追求在移动端（特别是微信内）有<strong>接近原生的流畅体验</strong>，功能相对独立、轻量，且能接受平台的审核规则和限制。</li>
<li><strong>选择网页开发当</strong>：你需要<strong>最大的开放性和灵活性</strong>，希望一次开发就能在各种有浏览器的设备上运行，<strong>不需要平台审核</strong>，或者应用非常复杂，需要利用大量现有的 Web 生态库。</li>
</ul>
<h3 id="任务队列输出"><a href="#任务队列输出" class="headerlink" title="任务队列输出"></a>任务队列输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>); <span class="comment">// 立即输出: script start</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>(); <span class="comment">// 调用 async1 函数</span></span><br><span class="line"><span class="comment">// 输出: async1 start</span></span><br><span class="line"><span class="comment">// 调用 async2，输出: async2</span></span><br><span class="line"><span class="comment">// await 后面的代码被放入微任务队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>); <span class="comment">// 立即输出: promise1</span></span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>); <span class="comment">// 回调被放入微任务队列</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>); <span class="comment">// 立即输出: script end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 async1 中 await 之后的代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>); <span class="comment">// 输出: async1 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 Promise.then 回调</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>); <span class="comment">// 输出: promise2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>); <span class="comment">// 输出: setTimeout</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/20/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%96%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/20/%E9%9D%A2%E8%AF%95/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E5%A4%96%E5%8C%85/" class="post-title-link" itemprop="url">记录1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-20 19:17:23" itemprop="dateCreated datePublished" datetime="2025-08-20T19:17:23+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-08-24 14:42:31" itemprop="dateModified" datetime="2025-08-24T14:42:31+08:00">2025-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="vite性能调优"><a href="#vite性能调优" class="headerlink" title="vite性能调优"></a>vite性能调优</h2><p>Vite 的快，主要源于其“开发环境用 ES Module，生产环境用 Rollup”的架构。</p>
<h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><ul>
<li>预构建</li>
</ul>
<p>vite 会先将你的 node_modules 中的 CommonJS 或 UMD 格式的依赖，转换为 ESM 格式并打包成一个模块，以减少浏览器请求次数。</p>
<p>因此当依赖非常多且没有esm格式时，预构建非常消耗时间</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="comment">// 强制预构建某些默认没有被包含的依赖</span></span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&#x27;some-big-dependency&#x27;</span>],</span><br><span class="line">    <span class="comment">// 排除不需要预构建的依赖（慎用，除非你确定它已经是 ESM 格式）</span></span><br><span class="line">    <span class="attr">exclude</span>: [<span class="string">&#x27;some-fast-esm-package&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产环境性能调优"><a href="#生产环境性能调优" class="headerlink" title="生产环境性能调优"></a>生产环境性能调优</h3><ul>
<li>分包</li>
</ul>
<p>如果不进行分包，所有第三方库（node_modules）都会打包到一个巨大的 vendor.js 文件中。任何业务代码的改动都会导致用户重新下载整个 vendor 文件，缓存失效。白屏时间长</p>
<p>在 vite.config.js 中配置 <code>build.rollupOptions.output.manualChunks</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 手动拆分 chunks</span></span><br><span class="line">        <span class="attr">manualChunks</span>: &#123;</span><br><span class="line">          <span class="comment">// 将 React 相关库拆分成单独的 chunk</span></span><br><span class="line">          <span class="string">&#x27;react-vendor&#x27;</span>: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">          <span class="comment">// 将组件库拆分成单独的 chunk</span></span><br><span class="line">          <span class="string">&#x27;ui-library&#x27;</span>: [<span class="string">&#x27;antd&#x27;</span>, <span class="string">&#x27;@arco-design/web-react&#x27;</span>],</span><br><span class="line">          <span class="comment">// 将工具库拆分开（也可以按更细的粒度）</span></span><br><span class="line">          <span class="string">&#x27;utils&#x27;</span>: [<span class="string">&#x27;lodash-es&#x27;</span>, <span class="string">&#x27;axios&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 或者使用函数进行更智能的拆分</span></span><br><span class="line">        <span class="comment">// manualChunks(id) &#123;</span></span><br><span class="line">        <span class="comment">//   if (id.includes(&#x27;node_modules&#x27;)) &#123;</span></span><br><span class="line">        <span class="comment">//     return &#x27;vendor&#x27;;</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>tree-shaking</p>
<ul>
<li><p>在你的项目 package.json 中设置 “sideEffects”: false，或者准确声明有副作用的文件（如 CSS、Polyfills）。</p>
<p>  <code>&quot;sideEffects&quot;: false</code>: 表示该包的所有文件都没有副作用，打包工具可以安全地移除未使用的代码。</p>
<p>  <code>&quot;sideEffects&quot;: [   &quot;*.css&quot;,   &quot;*.scss&quot;,   &quot;dist/polyfills.js&quot;   ]</code>: 表示只有匹配到的文件（如 .css 文件或 polyfills.js）具有副作用，不能被移除。其他未被引用的文件可以安全地移除。</p>
</li>
<li><p>编写：尽量使用 ESM 的 import 和 export，避免使用 CommonJS 的 require。保持代码的静态分析友好性。</p>
</li>
</ul>
</li>
<li><p>代码压缩</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">minify</span>: <span class="string">&#x27;esbuild&#x27;</span> <span class="comment">// 默认，最快。可选 &#x27;terser&#x27;，但更慢</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>esbuild</li>
</ol>
<p>含义： 使用 esbuild 进行代码压缩。<br>esbuild 是一个基于 Go 编写的极快的构建工具，性能优于传统的 JavaScript 压缩工具。</p>
<p>特点：压缩速度最快。<br>默认情况下，Vite 使用 esbuild 作为压缩工具。<br>支持基本的代码优化（如移除注释、缩短变量名等）。</p>
<p>适用场景：对构建速度要求较高，且对压缩率要求不高的项目。</p>
<ol start="2">
<li>terser</li>
</ol>
<p>含义：使用 Terser 进行代码压缩。<br>Terser 是一个成熟的 JavaScript 压缩工具，广泛应用于 Webpack 等构建工具中。</p>
<p>特点：<br>压缩率更高，能够生成更小的文件。<br>支持更复杂的优化（如死代码移除、更激进的变量名缩短等）。<br>相比 esbuild，压缩速度较慢。</p>
<p>适用场景：<br>对文件体积要求较高的项目（例如生产环境需要极致优化）。</p>
<ol start="3">
<li>false</li>
</ol>
<p>含义：<br>禁用代码压缩。<br>构建过程中不会对代码进行任何压缩处理。</p>
<p>特点：<br>构建速度最快，因为跳过了压缩步骤。<br>输出的文件是未压缩的，体积较大。</p>
<p>适用场景：<br>调试环境或开发阶段，便于直接查看未压缩的代码。<br>特殊场景下手动使用其他工具进行压缩。</p>
<ul>
<li><p>异步和延迟加载（懒加载）</p>
<ul>
<li><p>vue-router：通过import引入，每个页面会打包为独立的chunk</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;./views/Home.vue&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &#x27;/about&#x27;,</span><br><span class="line">        component: () =&gt; import(&#x27;./views/About.vue&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>defineAsynccomponent：通过defineAsyncComponent引入，每个页面会打包为独立的chunk</p>
</li>
</ul>
</li>
<li><p>分析构建产物</p>
<ul>
<li><p>rollup-plugin-visualizer</p>
</li>
<li><p>lightHouse&#x2F;WebPageTest等工具</p>
</li>
</ul>
</li>
<li><p>基于现代浏览器构建</p>
</li>
</ul>
<p>Vite 可以构建两种版本：支持现代浏览器的 ES 模块版本，和支持旧浏览器的传统版本。</p>
<p><code>@vitejs/plugin-legacy</code> 插件会为你生成传统版本的包和相应的 <code>&lt;script nomodule&gt;</code> 标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-legacy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">legacy</span>(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&#x27;defaults&#x27;</span>, <span class="string">&#x27;not IE 11&#x27;</span>] <span class="comment">// 指定目标浏览器</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vite和webpack比有什么优点"><a href="#vite和webpack比有什么优点" class="headerlink" title="vite和webpack比有什么优点"></a>vite和webpack比有什么优点</h2><h3 id="核心差异"><a href="#核心差异" class="headerlink" title="核心差异"></a>核心差异</h3><ul>
<li><p>Webpack：采用 「打包优先」 的思路。启动时，它会递归地构建所有模块的依赖关系图，将所有模块（JS、CSS、图片等）打包成一个或多个 bundle（通常是一个 vendor.js 和一个 app.js）。这个过程涉及大量的 AST 解析、代码转换和模块合并，项目越大，启动和热更新速度越慢16。</p>
</li>
<li><p>Vite：利用浏览器原生支持的 ES Modules (ESM)特性。开发阶段，Vite 启动一个服务器，浏览器直接按需请求模块。Vite 只在需要时（如请求某个模块时）编译源文件，并提供了高效的 HMR14。生产环境则使用 Rollup 进行打包14。</p>
</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>Webpack</li>
</ul>
<blockquote>
<p>优点：</p>
</blockquote>
<p>生态成熟稳定：社区庞大，拥有海量的 Loader 和 Plugin，几乎能处理任何类型的资源或满足任何构建需求（如微前端 Module Federation）168。</p>
<p>功能强大全面：对代码分割6、懒加载6、静态资源处理36、旧浏览器兼容（如 IE）3等方面支持得非常完善。</p>
<p>高度可配置：几乎能通过配置实现任何想要的构建流程，适合高度定制化的场景6。</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<p>配置复杂：学习曲线陡峭，配置文件可能非常冗长和复杂68。</p>
<p>开发体验相对较差：启动速度和热更新速度随项目增大而明显变慢，影响开发效率</p>
<ul>
<li>Vite</li>
</ul>
<blockquote>
<p>优点：</p>
</blockquote>
<p>极致的开发体验：启动速度和热更新速度极快，几乎秒开，热更新无感，大幅提升开发效率和幸福感。</p>
<p>开箱即用：对 TypeScript、JSX、CSS Modules、PostCSS 等提供原生支持，减少配置成本。</p>
<p>生产构建优化：使用 Rollup 打包，通常能生成更小体积的产出物（得益于更高效的 Tree Shaking）。</p>
<pre><code>Webpack 的 Tree Shaking 依赖于 CommonJS 和 ESM 的混合支持，导致在处理非纯 ESM 模块时可能无法完全移除无用代码。

Webpack 的模块解析机制更加复杂，可能导致额外的运行时代码（如 __webpack_require__）被引入, 需要兼容更多的浏览器环境，包括旧版浏览器（如 IE 11）。

Webpack 的 CSS 处理依赖于插件（如 mini-css-extract-plugin），可能会引入额外的运行时逻辑。

Webpack 通常需要额外的 Loader（如 file-loader 或 url-loader）来处理静态资源，增加了配置复杂性和潜在的冗余代码。

Vite 默认生成面向现代浏览器的 ES Module 构建产物，不包含旧版浏览器的兼容性代码（如 Polyfills）。

如果需要支持旧版浏览器，可以使用 @vitejs/plugin-legacy 插件，生成单独的 Legacy Bundle，避免污染现代浏览器的构建产物。

Vite 使用 PostCSS 和原生 CSS Modules，能够高效地处理样式文件，并自动进行 Tree Shaking。

Vite 使用原生的 import 语法引入静态资源，并通过 Rollup 插件优化资源路径。
</code></pre>
<blockquote>
<p>缺点：</p>
</blockquote>
<p>生态相对年轻：虽然基本需求都有覆盖，但一些特殊或复杂的场景可能找不到 Webpack 那样成熟多样的插件解决方案。</p>
<p>兼容性处理：对旧版浏览器（如 IE 11）支持不友好，需要额外配置 @vitejs&#x2F;plugin-legacy 和 polyfills。</p>
<table>
<thead>
<tr>
<th>特性维度</th>
<th>Webpack</th>
<th>Vite</th>
</tr>
</thead>
<tbody><tr>
<td>构建理念</td>
<td>打包器：提前打包所有资源，生成 bundle1</td>
<td>基于原生 ESM：开发时按需编译和服务，生产使用 Rollup</td>
</tr>
<tr>
<td>开发服务器启动</td>
<td>较慢（需先构建完整依赖图并打包）</td>
<td>极快（无需打包，直接启动服务器）</td>
</tr>
<tr>
<td>热更新 (HMR)</td>
<td>相对较慢（需重新构建变动的模块链）</td>
<td>非常快（基于 ESM，仅精确更新修改的模块）</td>
</tr>
<tr>
<td>生产构建</td>
<td>自身进行打包优化，配置复杂</td>
<td>使用 Rollup，配置简洁，Tree Shaking 高效</td>
</tr>
<tr>
<td>配置复杂度</td>
<td>高（需大量 Loader 和 Plugin 配置）</td>
<td>低（开箱即用，预设常用功能）</td>
</tr>
<tr>
<td>生态成熟度</td>
<td>非常成熟，社区庞大，插件和 Loader 丰富</td>
<td>发展中，生态不如 Webpack 丰富但增长迅速</td>
</tr>
<tr>
<td>兼容性</td>
<td>好（支持旧版浏览器、CommonJS）</td>
<td>面向现代浏览器（对旧版浏览器支持需额外处理）</td>
</tr>
</tbody></table>
<h2 id="vue2-Vite和Vue3-Vite区别"><a href="#vue2-Vite和Vue3-Vite区别" class="headerlink" title="vue2+Vite和Vue3+Vite区别"></a>vue2+Vite和Vue3+Vite区别</h2><p>将 Vue 2 项目的打包工具从 Webpack 更换为 Vite，并与 Vue 3 进行打包上的比较，同时对比 Vue 2 + Webpack 的优化，确实是一个值得关注的话题。Vite 带来的提升是显著的，但它与 Vue 3 的组合能带来更多框架层面的优化。</p>
<p>下面是一个表格，帮你快速了解 Vue 2 + Vite、Vue 3 + Vite 以及 Vue 2 + Webpack 这三者在打包上的主要区别和优化点：</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">Vue 2 + Vite (对比 Vue 2 + Webpack)</th>
<th align="left">Vue 3 + Vite (对比 Vue 2 + Vite)</th>
<th align="left">Vue 2 + Webpack (作为基准)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>构建工具与原理</strong></td>
<td align="left">开发环境基于 <strong>ESM</strong> 和 <strong>浏览器原生支持</strong>，无需打包；生产环境使用 <strong>Rollup</strong></td>
<td align="left">同 Vue 2 + Vite (Vite 特性)</td>
<td align="left">开发和生产环境均需<strong>打包和编译</strong></td>
</tr>
<tr>
<td align="left"><strong>开发服务器启动</strong></td>
<td align="left"><strong>极快</strong> (提升显著，例如从 40秒 降至 3秒 内，或从 76秒 降至 647ms)</td>
<td align="left">同 Vue 2 + Vite (Vite 特性)</td>
<td align="left"><strong>较慢</strong> (需先打包所有资源)</td>
</tr>
<tr>
<td align="left"><strong>热更新 (HMR)</strong></td>
<td align="left"><strong>更快</strong> (仅更新修改的模块)</td>
<td align="left">同 Vue 2 + Vite (Vite 特性)</td>
<td align="left"><strong>较慢</strong> (需重新构建变动的模块链)</td>
</tr>
<tr>
<td align="left"><strong>生产构建速度</strong></td>
<td align="left"><strong>更快</strong> (例如从 2分30秒 降至 40秒，或从 98秒 降至 33秒)</td>
<td align="left"><strong>可能更快</strong> (Vue 3 源码结构优化，Tree-shaking 更高效)</td>
<td align="left"><strong>较慢</strong></td>
</tr>
<tr>
<td align="left"><strong>产出物体积</strong></td>
<td align="left"><strong>可能减小</strong> (得益于 Rollup 高效的 Tree-shaking 和代码分割)</td>
<td align="left"><strong>通常更小</strong> (Vue 3 本身更轻量，Tree-shaking 效果更好，Composition API 更利于代码分割)</td>
<td align="left"><strong>较大</strong></td>
</tr>
<tr>
<td align="left"><strong>Tree-shaking</strong></td>
<td align="left"><strong>更好</strong> (Rollup 默认支持)</td>
<td align="left"><strong>最优</strong> (Vue 3 自身采用模块化设计，对 Tree-shaking 更友好)</td>
<td align="left"><strong>支持</strong> (但效果可能不如 Rollup)</td>
</tr>
<tr>
<td align="left"><strong>语法支持</strong></td>
<td align="left">需额外配置支持 Vue 2 的 <code>.vue</code> 单文件组件 (如使用 <code>vite-plugin-vue2</code>)</td>
<td align="left"><strong>原生支持</strong> Vue 3 的 <code>.vue</code> 单文件组件</td>
<td align="left">通过 <code>vue-loader</code> 支持 Vue 2</td>
</tr>
<tr>
<td align="left"><strong>代码组织与复用</strong></td>
<td align="left">Options API</td>
<td align="left"><strong>Composition API</strong> (更灵活的代码组织和复用，利于打包优化)</td>
<td align="left">Options API</td>
</tr>
<tr>
<td align="left"><strong>迁移成本</strong></td>
<td align="left"><strong>中等</strong> (主要处理 Webpack 与 Vite 的差异，如环境变量、CJS 模块、路径别名等)</td>
<td align="left"><strong>较高</strong> (如需从 Vue 2 升级至 Vue 3，涉及语法、API 和破坏性变更)</td>
<td align="left"><strong>无</strong> (基准)</td>
</tr>
</tbody></table>
<p> <strong>Vite 带来的提升（相较于 Webpack）</strong></p>
<p>从表格中可以看出，无论是 Vue 2 还是 Vue 3，从 Webpack 迁移到 Vite 都能在<strong>开发体验</strong>和<strong>构建效率</strong>上带来显著的提升：</p>
<ol>
<li><strong>开发服务器启动速度极快</strong>：Vite 利用浏览器原生 ESM 支持，在开发环境无需打包，实现秒级启动。</li>
<li><strong>热更新 (HMR) 速度更快</strong>：Vite 的 HMR 是在原生 ESM 上执行的，仅精确更新变更的模块，完全无需重新打包。</li>
<li><strong>生产构建效率提升</strong>：Vite 使用 Rollup 进行生产构建，其构建速度通常快于 Webpack。</li>
<li><strong>可能的产出物体积优化</strong>：Rollup 的 Tree-shaking 和代码分割机制非常高效，有助于减小打包体积。</li>
</ol>
<p>🔧 <strong>迁移注意事项（Vue 2 + Webpack → Vue 2 + Vite）</strong></p>
<p>虽然 Vite 好处很多，但迁移过程可能会遇到一些常见问题，需要留意：</p>
<ul>
<li><strong>环境变量</strong>：Vite 使用 <code>import.meta.env</code> 而非 Webpack 的 <code>process.env</code>，需替换。</li>
<li><strong>CommonJS 模块</strong>：Vite 开发环境默认使用 ESM。对 CJS 模块，可使用 <code>vite-plugin-commonjs</code> 或优先替换为 ESM 版本。</li>
<li><strong>Webpack 特定配置和插件</strong>：需要寻找 Vite 对应的替代方案或插件。</li>
<li><strong>路径和别名</strong>：正确配置 <code>resolve.alias</code>。</li>
<li><strong>HTML 模板</strong>：Vite 的 <code>index.html</code> 在项目根目录且需显式引入 JS [<code>&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;</code>](citation:3]。</li>
</ul>
<p> <strong>Vue 3 的额外优势（Vue 2 + Vite vs Vue 3 + Vite）</strong></p>
<p>将项目升级到 Vue 3，除了享受 Vite 带来的所有好处外，还能获得 Vue 3 本身带来的优势：</p>
<ol>
<li><p><strong>更高效的 Tree-shaking</strong>：Vue 3 的模块化设计和 Composition API 写法，使得打包工具能更有效地移除未使用的代码，进一步减小打包体积。</p>
<ul>
<li><p>vue2是一个单一的大对象，如果某些功能没有使用，但是在打包结果中也会把未使用的功能模块进行打包</p>
</li>
<li><p>vue3被彻底重写为由多个独立 ES 模块组成的集合。你可以按需导入特定的 API。</p>
</li>
<li><p>vue2使用options api，依赖于一个固定的对象结构（data, methods, computed 等）。很多语法（如 filter）是在全局定义的。构建工具很难静态分析出这些选项内部是否使用了某些全局 API，因此为了安全起见，往往不敢轻易移除任何代码。</p>
</li>
<li><p>Composition API 基于函数的导入和调用。这是一种对静态分析极度友好的模式。例如，如果你没有显式地 import { watch } from ‘vue’ 并在代码中调用它，构建工具可以 100% 确定 watch 相关的代码是“死代码”，可以安全地移除。这就是为什么 Composition API 不仅是代码组织方式的变革，更是对打包优化的一种强力支持。</p>
</li>
<li><p>Vue 3 的模板编译器能够识别出模板中使用了哪些指令或功能。它会自动为这些功能导入对应的辅助函数，而不是整个运行时库。</p>
</li>
</ul>
</li>
<li><p><strong>Composition API</strong>：除了更好的逻辑复用和代码组织，其函数式写法也更利于 Tree-shaking。</p>
</li>
<li><p><strong>更小的核心库体积</strong>：Vue 3 本身比 Vue 2 更轻量。</p>
</li>
<li><p><strong>性能优化</strong>：Vue 3 在运行时性能上的优化（如基于 Proxy 的响应式、静态提升等）虽然主要影响运行时，但也间接使得编译后的代码可能更高效。</p>
</li>
</ol>
<p>💡 <strong>总结与建议</strong></p>
<ul>
<li>如果你目前是 <strong>Vue 2 + Webpack</strong>，迁移到 <strong>Vue 2 + Vite</strong> 能带来<strong>开发体验上的巨大提升</strong>（启动和热更新极快），生产构建通常也会更快。这是<strong>性价比很高</strong>的优化手段。</li>
<li>如果在 <strong>Vue 2 + Vite</strong> 的基础上，进一步升级到 <strong>Vue 3 + Vite</strong>，则能<strong>同时享受构建工具和框架的双重优化</strong>，尤其是在打包体积和运行时性能方面会更出色，但需要评估升级 Vue 3 的成本。</li>
<li>Vite 在生产构建中默认使用 Rollup，其打包优化（如 Tree-shaking、代码分割）通常非常高效。</li>
</ul>
<h2 id="项目中如何使用ts"><a href="#项目中如何使用ts" class="headerlink" title="项目中如何使用ts"></a>项目中如何使用ts</h2><ul>
<li><p>安装 TypeScript</p>
</li>
<li><p>初始化配置文件 (tsconfig.json)</p>
</li>
</ul>
<p>TypeScript 的行为由一个名为 tsconfig.json 的文件控制。在项目根目录下生成它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tsc --init</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 tsconfig.json</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES2020&quot;</span><span class="punctuation">,</span>           <span class="comment">// 编译输出的 JavaScript 版本</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ES2020&quot;</span><span class="punctuation">,</span> <span class="string">&quot;DOM&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>     <span class="comment">// 要包含的环境 API 类型定义（如浏览器DOM）</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">,</span>           <span class="comment">// 模块系统</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span>   <span class="comment">// 模块解析策略，与 Node.js 相同</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>               <span class="comment">// 【核心】开启所有严格类型检查</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>      <span class="comment">// 更好地兼容 CommonJS 和 ES Module</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>         <span class="comment">// 跳过第三方库的类型检查，加快编译</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>              <span class="comment">// 【迁移关键】允许编译 .js 文件</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span><span class="punctuation">,</span>           <span class="comment">// 输出目录（构建时）</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./src&quot;</span><span class="punctuation">,</span>           <span class="comment">// 源文件目录</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-jsx&quot;</span>            <span class="comment">// 如果是 React 项目，处理 JSX 语法</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span>        <span class="comment">// 指定要编译的文件范围</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dist&quot;</span><span class="punctuation">]</span> <span class="comment">// 排除的文件</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“allowJs”: true：对于迁移至关重要。允许项目混合存在 .js 和 .ts 文件。</p>
<p>“strict”: true：强烈建议开启。这是 TypeScript 的核心价值，能从源头避免大量错误。</p>
<p>“skipLibCheck”: true：避免检查 node_modules 中的第三方库类型，大幅提升编译速度。</p>
<ul>
<li><p>基本类型注解: 为变量、函数参数和返回值添加类型。</p>
</li>
<li><p>使用接口 (interface) 和类型别名 (type): 用于复杂类型，例如接口返回</p>
</li>
<li><p>泛型 (Generics)：hooks多类型参数</p>
</li>
<li><p>公共类型抽离：将公共的类型定义抽离到 @&#x2F;types 或 @&#x2F;interfaces 这样的独立目录中，或者通过declara global.d.ts使得可以不通过引入就可以直接使用</p>
</li>
</ul>
<h2 id="ts怎么防止any"><a href="#ts怎么防止any" class="headerlink" title="ts怎么防止any"></a>ts怎么防止any</h2><ul>
<li>tsconfig.json添加<code>noExplicitAny: true</code>(TypeScript 4.1+)</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noExplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  <span class="comment">// 需要 TypeScript 4.1+</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ESLint</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/no-explicit-any&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/no-unsafe-assignment&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/no-unsafe-call&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/no-unsafe-member-access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@typescript-eslint/no-unsafe-return&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="vue3和vue2优化"><a href="#vue3和vue2优化" class="headerlink" title="vue3和vue2优化"></a>vue3和vue2优化</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h4><ul>
<li><p>Vue 2：</p>
<p>  在编译时，只能知道哪些节点是静态的，哪些是动态的，但无法区分动态节点中哪些是固定不变的（例如 class），每次 diff 都需要全量对比。</p>
</li>
<li><p>Vue 3：编译器会极尽所能地进行静态分析，生成优化后的虚拟 DOM 代码。</p>
<ul>
<li><p>静态提升 (Static Hoisting)：将静态的节点和属性“提升”到 render 函数之外。这意味着这些静态内容只在首次渲染时创建一次，后续更新时可以复用，完全跳过 diff 过程。</p>
</li>
<li><p>Patch 标志 (Patch Flags)：在创建动态节点时，Vue 3 会为其打上一个 &#x2F;* PatchFlag *&#x2F; 标志（一个数字），明确标识出这个节点需要被比对的类型，比如 1 代表 文本 变化，2 代表 class 变化。这样在 diff 时，可以直接跳过静态内容，只比对可能变化的动态内容，大大减少了比较范围。</p>
</li>
<li><p>树结构拍平 (Tree Flattening)：编译器会将模板中静态的子树“拍平”。这意味着在更新时，Vue 不再需要去遍历整个树结构，而是直接定位到包含动态内容的节点块（block）进行比对，效率极高。</p>
</li>
</ul>
</li>
</ul>
<h4 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h4><ul>
<li>Vue 2：使用 Object.defineProperty 来递归遍历所有属性，将其转换为 getter&#x2F;setter。它有明显的缺陷：</li>
</ul>
<p>无法检测对象属性的添加和删除，必须使用 Vue.set 和 Vue.delete。</p>
<p>对数组的索引操作和 length 修改无法监听，需要重写数组方法（如 push, pop）。</p>
<p>初始化时需要递归遍历整个对象，性能较差。</p>
<ul>
<li>Vue 3：使用 Proxy 来实现响应式，性能更好。</li>
</ul>
<p>全面拦截：可以监听到任何类型的属性变化，包括增、删、改、数组索引和 length 操作，彻底告别 Vue.set&#x2F;Vue.delete。</p>
<p>性能更好：Proxy 是在元编程层面提供的功能，性能通常优于 Object.defineProperty 的递归遍历。并且它是惰性的，只有在真正访问到某个深层属性时才会被递归转换为响应式。</p>
<p>支持 Map、Set 等集合类型：Vue 2 无法原生响应这些类型，Vue 3 可以。</p>
<h3 id="源码和体积-Bundle-Size-–treeshaking"><a href="#源码和体积-Bundle-Size-–treeshaking" class="headerlink" title="源码和体积 (Bundle Size)–treeshaking"></a>源码和体积 (Bundle Size)–treeshaking</h3><p>Vue 2：整个 Vue 库（如 vue.runtime.js）是一个大的单体，即使你只用了其中的一个 v-show 指令，也无法在打包时去掉未使用的功能（如 v-model, transition 等）。</p>
<p>Vue 3：将代码组织成多个独立的 ES 模块。构建工具（如 Webpack, Vite）可以只打包你真正用到的 API。例如，如果你没有使用 transition 组件，那么它的代码就不会出现在最终的生产包中。</p>
<p>结果：Vue 3 的核心运行时体积压缩后仅有约 10kB（gzipped），比 Vue 2 更小。</p>
<h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><ul>
<li><p>Vue 2 (Options API)：</p>
<p>  通过 data, methods, computed, watch, 生命周期 等选项来组织代码。</p>
<p>  缺点是逻辑关注点分散。一个功能相关的代码（数据、方法、计算属性、生命周期）被拆分到不同选项里，在阅读和维护成百上千行的组件时，需要上下反复滚动，非常痛苦。</p>
</li>
<li><p>Vue 3 (Composition API)：</p>
<p>  通过 setup() 函数，允许你按逻辑功能而非选项类型来组织代码。</p>
<p>  所有相关的代码（响应式数据、函数、生命周期）可以集中在一起，极大提高了代码的可读性和可维护性。它还带来了极强的逻辑复用能力（自定义组合式函数，类似于 React Hooks）。</p>
</li>
</ul>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><ul>
<li><p>Vue 2：</p>
<p>  对 TS 的支持是“嫁接”上去的，因为它的代码库本身是用 ES 写的，类型推导体验较差，需要依赖 vue-class-component 这类装饰器方案，学习成本高且不够自然。</p>
</li>
<li><p>Vue 3：</p>
<p>  完全用 TypeScript 重写。这意味着它具有一流的类型推导，组合式 API 对 TS 的支持尤其出色（因为主要是函数调用）。编写 Vue 3 + TS 组件体验非常流畅，几乎不需要额外的学习成本。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Fragment (片段)：组件可以像 React 一样有多个根节点，无需再用一个无用的 div 包裹。</p>
<p>Teleport (传送)：可以将组件的一部分模板“传送”到 DOM 的其他位置（如全局模态框、提示框），解决嵌套定位问题。</p>
<p>Suspense (实验性)：提供了一种在组件树中协调异步依赖（如异步组件、async setup()）的机制，可以优雅地处理加载状态。</p>
<h2 id="组合式api、option-api和mixins"><a href="#组合式api、option-api和mixins" class="headerlink" title="组合式api、option api和mixins"></a>组合式api、option api和mixins</h2><p>理解组合式 API (Composition API)、选项式 API (Options API) 和 Mixins 的优劣，能帮你在 Vue 开发中做出更合适的选择。我先用一个表格汇总它们的主要特点，然后详细解释。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">选项式 API (Options API)</th>
<th align="left">组合式 API (Composition API)</th>
<th align="left">Mixins</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码组织</strong></td>
<td align="left">按<strong>选项类型</strong>（data, methods等）组织，相同功能的代码<strong>分散</strong></td>
<td align="left">按<strong>逻辑功能</strong>组织，同一功能的代码<strong>集中</strong></td>
<td align="left">按<strong>功能模块</strong>组织，但多个 Mixin 的代码在组件中<strong>混合</strong></td>
</tr>
<tr>
<td align="left"><strong>逻辑复用</strong></td>
<td align="left">难以复用，通常通过 Mixins 或作用域插槽实现</td>
<td align="left"><strong>极强的复用性</strong>，通过组合式函数 (Composables) 实现，<strong>灵活清晰</strong></td>
<td align="left"><strong>一定的复用性</strong>，但容易发生<strong>命名冲突</strong>，来源不清晰</td>
</tr>
<tr>
<td align="left"><strong>TypeScript 支持</strong></td>
<td align="left">支持性<strong>一般</strong>，类型推断较弱</td>
<td align="left"><strong>一流的支持</strong>，基于函数，提供出色的类型推断</td>
<td align="left">支持性<strong>差</strong>，类型推导不友好</td>
</tr>
<tr>
<td align="left"><strong>学习成本</strong></td>
<td align="left"><strong>低</strong>，易于上手，约定大于配置</td>
<td align="left"><strong>较高</strong>，需要理解响应式 API 和函数组合的思想</td>
<td align="left"><strong>中等</strong>，概念简单但陷阱较多（如命名冲突）</td>
</tr>
<tr>
<td align="left"><strong>灵活性 &amp; 控制力</strong></td>
<td align="left"><strong>较低</strong>，受限于 Vue 的选项结构</td>
<td align="left"><strong>极高</strong>，完全是普通的 JavaScript 函数，不受组件约束</td>
<td align="left"><strong>较低</strong>，逻辑分散在多个 Mixin 中，关系不清</td>
</tr>
<tr>
<td align="left"><strong>可调试性</strong></td>
<td align="left">较容易，错误通常会在具体的选项（如 methods）中</td>
<td align="left">较容易，调用栈清晰，能明确追踪到组合式函数</td>
<td align="left"><strong>困难</strong>，当出现问题时，很难追踪到属性或方法的具体来源（是哪个 Mixin？）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>中小型项目</strong>、<strong>低复杂度组件</strong>、<strong>初学者</strong></td>
<td align="left"><strong>中大型项目</strong>、<strong>高复杂度组件</strong>、<strong>需要大量逻辑复用</strong>、<strong>追求更好TS支持和长期维护</strong></td>
<td align="left"><strong>Vue 2 项目中逻辑复用的主要方式</strong>（在 Vue 3 中已被组合式 API 取代）</td>
</tr>
</tbody></table>
<p> **选项式 API (Options API)**：它通过一些选项（如 <code>data</code>, <code>methods</code>, <code>computed</code>, <code>watch</code> 等）来组织代码。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>结构清晰，易于上手</strong>：代码放在哪个选项里有明确的约定，对初学者非常友好。</li>
<li><strong>“所见即所得”</strong>：查看一个选项（如 <code>methods</code>）就能看到组件的所有方法。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>逻辑关注点分离</strong>：当一个组件的功能变得复杂时，<strong>同一个功能的代码（数据、方法、计算属性、生命周期）会被拆分到不同的选项中</strong>。阅读和维护时需要反复上下滚动，如同“反复横跳”，体验较差。</li>
<li><strong>逻辑复用困难</strong>：本身不支持很好的逻辑复用，虽然可以通过 Mixins 实现，但会带来新问题。</li>
<li><strong>TypeScript 支持有限</strong>：与 TS 的集成体验不如 Composition API 流畅。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>小型到中型项目</strong>、<strong>逻辑不复杂的组件</strong>、<strong>刚接触 Vue 的初学者</strong>。</li>
</ul>
<p><strong>组合式 API (Composition API)<strong>： Vue 3 引入的新范式。它允许我们使用</strong>导入的 API 函数</strong>来描述组件逻辑，并采用<strong>函数</strong>的方式组织代码。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>卓越的代码组织</strong>：可以<strong>将同一个逻辑关注点的所有代码（响应式数据、函数、生命周期等）放在一起</strong>，大大提高了代码的可读性和可维护性。对于大型组件，这是巨大的优势。</li>
<li><strong>强大的逻辑复用</strong>：通过**组合式函数 (Composables)**，可以创建高度可复用、有状态逻辑的单元。它们像搭建乐高积木一样被组合到组件中，解决了 Mixins 的所有缺陷（命名冲突、来源不明确）。</li>
<li><strong>更好的 TypeScript 支持</strong>：完全是函数和变量，享受完整的类型推断，编写 Vue 组件和编写 TS 几乎没有区别。</li>
<li><strong>更灵活的代码分割</strong>：一个功能可以轻松拆分成一个独立的组合式函数。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>更高的学习曲线</strong>：需要理解 <code>ref</code>, <code>reactive</code>, <code>watch</code> 等新 API 的概念，并且思维方式要从“选项”切换到“函数组合”。</li>
<li><strong>需要更多的代码设计</strong>：选项式 API 提供了固定的结构，而组合式 API 给予了更大自由，这也意味着需要开发者自己更好地组织代码。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>中大型项目</strong>、<strong>复杂组件</strong>、<strong>需要大量逻辑复用</strong>、<strong>追求与 TypeScript 的深度融合</strong>、<strong>重视长期维护性</strong>。</li>
</ul>
<p><strong>Mixins</strong>： 是一种在 <strong>Vue 2</strong> 时代<strong>实现逻辑复用的主要方式</strong>。它允许你将组件的选项（如 <code>data</code>, <code>methods</code> 等）抽离到一个独立的对象中，然后“混合”进多个组件。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>在一定程度上的逻辑复用</strong>：在当时是解决代码复用的一种方案。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>命名冲突</strong>：如果多个 Mixin 或组件本身包含了同名的属性或方法，会发生覆盖，且调试起来非常困难。</li>
<li><strong>来源不清晰（黑盒）</strong>：在使用 Mixin 的组件中，你无法一眼看出某个属性或方法到底是来自组件自身，还是来自某个 Mixin，或者是哪个 Mixin。这极大地降低了代码的可维护性。</li>
<li><strong>不可知的属性传播</strong>：一个 Mixin 可能会向组件注入大量它不需要的属性和方法，导致组件变得臃肿且难以理解。</li>
<li><strong>糟糕的 TypeScript 支持</strong>：很难为 Mixin 提供良好的类型定义。</li>
</ul>
</li>
<li><strong>现状与适用场景</strong>：<strong>在 Vue 3 中，Composition API 被明确推荐为替代 Mixins 的首选方案</strong>。Mixins 现在主要用于<strong>遗留的 Vue 2 项目</strong>或一些非常简单的复用场景。</li>
</ul>
<h2 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h2><h3 id="构建阶段优化"><a href="#构建阶段优化" class="headerlink" title="构建阶段优化"></a>构建阶段优化</h3><ul>
<li><p>懒加载</p>
<p>  动态导入 (import(‘…’))： 会创建一个新的代码分割点。构建工具会将被导入的模块及其依赖拆分到一个独立的 chunk 文件中，这个文件只有在运行时需要时才会被浏览器加载</p>
<ul>
<li>路由懒加载：使用动态 import() 语法来定义路由</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入（不好）：构建时会打包到一起</span></span><br><span class="line"><span class="comment">// import Home from &#x27;./views/Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入（好）：会生成单独的 chunk 文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/Home.vue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">About</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/About.vue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line"><span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: <span class="title class_">About</span> &#125;,</span><br><span class="line">],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>组件懒加载：defineAsyncComponent</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HeavyComponent</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./components/HeavyComponent.vue&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖优化</p>
<p>  将很少变化的第三方库（如 vue, vue-router, lodash, element-plus）单独打包，利用浏览器缓存机制（强缓存），用户下次访问时就不再需要下载它们。</p>
<p>  在 vite.config.js 中配置 <code>build.rollupOptions.output.manualChunks</code>。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// vite.config.js</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">        <span class="attr">output</span>: &#123;</span><br><span class="line">            <span class="comment">// 手动拆分 chunks</span></span><br><span class="line">            <span class="attr">manualChunks</span>: &#123;</span><br><span class="line">            <span class="comment">// 将 React 相关库拆分成单独的 chunk</span></span><br><span class="line">            <span class="string">&#x27;react-vendor&#x27;</span>: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">            <span class="comment">// 将组件库拆分成单独的 chunk</span></span><br><span class="line">            <span class="string">&#x27;ui-library&#x27;</span>: [<span class="string">&#x27;antd&#x27;</span>, <span class="string">&#x27;@arco-design/web-react&#x27;</span>],</span><br><span class="line">            <span class="comment">// 将工具库拆分开（也可以按更细的粒度）</span></span><br><span class="line">            <span class="string">&#x27;utils&#x27;</span>: [<span class="string">&#x27;lodash-es&#x27;</span>, <span class="string">&#x27;axios&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 或者使用函数进行更智能的拆分</span></span><br><span class="line">            <span class="comment">// manualChunks(id) &#123;</span></span><br><span class="line">            <span class="comment">//   if (id.includes(&#x27;node_modules&#x27;)) &#123;</span></span><br><span class="line">            <span class="comment">//     return &#x27;vendor&#x27;;</span></span><br><span class="line">            <span class="comment">//   &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">- <span class="title class_">Tree</span> <span class="title class_">Shaking</span></span><br><span class="line"></span><br><span class="line">    在项目 package.<span class="property">json</span> 中设置 <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span>，或者准确声明有副作用的文件（如 <span class="variable constant_">CSS</span>、<span class="title class_">Polyfills</span>）</span><br><span class="line"></span><br><span class="line">- 压缩资源</span><br><span class="line"></span><br><span class="line">    - <span class="variable constant_">JS</span>/<span class="variable constant_">CSS</span> 压缩：<span class="title class_">Vite</span> 默认使用 esbuild 进行压缩，效率极高，通常无需配置。</span><br><span class="line"></span><br><span class="line">    - 图片压缩：使用 <span class="title class_">Vite</span> 插件如 vite-plugin-imagemin，或在构建流程前手动压缩图片（使用 <span class="title class_">Tinypng</span>, <span class="title class_">Squoosh</span> 等工具）。</span><br><span class="line"></span><br><span class="line">- @vitejs/plugin-legacy</span><br><span class="line"></span><br><span class="line">    通过 @vitejs/plugin-legacy 实现。它会生成两套包，现代浏览器只需加载更小的版本。</span><br><span class="line"></span><br><span class="line">    <span class="string">``</span><span class="string">` js</span></span><br><span class="line"><span class="string">    // vite.config.js</span></span><br><span class="line"><span class="string">    import legacy from &#x27;@vitejs/plugin-legacy&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    export default defineConfig(&#123;</span></span><br><span class="line"><span class="string">    plugins: [</span></span><br><span class="line"><span class="string">        legacy(&#123;</span></span><br><span class="line"><span class="string">        targets: [&#x27;defaults&#x27;, &#x27;not IE 11&#x27;], // 指定目标浏览器</span></span><br><span class="line"><span class="string">        &#125;),</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unocss：所有css融合一起，减少多余样式</p>
</li>
</ul>
<h3 id="运行优化"><a href="#运行优化" class="headerlink" title="运行优化"></a>运行优化</h3><ul>
<li><p>路由懒加载</p>
</li>
<li><p>Suspense：等待异步组件加载态</p>
</li>
<li><p>骨架屏</p>
</li>
<li><p>优化静态内容</p>
<ul>
<li><p>v-once：对纯粹静态、永远不会改变的内容使用 v-once，Vue 会将其视为静态节点，跳过后续的 diff 检查。</p>
</li>
<li><p>v-memo (Vue 3.2+)：对复杂的、有条件渲染的组件或节点进行记忆，只有在依赖项数组变化时才更新。可用于优化大型 v-for 列表。</p>
</li>
</ul>
</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ul>
<li>gzip压缩</li>
<li>协商缓存、强缓存</li>
<li>cdn</li>
</ul>
<h2 id="前端工程化理解"><a href="#前端工程化理解" class="headerlink" title="前端工程化理解"></a>前端工程化理解</h2><p>工程化是为了解决传统开发模式的根本问题：</p>
<p>效率低下：重复的手工操作（如文件合并、压缩、刷新浏览器）。</p>
<p>质量参差：代码风格不一，潜在 Bug 多，兼容性问题频发。</p>
<p>维护困难：代码结构混乱，牵一发而动全身，不敢修改。</p>
<p>协作不畅：多人开发时冲突不断，部署上线流程混乱。</p>
<p>核心组成部分：</p>
<ul>
<li><p>开发阶段</p>
<ul>
<li>模块化：从过去的 IIFE、AMD、CMD 到现在的 ES Module 成为标准，使得我们可以将代码拆分、复用、按需加载。</li>
<li>CSS 模块化：CSS-in-JS、CSS Modules 等技术解决了样式冲突、作用域和依赖管理的问题。</li>
<li>资源模块化：通过构建工具，图片、字体等资源都可以作为模块处理，并优化（压缩、转 Base64）。</li>
</ul>
</li>
<li><p>组件化</p>
<ul>
<li>将 UI 拆分为一个个独立、可复用、高内聚、低耦合的组件（如 Vue&#x2F;React 组件），这是开发复杂应用的基石。它背后是分治的软件工程思想。</li>
</ul>
</li>
<li><p>规范化 </p>
<ul>
<li>代码规范：使用 ESLint 强制统一代码风格，避免因风格不一造成的可读性问题和潜在 Bug。</li>
<li>提交规范：使用 Commitizen 或 Conventional Commits 规范 Git 提交信息，便于生成变更日志和回溯历史。</li>
<li>目录结构规范：约定好的项目结构，让任何新成员都能快速理解项目。</li>
</ul>
</li>
<li><p>自动化 </p>
<ul>
<li>构建 (Build)：这是工程化的核心。利用 Webpack、Vite、Rollup 等工具，将开发阶段的源代码（TS、Sass、Vue）转译(Transpile)、打包(Bundle)、压缩(Minify)、优化(Optimize) 成浏览器高效可执行的代码（JS、CSS、HTML）。</li>
<li>调试：借助构建工具提供的 Dev Server、Hot Module Replacement (HMR - 热更新) 等功能，获得极致的开发调试体验。</li>
</ul>
</li>
<li><p>测试与质量保障阶段</p>
<p>  单元测试 (Unit Testing)：使用 Jest、Vitest 等工具为工具函数、自定义 Hooks、组件工具逻辑编写测试，保证代码块的正确性。</p>
<p>  组件测试 (Component Testing)：使用 Testing Library、Vue Test Utils 等测试组件的渲染和交互。</p>
<p>  端到端测试 (E2E Testing)：使用 Cypress、Playwright 模拟真实用户操作，测试整个应用流程。</p>
<p>  持续集成 (Continuous Integration, CI)：通过 GitHub Actions、GitLab CI 等工具，在代码提交后自动运行 lint、测试、构建等流程，确保合并到主分支的代码是高质量的。</p>
</li>
<li><p>部署与运维阶段</p>
<p>  持续部署 (Continuous Deployment, CD)：在 CI 通过后，自动将代码部署到测试或生产环境。</p>
<p>  自动化部署：利用脚本或平台工具（如 Jenkins）实现一键或自动部署，替代手动 FTP 上传。</p>
<p>  性能监控与分析：上线后，使用 APM（应用性能监控）工具（如 Sentry）监控错误、性能指标（LCP, FCP），形成开发闭环。</p>
</li>
</ul>
<p>核心价值在于：</p>
<p>对开发者：解放生产力，聚焦业务逻辑而非繁琐流程，开发体验更愉悦。</p>
<p>对团队：降低协作成本，保证代码质量和一致性，方便新人 onboarding。</p>
<p>对产品：提升性能、稳定性和用户体验，支持快速迭代和稳定上线。</p>
<p>对公司：降低长期维护成本和风险，提升开发效率，从而节约人力成本。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E6%89%8B%E5%86%99%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E6%89%8B%E5%86%99%E9%A2%98/" class="post-title-link" itemprop="url">手写题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:33" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="将一维数组转化为-tree"><a href="#将一维数组转化为-tree" class="headerlink" title="将一维数组转化为 tree"></a>将一维数组转化为 tree</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;01&quot;</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">&quot;节点1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;011&quot;</span>, <span class="attr">parentId</span>: <span class="string">&quot;01&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;0111&quot;</span>, <span class="attr">parentId</span>: <span class="string">&quot;011&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点1-1-1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;02&quot;</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">&quot;节点2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;022&quot;</span>, <span class="attr">parentId</span>: <span class="string">&quot;02&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点2-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;023&quot;</span>, <span class="attr">parentId</span>: <span class="string">&quot;02&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点2-3&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;0222&quot;</span>, <span class="attr">parentId</span>: <span class="string">&quot;022&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;节点2-2-2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;03&quot;</span>, <span class="attr">parentId</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">&quot;节点3&quot;</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法 1：</p>
<p>使用循环+递归的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findParent</span>(<span class="params">tree, child</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> cur <span class="keyword">of</span> tree) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      cur.<span class="property">id</span> !== child.<span class="property">parentId</span> &amp;&amp;</span><br><span class="line">      cur.<span class="property">children</span> &amp;&amp;</span><br><span class="line">      cur.<span class="property">children</span>.<span class="property">length</span> !== <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      cur = <span class="title function_">findParent</span>(cur.<span class="property">children</span>, child);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.<span class="property">id</span> === child.<span class="property">parentId</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur.<span class="property">children</span>) &#123;</span><br><span class="line">        cur.<span class="property">children</span>.<span class="title function_">push</span>(child);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur.<span class="property">children</span> = [child];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrToTree</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tree = [];</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i].<span class="property">parentId</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      tree.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree = <span class="title function_">findParent</span>(tree, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法 2：</p>
<p>使用 map 映射和 js 当引用类型赋值时，是<strong>拷贝的地址</strong>的特性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">con</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> map = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">res, v</span>) =&gt;</span> ((res[v.<span class="property">id</span>] = v), res), &#123;&#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">parentId</span> <span class="keyword">in</span> map) &#123;</span><br><span class="line">      <span class="keyword">const</span> parent = map[item.<span class="property">parentId</span>];</span><br><span class="line">      parent.<span class="property">children</span> = parent.<span class="property">children</span> || [];</span><br><span class="line">      parent.<span class="property">children</span>.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="object-键扁平化"><a href="#object-键扁平化" class="headerlink" title="object 键扁平化"></a>object 键扁平化</h2><p>原始数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;b&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;d&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;d&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;e&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;f&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;g&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;f&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;h&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;i&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;g&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>转换数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;a.b.c&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;a.d&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;d&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;e.f.g&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;e.f.f.h.i&quot;</span><span class="punctuation">:</span> <span class="string">&quot;i&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;e.g&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>解法 1<br>采用 dfs 思维做</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">tree, preKey = <span class="string">&quot;&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tree !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">key</span>: preKey,</span><br><span class="line">      <span class="attr">value</span>: tree,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(tree);</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = <span class="title function_">dfs</span>(tree[key], preKey + <span class="string">&quot;.&quot;</span> + key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val)) &#123;</span><br><span class="line">      res = res.<span class="title function_">concat</span>(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ObjectKeyToStr</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="title function_">dfs</span>(obj[key], key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data)) &#123;</span><br><span class="line">      data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">        res[ele.<span class="property">key</span>] = ele.<span class="property">value</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res[data.<span class="property">key</span>] = data.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解法 2</p>
<p>采用类bfs的思路</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getKeys</span>(<span class="params">tree</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bfs</span>(<span class="params">tree</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> item = tree;</span><br><span class="line">  <span class="keyword">while</span> (item) &#123;</span><br><span class="line">    <span class="title function_">getKeys</span>(item).<span class="title function_">forEach</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> currdata = item[ele];</span><br><span class="line">      <span class="comment">// 因为额外加了_key属性，因此需要跳过这个属性</span></span><br><span class="line">      <span class="keyword">if</span> (ele !== <span class="string">&quot;_key&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(currdata) === <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">          stack.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">            ...currdata,</span><br><span class="line">            <span class="attr">_key</span>: item.<span class="property">_key</span> ? item.<span class="property">_key</span> + <span class="string">&quot;.&quot;</span> + ele : ele,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> key = item.<span class="property">_key</span> ? item.<span class="property">_key</span> + <span class="string">&quot;.&quot;</span> + ele : ele;</span><br><span class="line">          <span class="keyword">delete</span> currdata.<span class="property">_key</span>;</span><br><span class="line">          res[key] = currdata;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    item = stack.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E3%80%90%E6%89%8B%E5%86%99%E3%80%91call%E3%80%81apply%E3%80%81bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E3%80%90%E6%89%8B%E5%86%99%E3%80%91call%E3%80%81apply%E3%80%81bind/" class="post-title-link" itemprop="url">【手写】call、apply、bind</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:33" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="call"><a href="#call" class="headerlink" title="call"></a><em>call</em></h2><p>call 可以改变调用函数时的 this 指向，当调用但什么都不传入时，默认是 window 对象</p>
<h3 id="内部流程"><a href="#内部流程" class="headerlink" title="内部流程"></a>内部流程</h3><p><a target="_blank" rel="noopener" href="https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function.prototype.call">es 文档</a>上编写的流程如下:</p>
<ul>
<li><p>让一个函数 func 指向 this</p>
</li>
<li><p>如果这个函数 func 不能被调用，那么抛出 TypeError</p>
</li>
<li><p>准备尾调用 PrepareForTailCall</p>
</li>
<li><p>返回执行结果</p>
</li>
</ul>
<p>思路</p>
<ul>
<li><p>判断需要改变的 context 是否为空，如果为空，那么就默认指为 window。保留这个新的 context，作为后面函数调用时需要的 this 指向</p>
</li>
<li><p>将当前的 this 指向赋值给上一步保留的 context，作为 context 的一个属性</p>
</li>
<li><p>调用第一步保留的 context 的第二步赋值的属性函数，将所需要的参数传递给上一步新赋值的属性</p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>call</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">call_handle_writing</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// ctx指向obj，因为fn为非空</span></span><br><span class="line">  <span class="keyword">const</span> ctx = fn || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">//   ctx.cb指向的是fn1</span></span><br><span class="line">  ctx.<span class="property">cb</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">//   获取参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//   调用fn1函数，但是由于是ctx调用的，那么fn1被调用的时候的this指向是ctx</span></span><br><span class="line">  <span class="keyword">const</span> res = ctx.<span class="title function_">cb</span>(...args);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call_handle_writing</span> = call_handle_writing;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;out&quot;</span>, <span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br><span class="line">fn1.<span class="title function_">call_handle_writing</span>(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><blockquote>
<ol>
<li>Let func be the this value.</li>
<li>If IsCallable(func) is false, throw a TypeError exception.</li>
<li>If argArray is either undefined or null, then<blockquote>
<p>a. Perform PrepareForTailCall().<br /><br>b. Return ? <font color=red>Call(func, thisArg).</font></p>
</blockquote>
</li>
<li>Let argList be ? CreateListFromArrayLike(argArray).</li>
<li>Perform PrepareForTailCall().</li>
<li>Return ? Call(func, thisArg, argList).</li>
</ol>
</blockquote>
<p>其实就是接受一个数组作为参数，实际最后的调用时，调用的也是 call 方法</p>
<p>apply 调用 call 的时候，会用到扩展运算符，将参数放到 call 的参数中，因此这在一定程度上，导致了 apply 的性能会稍低于 call</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">apply_handle_writing</span>(<span class="params">fn, params</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(params)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">call_handle_writing</span>(fn, ...params);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">call_handle_writing</span>(fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply_handle_writing</span> = apply_handle_writing;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="内部流程-1"><a href="#内部流程-1" class="headerlink" title="内部流程"></a>内部流程</h3><blockquote>
<ol>
<li>Let Target be the this value.</li>
<li>If IsCallable(Target) is false, throw a TypeError exception.</li>
<li>Let F be ? BoundFunctionCreate(Target, thisArg, args).</li>
<li>Let L be 0.</li>
<li>Let targetHasLength be ? HasOwnProperty(Target, “length”).</li>
<li>If targetHasLength is true, then<blockquote>
<p>a. Let targetLen be ? Get(Target, “length”).<br/><br>b. If targetLen is a Number, then<br/></p>
<blockquote>
<p>i. If targetLen is +∞𝔽, set L to +∞.<br/></p>
<blockquote>
<p>ii. Else if targetLen is -∞𝔽, set L to 0.<br/><br>iii. Else,</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>Let targetLenAsInt be ! ToIntegerOrInfinity(targetLen).</li>
<li>Assert: targetLenAsInt is finite.</li>
<li>Let argCount be the number of elements in args.</li>
<li>Set L to max(targetLenAsInt - argCount, 0).</li>
<li>Perform SetFunctionLength(F, L).</li>
<li>Let targetName be ? Get(Target, “name”).</li>
<li>If targetName is not a String, set targetName to the empty String.</li>
<li>Perform SetFunctionName(F, targetName, “bound”).</li>
<li>Return F.</li>
</ol>
</blockquote>
<p>考虑场景：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> C = A.<span class="title function_">bind</span>(B);</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用 bind 后，使用<code>new</code>去创建一个实例，那么在<code>new</code>的时候不应该改变<code>this</code>指向</p>
<p>在返回的函数中，用<code>instanceof</code>判断是否是通过<code>new</code>方法进行调用的</p>
</li>
<li><p>调用 bind 后，在 c 上面可以调用 A 上 <code>prototype</code> 的方法</p>
<p>采用继承的方式，在返回的函数上，继承 A</p>
</li>
</ul>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bind_handle_writing</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = [...<span class="variable language_">arguments</span>, ...args];</span><br><span class="line">    fn = <span class="variable language_">this</span> <span class="keyword">instanceof</span> cb ? <span class="variable language_">this</span> : fn;</span><br><span class="line">    <span class="keyword">return</span> that.<span class="title function_">call</span>(fn, ...params);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用一个中间函数，在原型链上加一层，防止属性覆盖</span></span><br><span class="line">  <span class="keyword">const</span> buf = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  buf.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  cb.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">return</span> cb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind_handle_writing</span> = bind_handle_writing;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b540e1e17f54">如何手写一个 bind 方法</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E3%80%90wasb%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E3%80%90wasb%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">【wasb】环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:33" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/webAssembly/" itemprop="url" rel="index"><span itemprop="name">webAssembly</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="【webAsb】-Emscripten环境搭建"><a href="#【webAsb】-Emscripten环境搭建" class="headerlink" title="【webAsb】- Emscripten环境搭建"></a>【webAsb】- Emscripten环境搭建</h1><h2 id="依赖环境"><a href="#依赖环境" class="headerlink" title="依赖环境"></a>依赖环境</h2><ul>
<li><p>python</p>
</li>
<li><p>git</p>
</li>
</ul>
<p>这两项环境是必要的，否则无法进行安装</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="attr">https</span>:<span class="comment">//github.com/juj/emsdk.git</span></span><br></pre></td></tr></table></figure>
<p>下载emscripten项目</p>
<h3 id="安装依赖包等"><a href="#安装依赖包等" class="headerlink" title="安装依赖包等"></a>安装依赖包等</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd emsdk <span class="comment">// 进入项目目录中</span></span><br><span class="line">emsdk update <span class="comment">// 安装各种工具</span></span><br><span class="line">emsdk install latest <span class="comment">//下载各种包，时间比较长</span></span><br><span class="line">emsdk activate latest <span class="comment">//生成 ~/.emscripten 文件，激活配置</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pP6oCWT"><img src="https://s1.ax1x.com/2023/09/09/pP6oCWT.png" alt="pP6oCWT.png"></a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>可以先执行<code>emsdk_env</code>脚本，这个脚本默认会写入环境变量，但是也会有不成功的情况。</p>
<p>在非emsdk目录下执行<code>emcc --version</code>，判断是否报错，如果报错，就证明环境并未配置成功；如果未报错，那么环境已经配置完成啦</p>
<h4 id="环境未配置成功"><a href="#环境未配置成功" class="headerlink" title="环境未配置成功"></a>环境未配置成功</h4><ul>
<li><p>执行 <code>emcmdprompt.bat</code>命令</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pP6xUSA"><img src="https://s1.ax1x.com/2023/09/09/pP6xUSA.png" alt="pP6xUSA.png"></a></p>
</li>
<li><p>将带有<code>PATH +=</code>的路径写入环境变量的Path中</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pP6zKhQ"><img src="https://s1.ax1x.com/2023/09/09/pP6zKhQ.png" alt="pP6zKhQ.png"></a></p>
</li>
<li><p>将下面带有键值对的写入系统变量中</p>
<p>记住不能有空格，否则会执行不成功</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pP6z1cn"><img src="https://s1.ax1x.com/2023/09/09/pP6z1cn.png" alt="pP6z1cn.png"></a></p>
</li>
<li><p>在非<code>emsdk</code>目录下执行<code>emcc --version</code></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pP6zJBV"><img src="https://s1.ax1x.com/2023/09/09/pP6zJBV.png" alt="pP6zJBV.png"></a></p>
<p>环境配置成功</p>
</li>
</ul>
<h2 id="配置c-环境"><a href="#配置c-环境" class="headerlink" title="配置c++环境"></a>配置c++环境</h2><h3 id="安装配置c-c"><a href="#安装配置c-c" class="headerlink" title="安装配置c&#x2F;c++"></a>安装配置c&#x2F;c++</h3><ul>
<li><p>安装</p>
<p>安装c&#x2F;c++编译器：<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a></p>
</li>
<li><p>配置</p>
<p>在环境变量的Path中，把解压的mingw的bin目录加入进去</p>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在cmd输入<code>gcc -v</code>，没有报错即可</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pPIgD91"><img src="https://z1.ax1x.com/2023/09/21/pPIgD91.png" alt="pPIgD91.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43180456/article/details/126374156">参链</a></p>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><h3 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h3><p>建立一个cpp文件，写入c的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成js代码"><a href="#生成js代码" class="headerlink" title="生成js代码"></a>生成js代码</h3><blockquote>
<p><code>emcc test.cpp -o test.html</code></p>
</blockquote>
<p>会生成<code>html</code>，<code>js</code>和<code>wasm</code>文件，html默认引入js文件，js的作用是引入wasm文件</p>
<ul>
<li><p><code>-s</code> 表明编译到 Wasm，否则编译到 Asm.js（Wasm 的前身）， 最初 emscripten 是用于编译到 Asm.js 的。</p>
</li>
<li><p><code>SIDE_MODULE</code> 表明编译为副模块。有副模块就有主模块，简单理解副模块会去除 C 标准库函数，因为副模块会在运行时被链接到一个主模块，而主模块有C标准库函数。SIDE_MODULE的值可选 1 或者 2，前者会自动导出代码里所有的函数，而后者需要手动声明。</p>
</li>
<li><p><code>-o</code> xxxx 导出选项，导出的文件可选 .html、.js、.wasm，区别在于前面两者会帮你把胶水代码写好 ，而 .wasm 则需要在 JS 自己编写胶水代码了，但是前面两者代码冗余，比如编译为 JS 文件时，JS 文件会包含两千多行代码，不过这是学习 Wasm 的现成实例。</p>
</li>
</ul>
<h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><p>在代码路径中，搭建本地服务。在浏览器访问本地的文件会报错</p>
<ul>
<li><p><code>pnpm init</code></p>
<p>创建package.json文件</p>
</li>
<li><p><code>pnpm i http-server</code></p>
<p>安装<code>http-server</code></p>
</li>
<li><p><code>http-server -o</code></p>
<p>起本地服务，在浏览器打开html文件</p>
</li>
</ul>
<h3 id="验收"><a href="#验收" class="headerlink" title="验收"></a>验收</h3><p>用<code>http-server</code>起了本地服务后，在浏览器访问对应的域名加上生成的html文件，正常运行项目</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/pPIfE5Q"><img src="https://z1.ax1x.com/2023/09/21/pPIfE5Q.png" alt="pPIfE5Q.png"></a></p>
<h2 id="参链"><a href="#参链" class="headerlink" title="参链"></a>参链</h2><p><a target="_blank" rel="noopener" href="http://www.taodudu.cc/news/show-5750307.html?action=onClick">Emscripten编译器安装教程，亲测成功编译出第一个WebAssembly</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E3%80%90RN%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E3%80%90RN%E3%80%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">【RN】环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2025-08-14 11:18:33 / Modified: 11:18:49" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/React-Native/" itemprop="url" rel="index"><span itemprop="name">React Native</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="【React-Native】环境搭建"><a href="#【React-Native】环境搭建" class="headerlink" title="【React Native】环境搭建"></a>【React Native】环境搭建</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><p>Nodejs: <code>v16.16.0</code></p>
</li>
<li><p>react-native: <code>0.72.3</code></p>
</li>
<li><p>react-native-cli: <code>2.0.13</code></p>
</li>
<li><p>webStorm: <code>2023.1.2</code></p>
</li>
<li><p>Android Studio: <code>2022.2.1.20</code></p>
</li>
</ul>
<h2 id="基本环境配置"><a href="#基本环境配置" class="headerlink" title="基本环境配置"></a>基本环境配置</h2><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p><a target="_blank" rel="noopener" href="https://nodejs.p2hp.com/">Node.Js中文网</a></p>
<h3 id="安装react-native及其脚手架"><a href="#安装react-native及其脚手架" class="headerlink" title="安装react-native及其脚手架"></a>安装react-native及其脚手架</h3><blockquote>
<p>npm i -g react-native react-native-cli</p>
</blockquote>
<h3 id="安装Android-Studio"><a href="#安装Android-Studio" class="headerlink" title="安装Android Studio"></a>安装Android Studio</h3><p>这个是配置安卓环境的，需要配置好后，才能运行成功。</p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/">官网下载</a></p>
<p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/environment-setup">安装流程</a></p>
<ul>
<li><p>必须安装的SDK：</p>
<ul>
<li><code>Android SDK</code></li>
<li><code>Android SDK Platform</code></li>
<li><code>Android Virtual Device</code></li>
</ul>
</li>
</ul>
<p>安装过程由于下载内容较多，因此安装过程较慢。</p>
<ul>
<li><p>安装后，需要额外安装的SDK</p>
<ul>
<li><p><code>Android SDK Platform 33</code></p>
</li>
<li><p><code>Intel x86 Atom_64 System Image</code></p>
</li>
<li><p><code>Android SDK Build-Tools 33.0.0</code></p>
</li>
</ul>
<p>  从设置按钮-》settings-》Appearance &amp; Behavior -》 System Settings -》 Android SDK<br>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbGec8"><img src="https://s1.ax1x.com/2023/07/21/pCbGec8.png" alt="pCbGec8.png"></a></p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCb8Xfx"><img src="https://s1.ax1x.com/2023/07/21/pCb8Xfx.png" alt="pCb8Xfx.png"></a></p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbGJ3V"><img src="https://s1.ax1x.com/2023/07/21/pCbGJ3V.png" alt="pCbGJ3V.png"></a></p>
</li>
<li><p>配置路径</p>
<p>  在环境变量中设置以下路径：</p>
<blockquote>
<p><code>ANDROID_HOME</code>: <code>上个步骤中tab中的Android SDK Location</code></p>
</blockquote>
<p>  在<code>Path</code>的环境变量中，添加如下文案：</p>
<ul>
<li><code>%ANDROID_HOME%\platform-tools</code></li>
<li><code>%ANDROID_HOME%\emulator</code></li>
<li><code>%ANDROID_HOME%\tools</code></li>
<li><code>%ANDROID_HOME%\tools\bin</code></li>
</ul>
<p>  设置完成后，点击应用即可</p>
</li>
</ul>
<h3 id="安装webStorm"><a href="#安装webStorm" class="headerlink" title="安装webStorm"></a>安装webStorm</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv24375178/">安装教程</a></p>
<p>注：如果破解的code不生效，可以重启电脑然后再填入对应的code</p>
<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ul>
<li><p>在webStorm新建一个React Native项目</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbJkb4"><img src="https://s1.ax1x.com/2023/07/21/pCbJkb4.png" alt="pCbJkb4.png"></a></p>
</li>
<li><p>创建项目的文件目录</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbJ1qe"><img src="https://s1.ax1x.com/2023/07/21/pCbJ1qe.png" alt="pCbJ1qe.png"></a></p>
</li>
<li><p>右上角的命令的edit，进入命令的编辑页面</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbJ4LF"><img src="https://s1.ax1x.com/2023/07/21/pCbJ4LF.png" alt="pCbJ4LF.png"></a></p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbJodJ"><img src="https://s1.ax1x.com/2023/07/21/pCbJodJ.png" alt="pCbJodJ.png"></a></p>
</li>
<li><p>在Before launch的标签栏，点击+，选择<code>Run External Tool</code>，选择+</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbwt0K"><img src="https://s1.ax1x.com/2023/07/21/pCbwt0K.png" alt="pCbwt0K.png"></a></p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCbwwfH"><img src="https://s1.ax1x.com/2023/07/21/pCbwwfH.png" alt="pCbwwfH.png"></a></p>
</li>
<li><p>填写相关信息</p>
<p>  Name为该按钮的名字</p>
<p>  Program为react Native的路径，win终端命令:where react-native </p>
<p>  working directory：该输入框中,先点击右边的insert macro,选择ProjectFileDir.</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCb0mjI"><img src="https://s1.ax1x.com/2023/07/21/pCb0mjI.png" alt="pCb0mjI.png"></a></p>
<p>  填写内容：</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCb0KDP"><img src="https://s1.ax1x.com/2023/07/21/pCb0KDP.png" alt="pCb0KDP.png"></a></p>
</li>
<li><p>保存以上操作，然后执行刚刚配置好的命令</p>
<p>  <a target="_blank" rel="noopener" href="https://imgse.com/i/pCb0D5F"><img src="https://s1.ax1x.com/2023/07/21/pCb0D5F.png" alt="pCb0D5F.png"></a></p>
</li>
</ul>
<h2 id="参链"><a href="#参链" class="headerlink" title="参链"></a>参链</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://reactnative.cn/docs/environment-setup">搭建开发环境</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv24375178/">webstorm破解激活2023最新永久教程「亲测有效」</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36279113/article/details/100576426">WebStorm里配置运行React Native</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E3%80%90AST%E3%80%91-%E8%A7%A3%E6%9E%90attrs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E3%80%90AST%E3%80%91-%E8%A7%A3%E6%9E%90attrs/" class="post-title-link" itemprop="url">解析 attrs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:33" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="【AST】-解析-attrs"><a href="#【AST】-解析-attrs" class="headerlink" title="【AST】-解析 attrs"></a>【AST】-解析 attrs</h1><h2 id="考虑情况"><a href="#考虑情况" class="headerlink" title="考虑情况"></a>考虑情况</h2><ul>
<li>普通情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>=<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>空格情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>=<span class="string">&quot;a b c&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>无引号情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>无赋值情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data - a;</span><br></pre></td></tr></table></figure>

<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h3><p>1、attrs 作为一整串字符串传入，因为第二种(空格)情况的存在，不能通过空格进行数组分割</p>
<p>2、存在第二种(无引号)的情况，不能完全通过引号作为标志位进行分割</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><p>以引号和等于同时作为标志位，对字符串进行切分。引号为第一准则，等号为附用</p>
</li>
<li><p>在切分 key 与 value 时，以等号作为分割符，但还需要检查 key 中是否存在空格，如果有空格，则表示存在第四种(无赋值情况)情况</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getKeyValue</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">  <span class="comment">// 存放key-value/attr字符的数组</span></span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="comment">// 是否是有双引号的标志位</span></span><br><span class="line">  <span class="keyword">let</span> is_start = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 是否是有等号的标志位</span></span><br><span class="line">  <span class="keyword">let</span> is_equal = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 存放每个key-value的字符</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 遍历整个attrs字符串</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    str += strs[i];</span><br><span class="line">    <span class="comment">// 如果当前的字符是引号，那么表示一个attr值的开始或者结束，class=&quot;(开始)a&quot;(结束)</span></span><br><span class="line">    <span class="keyword">if</span> (strs[i] === <span class="string">`&quot;`</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果之前已经出现了引号，那么表示这个引号是attr的结束位，class=&quot;a&quot;(结束)</span></span><br><span class="line">      <span class="keyword">if</span> (is_start) &#123;</span><br><span class="line">        <span class="comment">// 那么就需要将当前收集的字符存到attr的数组中</span></span><br><span class="line">        str = str.<span class="title function_">replaceAll</span>(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        res.<span class="title function_">push</span>(str);</span><br><span class="line">        <span class="comment">// 需要重新收集，那么一切回到初始</span></span><br><span class="line">        is_start = <span class="literal">false</span>;</span><br><span class="line">        is_equal = <span class="literal">false</span>;</span><br><span class="line">        str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果之前没有引号，那么表示这个引号是attr值的开始位，class=&quot;(开始)a&quot;</span></span><br><span class="line">        is_start = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有=，但是没有&quot;表示开始，那么就表示是x=1的形式</span></span><br><span class="line">    <span class="keyword">if</span> (strs[i] === <span class="string">&quot;=&quot;</span> &amp;&amp; !is_start) &#123;</span><br><span class="line">      is_equal = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当时是空格，并且是出现过等号且没有出现过引号，那么表示是data=1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (strs[i] === <span class="string">&quot; &quot;</span> &amp;&amp; is_equal &amp;&amp; !is_start) &#123;</span><br><span class="line">      <span class="comment">// 那么就需要将当前收集的字符存到attr的数组中</span></span><br><span class="line">      res.<span class="title function_">push</span>(str);</span><br><span class="line">      <span class="comment">// 需要重新收集，那么一切回到初始</span></span><br><span class="line">      is_start = <span class="literal">false</span>;</span><br><span class="line">      is_equal = <span class="literal">false</span>;</span><br><span class="line">      str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据已经遍历完成，但是str还没有结束</span></span><br><span class="line">  <span class="keyword">if</span> (str) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> data = res.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过等号将attr的str分隔开</span></span><br><span class="line">    <span class="keyword">let</span> [key, val = <span class="string">&quot;&quot;</span>] = cur.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    <span class="comment">// 去掉key的左右空格</span></span><br><span class="line">    key = key.<span class="title function_">trim</span>();</span><br><span class="line">    <span class="comment">// 如果key还存在空格，那么就表示是data-b data=1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (key.<span class="title function_">includes</span>(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 需要将key以空格分割开</span></span><br><span class="line">      <span class="keyword">const</span> keys = key.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="comment">// 将在最后一个key之前的key都放入attrs数组里面</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre.<span class="title function_">push</span>(&#123; <span class="attr">key</span>: keys[i].<span class="title function_">trim</span>(), <span class="attr">val</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最后一个key作为对于的value值</span></span><br><span class="line">      key = keys[keys.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">trim</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在attrs里面添加attr的key及value</span></span><br><span class="line">    pre.<span class="title function_">push</span>(&#123; <span class="attr">key</span>: key.<span class="title function_">trim</span>(), <span class="attr">val</span>: val.<span class="title function_">trim</span>() &#125;);</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getKeyValue</span>( <span class="string">` class=&quot;a b  c &quot;   id=&quot;d &quot; data-b data-c data=1   data-a=&quot;111&quot; data-d`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// res(keyvalue)数组：</span></span><br><span class="line"> [<span class="string">&#x27; class=a b  c &#x27;</span>, <span class="string">&#x27;   id=d &#x27;</span>, <span class="string">&#x27; data-b data-c data=1 &#x27;</span>, <span class="string">&#x27;  data-a=111&#x27;</span>, <span class="string">&#x27; data-d&#x27;</span>]</span><br><span class="line"><span class="comment">// data结果：</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;class&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;a b  c&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;id&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;data-b&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;data-c&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;data&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;data-a&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;111&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">key</span>: <span class="string">&#x27;data-d&#x27;</span>, <span class="attr">val</span>: <span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/14/%E6%BA%90%E7%A0%81/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91vuex-%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yangxin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/14/%E6%BA%90%E7%A0%81/%E3%80%90%E6%BA%90%E7%A0%81%E3%80%91vuex-%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">vuex-执行函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-14 11:18:33" itemprop="dateCreated datePublished" datetime="2025-08-14T11:18:33+08:00">2025-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-03-06 17:08:26" itemprop="dateModified" datetime="2025-03-06T17:08:26+08:00">2025-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/vuex-%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">vuex 源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h2><p>vuex 中有三个关于 dispatch 回调的方法：</p>
<ul>
<li><p>进行初始化时 Store 中对 dispatch 的重新赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">boundDispatch</span>(<span class="params">type, payload</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, ref, <span class="variable language_">this</span> == ref);</span><br><span class="line">  <span class="keyword">return</span> dispatch.<span class="title function_">call</span>(store, type, payload);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Store 的 prototype；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Store</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">_type, _payload</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在走初始化时，注册每个 action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerAction</span>(<span class="params">store, type, handler, local</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entry = store.<span class="property">_actions</span>[type] || (store.<span class="property">_actions</span>[type] = []);</span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedActionHandler</span>(<span class="params">payload</span>) &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当在项目中调用 dispatch 时，调用顺序是依次调用的，实际调用项目的 action 函数，也是在 registerAction 中进行调用的。平时写 action 函数时的 root，就是在 registerAction 的函数中进行赋值的</p>
</li>
</ul>
<h3 id="Store-重新赋值"><a href="#Store-重新赋值" class="headerlink" title="Store 重新赋值"></a>Store 重新赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">var</span> ref = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">var</span> dispatch = ref.<span class="property">dispatch</span>;</span><br><span class="line"><span class="keyword">var</span> commit = ref.<span class="property">commit</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">boundDispatch</span>(<span class="params">type, payload</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch.<span class="title function_">call</span>(store, type, payload);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的 dispatch 主要是为了执行 dispatch 时，将其 this 确定绑定到 Store 中</p>
<h3 id="Store-原型链的-dispatch"><a href="#Store-原型链的-dispatch" class="headerlink" title="Store 原型链的 dispatch"></a>Store 原型链的 dispatch</h3><ul>
<li><p>获取到 action 对应的 type 和参数<br>传入的第一个参数可能是个 object，那么需要从 object 中取出 type 和 action 的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = <span class="title function_">unifyObjectStyle</span>(_type, _payload);</span><br><span class="line"><span class="keyword">var</span> type = ref.<span class="property">type</span>;</span><br><span class="line"><span class="keyword">var</span> payload = ref.<span class="property">payload</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> action = &#123; <span class="attr">type</span>: type, <span class="attr">payload</span>: payload &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环执行 Store 提供的 subscribeAction 回调的 before</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到所有的subscribeAction列表，过滤掉只存在before的函数并且执行</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_actionSubscribers</span></span><br><span class="line">    .<span class="title function_">slice</span>() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">    .<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">      <span class="comment">// 过滤只存在before的函数</span></span><br><span class="line">      <span class="keyword">return</span> sub.<span class="property">before</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">      <span class="comment">// 循环执行对应的函数</span></span><br><span class="line">      <span class="keyword">return</span> sub.<span class="title function_">before</span>(action, <span class="variable language_">this</span>$1.<span class="property">state</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;[vuex] error in before action subscribers: &quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行 action 函数<br>action 是一个数组，重复的 action 名称是会放到同一个 actionType 下的<br>实际这里执行的是在 registerAction 对函数进行包装了一层的 action 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result =</span><br><span class="line">  entry.<span class="property">length</span> &gt; <span class="number">1</span></span><br><span class="line">    ? <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">        entry.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">handler</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">handler</span>(payload);</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    : entry[<span class="number">0</span>](payload);</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环执行 Store 提供的 subscribeAction 回调的 after 和 error，并将 action 执行结果传给此函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 在action成功执行之后</span></span><br><span class="line">  result.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>$1.<span class="property">_actionSubscribers</span></span><br><span class="line">          .<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">            <span class="comment">// 过滤只含有after的项</span></span><br><span class="line">            <span class="keyword">return</span> sub.<span class="property">after</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环执行函数</span></span><br><span class="line">            <span class="keyword">return</span> sub.<span class="title function_">after</span>(action, <span class="variable language_">this</span>$1.<span class="property">state</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;[vuex] error in after action subscribers: &quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果出错了，就需要将错误传给error回调</span></span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>$1.<span class="property">_actionSubscribers</span></span><br><span class="line">          .<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sub.<span class="property">error</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sub.<span class="title function_">error</span>(action, <span class="variable language_">this</span>$1.<span class="property">state</span>, error);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;[vuex] error in error action subscribers: &quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="registerAction-的-action"><a href="#registerAction-的-action" class="headerlink" title="registerAction 的 action"></a>registerAction 的 action</h3><p>这个函数才是真正执行项目中写的 action 回调</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerAction</span>(<span class="params">store, type, handler, local</span>) &#123;</span><br><span class="line">  <span class="comment">// 拿到当前action列表</span></span><br><span class="line">  <span class="keyword">var</span> entry = store.<span class="property">_actions</span>[type] || (store.<span class="property">_actions</span>[type] = []);</span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedActionHandler</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是在Store.prototype.dispatch中调用action时，调用的函数</span></span><br><span class="line">    <span class="comment">// handler是项目中的action，将其this指向store</span></span><br><span class="line">    <span class="comment">// 传入root参数</span></span><br><span class="line">    <span class="keyword">var</span> res = handler.<span class="title function_">call</span>(</span><br><span class="line">      store,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">dispatch</span>: local.<span class="property">dispatch</span>,</span><br><span class="line">        <span class="attr">commit</span>: local.<span class="property">commit</span>,</span><br><span class="line">        <span class="attr">getters</span>: local.<span class="property">getters</span>,</span><br><span class="line">        <span class="attr">state</span>: local.<span class="property">state</span>,</span><br><span class="line">        <span class="attr">rootGetters</span>: store.<span class="property">getters</span>,</span><br><span class="line">        <span class="attr">rootState</span>: store.<span class="property">state</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      payload</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 如果返回结果不是一个promise，那么也包装为一个promise返回</span></span><br><span class="line">    <span class="comment">// 这里保证了在Store.prototype.dispatch的执行结果必须是个promise</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isPromise</span>(res)) &#123;</span><br><span class="line">      res = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">_devtoolHook</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        store.<span class="property">_devtoolHook</span>.<span class="title function_">emit</span>(<span class="string">&quot;vuex:error&quot;</span>, err);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>和 dispatch 一样，vuex 中关于 commit 的地方也有三个：</p>
<ul>
<li><p>进行初始化时 Store 中对 commit 的重新赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Store 的 prototype；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Store</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">commit</span>(<span class="params">_type, _payload, _options</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在走初始化时，注册每个 action</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerMutation</span>(<span class="params">store, type, handler, local</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entry = store.<span class="property">_mutations</span>[type] || (store.<span class="property">_mutations</span>[type] = []);</span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedMutationHandler</span>(<span class="params">payload</span>) &#123;</span><br><span class="line">    handler.<span class="title function_">call</span>(store, local.<span class="property">state</span>, payload);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当在项目中调用 commit 时，调用顺序是依次调用的，实际调用项目的 commit 函数，也是在 registerMutation 中进行调用的。平时写 commit 函数时的 state，就是在 registerMutation 的函数中进行赋值的</p>
</li>
</ul>
<h3 id="Store-重新赋值-1"><a href="#Store-重新赋值-1" class="headerlink" title="Store 重新赋值"></a>Store 重新赋值</h3><p>作用和 dispatch 一样，也是确保执行的 this 指向 Store</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">commit</span> = <span class="keyword">function</span> <span class="title function_">boundCommit</span>(<span class="params">type, payload, options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> commit.<span class="title function_">call</span>(store, type, payload, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Store-prototype-commit"><a href="#Store-prototype-commit" class="headerlink" title="Store.prototype.commit"></a>Store.prototype.commit</h3><ul>
<li><p>和 dispatch 一样，将传入的参数格式化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">this</span>$1 = <span class="variable language_">this</span>;</span><br><span class="line"><span class="comment">// check object-style commit</span></span><br><span class="line"><span class="keyword">var</span> ref = <span class="title function_">unifyObjectStyle</span>(_type, _payload, _options);</span><br><span class="line"><span class="keyword">var</span> type = ref.<span class="property">type</span>;</span><br><span class="line"><span class="keyword">var</span> payload = ref.<span class="property">payload</span>;</span><br><span class="line"><span class="keyword">var</span> options = ref.<span class="property">options</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutation = &#123; <span class="attr">type</span>: type, <span class="attr">payload</span>: payload &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 commit<br>先获取到 commit 列表，然后执行 commit 函数，和 dispatch，这里执行的也是 registerMutation 中的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entry = <span class="variable language_">this</span>.<span class="property">_mutations</span>[type];</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  entry.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">commitIterator</span>(<span class="params">handler</span>) &#123;</span><br><span class="line">    <span class="title function_">handler</span>(payload);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>_withCommit<br>这里将 Store 的_committing 置为 true，然后再去对应的 commit<br>因此可以通过 Store 的<code>_committing</code>字段来判断是否是通过 commit 进行的数据修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Store</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_withCommit</span> = <span class="keyword">function</span> <span class="title function_">_withCommit</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> committing = <span class="variable language_">this</span>.<span class="property">_committing</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_committing</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">  <span class="comment">// 执行之后重置数据</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_committing</span> = committing;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>执行 subscribe 列表<br>commit 执行结束之后，循环执行 subscribe 列表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_subscribers</span></span><br><span class="line">  .<span class="title function_">slice</span>() <span class="comment">// shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe</span></span><br><span class="line">  .<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sub</span>(mutation, <span class="variable language_">this</span>$1.<span class="property">state</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>输出日志<br>如果commit的时候，第三个参数是带有silent的，那么会输出一行日志</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&quot;production&quot;</span> &amp;&amp; options &amp;&amp; options.<span class="property">silent</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">    <span class="string">&quot;[vuex] mutation type: &quot;</span> +</span><br><span class="line">      type +</span><br><span class="line">      <span class="string">&quot;. Silent option has been removed. &quot;</span> +</span><br><span class="line">      <span class="string">&quot;Use the filter functionality in the vue-devtools&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="registerMutation"><a href="#registerMutation" class="headerlink" title="registerMutation"></a>registerMutation</h3><p>实际情况下，action和commit都是被拉平了的，那么这里如何确保在执行的时候，传入项目的commit函数state的对应module下的呢？</p>
<p>执行registerMutation的函数是在installModule，进行forEachMutation时调用的，在这个时候调用registerMutation传入的module。这个情况下，因为还在对每个模块进行遍历，模块是单独独立的，然后在执行wrappedMutationHandler时，由于闭包的特性，所以访问的local是没有被污染的真实的module</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerMutation</span> (<span class="params">store, type, handler, local</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entry = store.<span class="property">_mutations</span>[type] || (store.<span class="property">_mutations</span>[type] = []);</span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedMutationHandler</span> (<span class="params">payload</span>) &#123;</span><br><span class="line">    <span class="comment">// 主要是这里执行项目中真正编写的commit函数</span></span><br><span class="line">    <span class="comment">// 也是这里将module的state传入的</span></span><br><span class="line">    handler.<span class="title function_">call</span>(store, local.<span class="property">state</span>, payload);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yangxin</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
