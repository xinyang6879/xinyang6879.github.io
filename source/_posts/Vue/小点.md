---
title: 小点
categories: vue
---

### 渐进式框架理解

渐进式表示: 没有做过多的事情,vuejs只提供了最核心的组件系统和双向数据绑定,pinia、vue-router都是围绕vuejs开发的库

如果使用react还需要理解:
- 函数时编程理念
- 副作用
- 什么是纯函数
- 如何隔离避免副作用

### 组件之间传值方式

父向子
- props
- inject
- vuex
- 调用子组件实例的方法+defineExpose

子向父

- emit
- 引用类型可以修改或者用Vue.set
- vuex

### v-if和v-show区别

相同点:

都是vuejs中用于控制元素是否显示的指令

不同点:

- v-if是在节点中都没有这个元素, 动态向dom树添加或者删除这个节点; v-show是使用了display:none让元素不显示
- v-if切换是有一个局部编译/卸载的过程,切换过程中适当销毁和重建内部的事件监听和子组件;而v-show只是css切换
- 在初始编译过程中,v-if如果是false那么就不会编译,v-show都会编译
- v-if切换是会销毁和创建;v-show只编译一次.因此v-show性能更好(如果存在多次切换条件)

v-if判断是否加载,可以减轻服务器压力,但在需要加载时,会由更高的切换开销

v-show跳转dom的style属性,可以使得用户操作更加流畅,但由更高的初始渲染开销

### vue的计算属性

设计初衷是用于简单运算,在computed中放入太多逻辑会让模板过重且难以维护

用法:

- 在一个计算属性中可以完成各种复杂的逻辑,包括运算和函数调用等,只要最终返回一个结果即可
- 计算属性可以依赖多个vue实例的数据,只要其中任一数据变化,计算属性就会重新执行,视图也会更新

getter和setter

每个计算属性都包括一个getter和setter,通常使用的都是computed的默认用法,只是利用了getter来读取.在用户需要时,可以提供一个setter函数,当手动修改computed的值就像修改一个普通数据那样时,就会触发setter

computed缓存

computed会有对数据的缓存,多次使用同一个computed不会重复计算,除非数据变化.

其基于computed的依赖进行缓存的,计算属性只有在其相关依赖发生改变时才会重新求值

### vue-router有哪几种导航钩子

守卫类型

- 全局守卫: router.beforeEach(to, from, next)

    当一个导航触发时,其会按照创建顺序调用.守卫是异步解析执行,此时导航在所有守卫resolve完之前一直处于等待状态
- 全局解析守卫: router.beforeResolve(to, from, next)

    在全局解析守卫中可以使用beforeResolve注册一个全局守卫.和beforeEach类似,但其在导航被确认之前,同时在所有组件内守卫和异步路由组件被解析之后调用

- 全局后置钩子: router.afterEach(to, from)

    也可以注册全局后置钩子,但这个没有next,也无法改变导航本身
- 路由独享的守卫: beforeEnter

    可以在路由配置这个函数
- 组件内的守卫: beforeRouteUpdate,beforeRouteEnter,  beforeRouterLeave

参数:

to(即将要进入的页面路由对象), 

from(从哪儿来的页面路由对象), 

next(一定要调用这个方法来resolve这个钩子,否则页面会一直等待)

### vue-router导航解析流程

- 导航被触发
- 调用离开组件的beforeRouterLeave钩子
- 调用全局的beforeEach函数
- 在重用的组件调用beforeRouteUpdate
- 在路由配置中调用beforeEnter
- 解析异步路由组件
- 调用组件的beforeRouteEnter
- 调用全局的beforeResolve
- 导航被确认
- 调用全局的afterEach
- 触发DOM更新
- 用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数
