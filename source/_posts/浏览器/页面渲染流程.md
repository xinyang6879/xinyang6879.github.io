---
title: 页面渲染流程
categories: 浏览器
tag: 浏览器
---

## 从输入url到页面渲染浏览器流程

- 输入url回车
    - 触发BeforeUnload事件（允许当前页阻止导航
- 判断是ip还是网址，如果是网站，需要去进行dns查询。浏览器先检查缓存（Service Worker、HTTP Cache等）
    - dns预解析
    - dns查询流程
- 进行网络请求
    - tcp三次握手
    - http1、http2和http3
    - ssl加密
- 获取到html后，开始进行解析
- 开始解析html，如果这个html文件遇到被分片的情况，浏览器不会等到所有的html全部接收到之后再进行解析，而是拿到一部分之后就已经开始解析了
- 解析过程中，如果遇到资源，那么就开始进行资源的加载（除了defer、async和preload的资源
- html解析完成后，然后生成一个DOM树，JS在DOMContentLoaded事件前defer加载的资源
    - js执行过程中，会阻塞html的渲染，因为js可能会修改dom的位置
- 开始解析css，生成一个css树
    - css会影响元素样式，js中可能会获取元素的样式，为了保证js获取的样式无问题，因此css可能会影响到js的执行
- css和dom树进行叠加，得出一个渲染树
    - 仅包含可见节点（排除display:none等）
    - @font-face外部字体加载时机：在构建渲染树时，如果遇到非空节点，那么才会进行字体文件的加载；如果整个文件都没有文本，那么即使引入了字体文件，也不会去加载这个字体文件
- 浏览器并不知道每个元素应该在什么位置，因此会遍历一次渲染树，把元素位置、大小等转为屏幕上的绝对像素，css和模型、flex等是在这个时候执行的，得到一个布局树
- 页面开始渲染，在渲染过程前，会依据每个元素的层级（zindex、3d变换等），进行分层，在每层上进行对应元素的绘制
    - 分层通常发生在布局之后、绘制之前。
    - 浏览器引擎（如Blink）在布局完成后，会根据特定规则（不仅是z-index和transform: translate3d/scale3d/rotate3d，还包括willchange、opacity < 1、filter、position: fixed、<video>/<canvas>等）决定将渲染树中的某些部分提升为独立的合成层（Compositing Layer）
- 分层完成后，主线程为每个合成层生成一个绘制记录（Paint Record）（包含绘制该层所需的所有绘制指令）。然后，主线程将这些层信息（包括绘制记录）提交（Commit）给合成线程（Compositor Thread）。合成线程将层划分为更小的图块（Tiles）。光栅化线程（Raster Threads）（通常在GPU进程中）负责将每个图块的绘制指令光栅化（Rasterize） 成GPU内存中的位图纹理（Bitmap Texture）。
    - 浏览器不会无限创建层。层过多会消耗大量内存（特别是GPU内存）和管理开销。浏览器有启发式规则来决定何时真正提升一个元素为合成层（即使有will-change等提示）。不必要的层提升（层爆炸）反而可能损害性能。
- 获取到所有图层后，开始进行页面的绘制，将每个元素的信息输出为具体的像素点，这个过程成为光栅化
    - 绘制（Painting）：也称为 栅格化（Rasterization） 的前一步。主线程遍历层（Layer）（更准确地说，是遍历层内的绘制指令列表），将元素的视觉表现（颜色、边框、文本、阴影等）转换成一系列绘制指令（Draw Commands）。这些指令描述的是“画什么”和“在哪里画”（相对于层本身），但还不是最终像素。
    - 绘制指令被实际执行，转换成位图像素的过程。这通常发生在合成线程（Compositor Thread） 控制下，由光栅化线程（Raster Threads）（通常是GPU进程中的线程）执行。输入是绘制指令，输出是存储在GPU内存中的纹理（Texture）（即包含RGBA像素数据的位图）。光栅化通常是按图块（Tiles） 进行的。
- 每个层绘制完成后，会进行合并，这个过程称为合成   
- 合成线程把得到的层分块，然后把需要渲染的块交给光栅化线程，由其完成分块的光栅化并储存在gpu中
- 光栅化线程结束后，合成线程会把这些得到的创建一个合成帧，直接发送给GPU完成屏幕的显示
    - 合成线程生成一个合成帧（Compositor Frame），其中包含如何将这些纹理组合（合成）成最终屏幕图像的指令（通常是描述一个场景图的 Quad 信息）
    - 这个合成帧被提交给浏览器进程（Browser Process）。
    - 浏览器进程通过VIZ组件将合成帧数据（通过IPC）传递给GPU进程。
    - GPU进程的GPU线程最终驱动GPU硬件执行合成（Compositing） 操作：将各个图块纹理按照合成帧的指令，通过OpenGL/DirectX/Vulkan API绘制到后缓冲区（Back Buffer）。
    - 最后，GPU发出垂直同步（VSync） 信号时，系统（通常是窗口管理器或显示服务器）将后缓冲区交换（Swap） 到前缓冲区（Front Buffer），完成屏幕的显示（Display）。
    - 总结流向： 合成线程 -> (合成帧) -> 浏览器进程 -> GPU进程 (GPU线程) -> GPU硬件 -> 屏幕。
- 当页面滚动和纯合成动画发生时，合成器只需要重新合成一个合成帧，并发送给GPU即可，此时就不再需要主线程的参与
- 纯合成动画高度依赖gpu，不影响页面的主线程，因此其会有更好的性能；解析、执行js、重新布局等依赖主线程完成的动画都不是纯合成动画，因此性能会比其更差些
    - 纯合成动画通常既不触发重排也不触发重绘，只触发合成

主线程  dom -> 计算样式 -> 布局 -> 分层 ⬇

合成线程                           分层->    分块 ⬇     光栅化-> 合成⬇

光栅化线程                                  分块 -> 光栅化 ⬆

GPU                                                         合成 -> 显示


纯合成动画的优势（再强调）
绕过主线程： 动画逻辑（如滚动位置更新、变换计算）在合成线程执行。

无 JS、样式计算、布局、绘制： 不需要主线程参与这些昂贵操作。

重用光栅化结果： 通常只需改变纹理的变换矩阵（位置、旋转、缩放）或透明度，无需重新光栅化图块内容。

GPU 高效合成： GPU 极其擅长执行这种纹理变换和混合操作。

与 VSync 更好同步： 减少卡顿

## 回流与重绘

### 重绘

重绘一般是只需要改动某些页面元素的样式，例如背景色、字号色等，不会影响其他元素的布局，因此只需要重新渲染这个dom，性能会好些

如果连续多次修改样式，浏览器会合并执行，一般是60ms内的

元素的视觉样式发生改变（如颜色、背景色、边框样式等），但不影响其几何属性和其他元素的位置。这跳过了布局阶段，但需要重新执行绘制（Painting）（生成新的绘制指令）和受影响区域的重新光栅化（Rasterization）。比重排开销小，但也不可忽视。

### 回流

元素的几何属性（位置、尺寸）发生改变，影响了文档流或其他元素的位置。这必须触发整个或部分渲染树的重新布局（Layout）。这是最昂贵的操作。

#### 影响因素

- 元素大小、位置等的变化，会影响到其他布局

- 强制重排：js获取一些与排版有关的信息时，为了保证信息的准确性，会进行同步计算样式和排版信息给js

    - 获取元素、窗口大小
    - 滚动
    - 获取鼠标指针位置
    - 进行样式计算（getCompitedStyle
    
## 资源加载

### script

js有三种加载方式，`normal`、`defer`、`async`，normal是script标签上不会添加属性，defer是script标签上添加defer属性，async是script标签上添加async属性

normal：js加载执行和html解析互斥，即在加载解析js时会停止html的解析

defer和async都可以让js加载和html同步进行，在加载时不影响html的解析，但是在解析时依旧影响

- defer

    - 加载完不会立马执行，而是等所有元素解析完后再执行，在`DOMContentLoaded`事件触发时执行
    - 可以保证加载顺序

- async

    - 加载完后立马解析
    - 无法保证执行顺序，因为可能每个文件加载完成时间不同，可能文件靠后的反而先加载完成，那么也会先执行

### link

css加载可以通过`normal`、`import`、`prefetch`和`preload`

- normal
    - 默认加载方式，会阻塞html的解析,浏览器必须等待CSS加载并构建CSSOM

- import
    - 在css文件中使用import引入其他css文件
    - 链式依赖导致浏览器需按顺序加载所有关联CSS

- prefetch: 空闲，低优先级
    - 预先加载，可以在浏览器空闲的时候加载文件，一般是对用户行为的一种判断
    - 不会阻塞页面渲染
    - 资源下载优先级为 Lowest（浏览器空闲时才加载）
    - 下载过程完全在后台进行，与 DOM 解析、CSSOM 构建并行

- preload：通用预加载，高优先级
    - 对当前页面的资源进行提前加载，但不解析
    - 可能会阻塞页面渲染
    - preload 资源在 HTML 解析过程中被立即发现时启动加载。浏览器在构建 DOM 树的过程中，首次遇到带有 rel="preload" 的标签时，会立即以高优先级发起网络请求，无需等待其他资源。

- modulepreftech：主要Chromium支持，高优先级
    - 转为es模块设计
    - 不仅加载模块，还会递归加载依赖树
    - 加载且解析模块（不执行，将解析结果放在模块映射中
    - 使用 modulepreload 时，获取请求的模式始终是 cors，并使用 crossorigin 属性来确定请求凭证模式。如果 crossorigin 设置为 anonymous 或 ""（默认），则凭证模式是 same-origin，并且仅对同源请求发送用户凭证，如 cookies 和身份验证信息。如果 crossorigin 设置为 use-credentials，则凭证模式是 include，用于单源和跨源请求的用户凭证。



### 域名

- dsn-prefetch

可以在浏览器空闲的时候把域名转为ip

`<link rel="dns-prefetch" href="//baidu.com" />`