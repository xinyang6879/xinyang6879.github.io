---
title: 小程序设计原理
categories: 小程序
tags:
- 小程序
- 前端 
---

小程序是双线程模型，架构分为3层：
- 逻辑层

    主要进行数据请求和业务逻辑处理，通过js引擎提供的沙箱环境执行js。与浏览器web比，逻辑层无法直接操作dom和bom，无法使用一些浏览器暴露的接口（例如跳转动态执行脚本）

    逻辑层主要负责将数据处理后再发送给渲染层，同时接收渲染层的事件反馈，对数据进行反向操作。对于小程序来说，逻辑层就是所有js文件的集合
- 渲染层

    主要在webview线程中执行界面渲染相关的任务，对于小程序来说，渲染层就是所有wxml和wxss文件的集合

    通过虚拟dom减少渲染开销，提高局部更新数据和重渲染的效率，让页面更加流程

- 系统层

    通过JSBridge构建js和Native之间的通信，以便上层间接调用客户端的原生底层接口
    
    提供请求、数据缓存、本地文件、媒体等基础能力

    为逻辑层和渲染层的通信中转

在双线程模型下，把界面渲染和逻辑处理分开、并行处理，可以加快渲染速读，避免单线程模型下因为js运算时间过长而导致ui卡顿等问题。采用数据驱动的方式，开发者无法直接操作dom，可以加强管控和安全，但双线程也会带来通信延时的问题

## 小程序设计原理
### 小程序运行环境
| 运行环境 | 逻辑层 | 渲染层|
| -----| ----- | ----- |
|IOS | 内置的JavaScriptCore | WKWebview | 
| Android | 旧版X5 JSCore，新版V8 JS引擎 | chromium定制内核 |
| 小程序开发工具 | NWJS | Chrome Webview |

微信客户端有js的解释引擎，因此可以使用一个单独的js线程作为沙箱环境运行小程序的业务代码。

渲染相关的任务在webview线程里面，然后通过逻辑层代码控制渲染的逻辑。
把开发者的逻辑代码放入单独的线程运行，不在webview线程里面，因此这个环境中没有webview的任何接口，因此开发者无法直接操作DOM，也无法动态更改界面或抓取数据

### 逻辑层
小程序运行开发者的业务代码，这些代码会被打包成一份js文件。在运行时，从后台下载，被销毁时，停止运行。有点类似于浏览器的Service Worker，因此逻辑层也可以称为是App Service

小程序每个界面都是一个单独的Webview线程，但小程序只有一个逻辑线程

### 渲染层

渲染层包括多个webview，小程序的各个界面被管理在一个页面栈中，界面渲染的相关任务全都在webview线程里执行，通过逻辑层代码去控制渲染哪些页面。

页面渲染流程
- 新建页面在渲染层进行：渲染层WXML生成一个虚拟dom的js对象，拼接shadow tree，注入初始数据进行渲染
- 逻辑层调用setData，更新数据到渲染层：逻辑层执行逻辑，调用setData后，将setData的数据通过Native传递到渲染层
- 渲染层页面更新：渲染层对新的数据进行diff，获取到对应的差异，然后把差异应用到真实dom上，更新页面

#### 自定义组件
自定义组件需要用this获取到组件实例，对于每个组件的生命周期事件，渲染层都需要通知逻辑层，这样会导致线程通信过于频繁。

但如果将自定义组件的虚拟dom和创建组件在逻辑层进行，就需要把完整的html传递给渲染层，这样会导致传递的数据过于庞大

| 创建方式 | 同步方式 | 优点 | 缺点 | 
| -----| ----- | ----- | ----- |
|渲染层创建 | 组件创建及其他关键事件，通知逻辑层 | 减少通信数据大小 | 有很多双向通信和线程间等待 |
| 逻辑层创建  | 传递创建后的shadow dom | 减少通信次数 | 通信数据量大 |

渲染流程
- 逻辑层新建组件，并通知渲染层：
    - 在逻辑层，将wxml和js需要生成一个js对象，然后js的节点部分生成虚拟dom信息，通过底层通信通知到渲染层。
    - 渲染层拿到虚拟dom节点信息后，创建shadow dom，拼接shadow dom，注入初始数据渲染
- 逻辑层调用setData，更新数据到渲染层：
    - 逻辑层执行逻辑，调用setData后，在**逻辑层**进行dom的**diff**，然后将diff结果传到渲染层（这里和页面的渲染流程不一致
- 渲染组件更新：渲染层拿到diff信息，更新虚拟dom节点信息，同时更新页面

### 双线程通信
#### 虚拟dom
小程序中也使用到了虚拟dom，一次数据更新（setData）步骤：
- 在渲染层中，把wxml转化成对应的用于描述虚拟dom树的js对象
- 逻辑层发生数据变化的时候，通过宿主环境提供的setData方法把变更从逻辑层传递到Native，再转发到渲染层
- 在渲染层中，经过前后对比差异，把差异应用在原来的虚拟dom上，更新界面

#### 通信方式
由于限制数据的通信，模板渲染需要以来虚拟dom的思路解决。在小程序中，双线程通信时会将需要传输的数据转换为字符串形式

以下是setData调用的过程

- 调用setData，底层会使用JSON.stringify处理一遍数据，一些不可序列化的数据将被移除
- 逻辑层将数据发送给渲染层，同步更新页面的data数据。这样确保开发者在逻辑层获取的this.data是最新的数据
- 数据传输需要Native进行中转，因此并不能实时到达渲染层，所以setData将数据从逻辑层发送到渲染层是异步的。如果需要知道页面渲染完毕，setData提供了其回调进行监听

因此从上面的流程可以看出，setData只接受可以被序列化的数据，且单次设置的数据不超过1024KB

### 原生组件

#### 引入原因

逻辑层和渲染层的每一次通信都需要经过系统层，就会导致用户和页面的一次交互会触发最多4次通信
- 渲染层 -> Native（点击、输入事件等
- Native -> 逻辑层 （事件监听
- 逻辑层 -> Native（开发者事件触发回调，调用setData
- Native -> 渲染层

如果是输入框的情况，输入一次至少触发4次通信：输入（前两个通信），setData到输入框（后两次通信。如果用户不停输入，就容易导致页面出现卡顿

#### 引入原生组件

小程序是Hybrid应用，除了web组件的渲染体系，还有由客户端参与组件（原生组件）的渲染，原生组件可以直接与逻辑层通信

引入原生组件后，组件和逻辑层的通信绕过了setData，避开数据通信和重渲染流程。逻辑层可以和原生组件直接通信，节省交互过程的中转通信次数，减少webview的计算和渲染工作

小程序的输入框在聚焦时是原生组件，在失焦时是普通的web输入框，因此样式会有不一致的地方

使用原生组件渲染过程
- 渲染层依据逻辑层传入的数据创建组件
- 组件被插入页面，同时根据样式和属性涉及，webview渲染布局，得到组件的位置和宽高
- 将计算得到的数据告诉客户端，客户端可以将原生组件渲染到具体位置上

相当于使用webview生成一个dom，然后计算布局信息给客户端进行渲染。

但是这个也会导致一个问题，原生组件的层级会比所有其他webview的组件高。另外，部分css样式无法应用于原生组件

#### 同层渲染
为了解决原生组件层级高于其他webview渲染的组件的问题

- ios同层渲染

    ios下，小程序是通过使用WkWebview进行渲染的，其为了让ios的webview滚动更有流畅的体验，页面的滚动实际上是由真正的原生滚动组件（WKChildScrollView）承载的。

    ios同层渲染利用了这一特性，WKChildScrollView虽然是原生组件，但是在WebKit内部已经处理了其与其他dom之间的层级关系。因此小程序通过将原生组件插入到WKChildScrollView，直接使用wxss控制层级
- Android同层渲染
    安卓是基于chromium内核开发的扩展，chromium支持webPlugin机制（浏览器内核的一个插件机制），主要用于解析和描述embed标签。安卓端支持原生组件的画面绘制到embed标签生成的RenderLayer所绑定的SurfaceTexture上，从而实现同层渲染

同层渲染依然有需要注意的地方：
- 原生组件的同层渲染能力可能会失效，失败后触发bindrendererror事件
- 由于同层渲染是将原生组件渲染到某个webview组件上，所以有些对组件本身进行裁剪的样式不会生效
- 原生组件不支持冒泡，但同层渲染后的原生组件支持

### 小程序基础库

包括：
- 提供虚拟dom渲染机制相关基础代码，解决双线程的渲染问题
- 提供封装后的内置组件
- 提供逻辑层的api
- 提供其他补充能力的基础代码

小程序管理组件的框架：Exparser，简化版的shadow dom

自定义组件运行时也受到Exparser的管理。首先小程序启动会调用Component构造器，开发者设置的properties、data、methods这些字段会记录在Exparser的组件注册表中，其他组件在引用这个组件时会获取这些信息

在初始化页面时，页面会有一个根组件实例，然后根据开发者使用的内置组件或自定义组件的情况，递归地创建这些组件。Exparser会通过组件树拼接的方式，最终拼接成一个页面。因此Page构造器的大体运行流程和自定义组件类似，只是参数形式不一样

#### 小程序启动

启动流程：
- 准备页面过程，包括逻辑层和渲染层分别进行初始化以及公共库的注入。逻辑层和渲染层是并行准备的，并不会相互依赖组件（页面预渲染
    - 初始化JSCore-》注入appService基础库；
    - 初始化webview-》 注入webview基础库
- 用户打开进入小程序后，小程序开发下载业务代码，同时在本地创建基础ui（内置组件）。准备完成后，开发注入业务代码，启动运行业务逻辑
- 小程序启动时，微信会被小程序展示一个固定的启动界面，界面内包含小程序的图标名称和加载logo。此时微信会进行：下载小程序代码包、加载小程序代码包、初始化小程序首页

为了用户体验，小程序在打开前，已经准备好了一个webview层，当这个预加载的webview被使用了之后，一个新的webview层同样会被提前加载。

webview层级准备会提前准备好一个webview，包括启动webview、初始化基础库等

#### 代码包下载

通常来说，当用户打开的时候，如果本地缓存有旧的代码包，会优先使用缓存中的代码，同时异步下载最新的代码包，新下载的代码包会在下一次冷启动的时候使用。如果本地没有缓存，那么就直接下载最新的代码包运行

代码包下载完成后，小程序就可以开始加载业务代码。小程序启动时，会未小程序准备好通用的运行环境
- 在逻辑层中，app.js首页所在的js文件及首页依赖的js文件都会被自动执行一次
- 渲染层中，所有页面和页面中用到的组件都会在基础库中进行注册

小程序入口是app.js，如果app.js依赖了其他文件，则会按顺序进行加载。然后以及app.json中的pages顺序执行对应的文件。如果一个页面被多次创建，小程序会去基础库中获取这个页面注册的信息，重新生成页面实例，而这个页面的js文件只会执行一次。因此，即使这个页面被销毁再重新加载，页面中如果修改过全局变量的值，修改后的值依旧会被保留

## 参考书
- 小程序开发原理与实战（王贝珊 李成熙）