---
title: 【云托管】无头浏览器生成图片并上传到对象储存
time: 2025-04-03 16:00:00
categories: 小程序
---

## 无头浏览器截图

使用库 puppeteer

云托管 cli 的 nodejs 版本是 14.20.1，因此最新的 puppeteer 不兼容，部署发布会报错，需要将其降低到 17

- dockerFile 配置字体

没有配置导致中文字体出现方括号

```dockerfile
RUN apt-get update && \
    apt-get install -y \
    fonts-arphic-ukai \
    fonts-arphic-uming \
    fonts-ipafont-mincho \
    fonts-unfonts-core
```

- 开启无头浏览器

```js
let browser;
// 启动浏览器
browser = await puppeteer.launch({
  headless: true,
  executablePath: process.env.PUPPETEER_EXECUTABLE_PATH,
  args: [
    "--no-sandbox",
    "--disable-setuid-sandbox",
    "--disable-dev-shm-usage",
    "--single-process",
  ],
  timeout: 60000, // 增加超时时间
});
// 开启一个新的标签页
const page = await browser.newPage();
```

- 加载对应页面

```js
// 读取 HTML 文件
const filePath = path.join(__dirname, "./template-1.html");
let htmlContent = fs.readFileSync(filePath, "utf8");

const escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
for (const [key, value] of Object.entries(dataToReplace)) {
  const escapedKey = escapeRegExp(key);
  htmlContent = htmlContent.replace(new RegExp(escapedKey, "g"), value);
}
// 加载修改后的 HTML 内容
await page.setContent(htmlContent, { waitUntil: "networkidle0" });

// 设置视口大小
// 修改后：根据 4 倍缩放调整视口
await page.setViewport({
  width: 220,
  height: 176,
  deviceScaleFactor: 2,
});
```

- 截图保存

```js
// 1. 创建截图目录
const screenshotDir = path.join(__dirname, "screenshots");
if (!fs.existsSync(screenshotDir)) {
  fs.mkdirSync(screenshotDir, { recursive: true });
}
const name = Math.random() + "_screenshot.png";
const picName = path.join(screenshotDir, name);
// 添加字体加载等待
await page.evaluate(async () => {
  const ensureFonts = (callback) => {
    document.fonts.ready.then(callback);
  };
  await new Promise((resolve) => ensureFonts(resolve));
});
// 截图并保存
await page.screenshot({ path: picName, fullPage: true });
```

## 上传到对象储存

https://developers.weixin.qq.com/miniprogram/dev/wxcloudservice/wxcloudrun/src/development/storage/service/upload.html

上传到对象储存需要走两部，获取上传链接，然后再进行文件上传

服务端可以通过配置云调用，将`tcb/uploadfile`和`tcb/batchdownloadfile`配置到云调用中，那么服务端就不需要再传 access_token 了，且可以通过`req.headers?.["x-wx-openid"]`获取到用户的 unionid

### 获取上传链接

uploadFileResponse 返回的 token 有效期是半小时

同名的文件是被覆盖

```js
const uploadFileResponse = await axios.post(
  "http://api.weixin.qq.com/tcb/uploadfile",
  {
    env: "微信云托管环境ID",
    path: `shareCard/${name}`, //目录及文件名称
  }
);
if (uploadFileResponse.status !== 200 || !uploadFileResponse.data.url) {
  await browser.close();
  reject(uploadFileResponse);
  return;
}
```

### 文件上传

接口链接是获取上传链接时返回的 url，依据接口的参数拼接

此接口无返回，状态码 status 返回 204，因此不要判断其状态码是 200 才算是正常的！！！

```js
const result = uploadFileResponse.data;
const data = new FormData();
data.append("key", `shareCard/${name}`);
data.append("Signature", result.authorization);
data.append("x-cos-security-token", result.token);
data.append("x-cos-meta-fileid", result.cos_file_id);
const fileStream = fs.createReadStream(picName);
data.append("file", fileStream, {
  filename: name,
  contentType: "image/png",
  knownLength: fs.statSync(picName).size,
});
// COS 直传
const uploadRes = await axios.post(result.url, data, {
  headers: data.getHeaders(),
});
```

### 获取文件下载链接

服务端和小程序端都有获取到文件下载链接的方法，小程序可以通过 fileid 直接在 image、video 等标签中直接显示

- 服务端获取文件下载链接

如果之前给的下载链接未失效，那么此图片修改后，对应的下载链接的图片也会更新

```js
const getFileLinkResponse = await axios.post(
  "http://api.weixin.qq.com/tcb/batchdownloadfile",
  {
    env: "微信云托管环境ID",
    file_list: [
      {
        fileid: result.file_id,
        max_age: 7200, //失效时间
      },
    ],
  }
);
const [fileInfo = {}] = getFileLinkResponse.data?.file_list || [];
const download_url = fileInfo.download_url;
```

```ts
type FileInfo = {
  fileid: string; // 文件ID
  download_url: string; // 下载链接
  status: number; // 状态码
  errmsg: string; // 该文件错误信息
};
```

## 储存数据库

依据 unionid，fileid 储存到数据库中

### 定义数据表

```js
// db.js
const { Sequelize, DataTypes } = require("sequelize");
// 从环境变量中读取数据库配置
const { MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_ADDRESS = "" } = process.env;

const [host, port] = MYSQL_ADDRESS.split(":");

const sequelize = new Sequelize("nodejs_demo", MYSQL_USERNAME, MYSQL_PASSWORD, {
  host,
  port,
  dialect: "mysql" /* one of 'mysql' | 'mariadb' | 'postgres' | 'mssql' */,
});

// 定义新的数据模型
const UserShareStyle = sequelize.define("UserShareStyle", {
  unionid: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true, // 确保每个 unionid 是唯一的
    index: true,
  },
  fileId: {
    type: DataTypes.STRING,
    allowNull: false,
  },
});

// 数据库初始化方法
async function init() {
  await UserShareStyle.sync({ alter: true });
}

// 导出初始化方法和模型
module.exports = {
  initDB: init,
  UserShareStyle,
};
```

入口文件声明

```js
// index.js
async function bootstrap() {
  await initDB();
  app.listen(port, () => {
    console.log("启动成功", port);
  });
}
```

### 插入数据

```js
// 获取到用户unionid
const unionid = req.headers?.["x-wx-openid"];
const [record, created] = await UserShareStyle.upsert(
  { unionid, fileId: result.file_id }, // 更新或插入的数据
  { where: { unionid } } // 根据 unionid 操作
);
if (created) {
  console.log("插入新记录成功");
} else {
  console.log("更新记录成功");
}
```
