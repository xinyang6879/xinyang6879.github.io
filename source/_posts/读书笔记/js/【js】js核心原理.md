---
title: js核心原理
categories: js
tags:
- js
- 前端 
---

### js语言基础

- 所有赋值运算的含义是，将右边的“值”赋给左边用于包含该值的“引用”
- delete x：删除一个表达式的引用类型的结果
- delete x只能删除一种引用，即对象的属性   

- 赋值表达式运算本身是有结果的，因此在连续赋值时，赋值的都是右方的运算结果
    ``` js
        let obj
        obj = {
        f: function () {
            console.log(this)
            return this === obj
        },
        };
        b=((a = obj.f))()

        //执行结果：
        // b false
        // a ƒ () {} 且this指向window
    ```
- ``` js  var a={n:1}; a.x= a = {n:2}```执行流程：
    - 《JavaScript权威指南》说：js总数严格按照从左至右的顺序左表达式运算
    - 计算a.x表达式的结果，结果是一个引用，因此通过这个引用保存了一些计算过程中的信息（例如保存了a这个对象），以备后续运算中可能会作为this来使用
    - 执行a，由于a是当前环境的变量，与上一次暂存的值是相同的
    - 赋值{n：2}，左运算符a作为一个引用被覆盖了，这个引用仍是当前上下文中那个变量a（var声明的a）。因此这里确实是发生了一次赋值操作a={n：2}。
    - a.x表达式被保留在一个结果中的引用a不会更新，因为只是一个运算结果，这个结果有且仅有引擎知道。现在是一个引擎才理解的引用，对它的可能操作只有取值（GetValue()）或置值（PutValue()），以及想其他地方传递这个引用，被后续typeof和delete等运算符使用
    - 整个语句行最右左边“空悬”了一个已经求值过的**a.x**。当它作为赋值表达式的做运算数时，是一个被赋值的引用。而它作为结果所保留的a是在被第一个赋值运算之前的那个**原始变量a**。即，如果访问它的a.n，那么值是1，因此如果在这里可以访问这个原始变量a时，是可以获取到a.x的。但是由于在a={n:2}时，将之前的{n:1}的引用丢弃了，所以最后a.x是undefined

- 执行
    ``` js
    var a={n:1}, b=a
    a.x= a = {n:2}
    // 执行结果：
    // b {x:{n:2}，n：1}
    // a {n:2}
    ```

- 具名函数作为表达式时名字在块级作用域中无意义
    ``` js
    let fn1 = function fn(){}
    // fn这个名字是无意义的
    ```
- 如果export default后面导出的是匿名函数（export default function(){}），那么它将强制在当前作用域中登记为*default*这样一个特殊的名字，并且在执行时绑定该匿名函数。因此在语意上将其登记为类似`var default...`声明的名字default，而实际处理时为它创建一个不可访问的中间名字，然后映射给该模块的某个名字表。
- 为什么导出需要给个默认名称，实际在import/export的处理逻辑需要一个运行期的名字绑定操作

- let/const语句的单次声明（不可覆盖）的设计，与迭代多次执行的现实逻辑是矛盾的，因此这里为循环体增加了一个作用域
- for循环时如果包含了闭包，那么在每次迭代都创建一个新的作用域副本，这称为迭代环境，且每次迭代都不是运行在loopEnv中，而是运行在该次迭代自有的iterationEnv中              

### 从原型到类
- super指向父类
- [[HomeObject]]
    - 如果是类声明中的静态声明（即用static声明）的方法，主对象就是这个类
    - 如果是类声明中的其他方法，主对象就是这个类使用的原因，即AClass.prototype
    - 如果是字面量风格的对象声明，方法的主对象就是这个对象本身
- `super.xxx`在语言内核上是一个“引用（规范类型）”，ES约定将这个语法标记为“Super引用”（Super Reference），并且为它的引用记录专门添加了一个thisValue字段，这个字段在函数的执行上下文也有一个。ES还约定，优先取Super引用中的thisValue值，然后取函数执行上下文中的
    - ES关于super两项关键性设计：通过这个thisValue传递上下文中的this；在delete右边的操作数如果是一个Super引用就抛出异常
- super关键字代表的父类对象是通过当前方法的[[HomeObject]]的原型链来查找的
- this引用是从当前环境绑定的this中抄写过来并绑定到super的
-