---
title: 【js】小点
categories: JS
tag: js
---

### 检测一个数是否是整数

将这个值转为十进制，如果是整数，那么十进制后的值和原本的值是相等的；如果不是，那么就不相等
``` js
parseInt(num) === num
```

### 去除字符串空格

- 利用正则
``` js
// 去除所有空格
const re=/\s+/g;
// 去除开头空格
const re=/\s+/;
// 去除结尾空格
const re=/\s+$/;
str.replace(re,'');
```

- 使用trim()方法去除首尾空格

### undefined和null异同

相同点

- 都表示无数据
- boolean后都是false

不同点

- null表示一个对象变量已经初始化,但未装入对象; undefined则是未初始化变量
- null表示"无"的对象,转为数值后是0; undefined表示"无"原始值,转为数值后是NaN
- null
    - 作为函数参数,表示该函数的参数不是对象
    - 作为对象原型链的终点
- undefined
    - 变量被声明了,但没有赋值
    - 调用函数时,没有传的参数时
    - 函数没有返回值,默认返回undefined
    - 对象没有赋值的属性

### 先执行冒泡事件还是捕获事件

事件顺序: 其他元素捕获阶段->本元素代码顺序->其他元素冒泡阶段

先执行捕获.从上往下,如果有捕获,则执行,一直向下到目标元素后,从目标元素开始向上执行冒泡元素

### 查找页面zindex最大的元素

- 获取所有元素
- 使用`window.getComputedStyle(_DOM).zIndex`获取实际的zindex
- 进行查找对比

### 引入js文件
- html的head, body中写script标签
- script的src引入外部文件
- 元素事件中引入

    ``` js
        <button @click='alert("")'>btn</button>
    ```

### 获取节点方法
子节点
- getElementById/getElementByTagName/querySelector...
- childNodes获取子节点,会把换行和空格也作为子节点
- children
- firstChild:获取第一个子节点,可能是换行或空格
- firstElementChild: 获取第一个真正的子节点,不包括换行或空格
- lastChild

父节点
- parentNode: W3C标准
- parentElement: IE标准
- offsetParent: 获取所有父节点

兄弟节点:
- previousSibling/previousElementSibling: 前者包含换行和空格
- nextSibling/nextEmementSibling

### DOM节点类型
12种

- 元素节点:nodeType=1

    对应HTML标签元素, nodeName是大写的标签名,nodeValue是null
- 特性节点: nodeType=2

    对应HTML标签的属性,只存在于元素的attributes属性中,并不是DOM树的一部分, nodeName是属性名,nodeValue是属性值
- 文本节点: 3

    text代表网页的HTML标签内容, nodeName是'#text',nodeValue是标签内容值

- CDATA节点: 4

    只针对基于XML的文档, nodeName是'#cdata-section',nodeValue是CDATA区域中的内容

- 实体引用名称节点

    实体是一个声明,指定了在XML中取代内容或标记而使用的名称, nodeName是实体引用的名称,nodeValue是null

- 实体名称节点

     nodeName是实体名称,nodeValue是null

- 处理指令节点

    , nodeName是target,nodeValue是entire content excluding the target

- 注释节点: 8

    nodeName是'#comment',nodeValue是null

- 文档节点/根节点: 9

    nodeName是'#document',nodeValue是null

- 文档类型节点

    包含与文档的doctype有关的所有信息, nodeName是doctype的名称,nodeValue是null

- 文档片段节点

    在文档中没有对应的标记,是一种轻量级的文档,可以包含控制节点,但不会向完整的文档占用额外的资源, nodeName是'#document-fragment',nodeValue是null

- DTD声明节点:12

    nodeName是符号名称,nodeValue是null


### 宿主对象,原生对象

原生对象:ECMA-262把本地对象定义为"独立于宿主环境的ECMAScript实现提供的对象"

本地对象包括:Object,Function,Array,String,Boolean,Number,Date,RegExp,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError

内置对象:定义为"由ES实现提供的,独立于宿主环境的所有对象,在ES程序开始执行时出现",这意味着开发者不需要明确实例化内置对象,它已经被实例化了

内置对象包括:Global和Math

宿主对象:网页的运行环境,即DOM和BOM

### this

- 方法调用

    当函数被保存为一个对象属性时,该函数是该对象的方法,this指向该对象

- 函数调用

    this指向全局

- 构造器调用

    使用new调用的函数,this将会绑定到这个新创建的对象

- apply/call

    this指向传入的第一个参数

### JSONP

客户端定义一个函数,然后创建script标签,src为url+?jsonp=函数名,之后服务器会生成一个和传递过来的和函数名一样名字的参数,并把需要传递的数据当作擦书传入,然后返回给客户端,此时客户端就指向了这个服务器端返回的函数回调

客户端定义一个函数,然后请求,服务器返回的js内容就是调用这个函数,需要的数据都作为参数传入这个函数

JSONP是一种非官方跨域数据交互协议,允许在服务器端集成script标签返回给客户端,通过js回调的形式实现跨域访问

由于同源策略的影响,跨域会报错,但是script可以访问外部资源,可以绕过同源协议

### 如何实现页面的前进后退

监听路由的变化事件hashchange与路由的第一次加载事件load

- url存在于浏览记录即为后退,后退时,把当前路由后面的浏览记录删除
- url不存在浏览记录是前进,前进时,push在当前路由的数组中
- url在浏览器末端是在刷新页面,不需要对路由数据做任何操作

注:数组可能存在多次相同的路由,应该用key来区分相同路由的不同实例

用两个栈实现浏览器的前进后退功能, 使用两个栈X和Y,把首次浏览的页面依次压入栈X,当单击"后退"时,再依次从栈X中出栈,并将其放入Y中.当点击"前进"按钮时,从Y中出栈,将其放入X中.当X中无数据时,说明页面无法继续后退;当Y中无数据时,说明页面无法前进

- 进入了多个页面a,b,c:将abc压入X栈,此时在c页面
- 后退两步,将bc从X中弹出,放入Y栈,此时在a页面
- 前进一步,将b从Y中弹出,放入X栈,此时在b页面
- 打开新页面d,将d压入X栈,此时在d页面
- 清空Y,此时无法前面或后退到c页面
